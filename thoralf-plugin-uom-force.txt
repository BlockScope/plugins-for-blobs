Resolving dependencies...
Build profile: -w ghc-8.2.2 -O1
In order, the following will be built (use -v for more details):
 - thoralf-plugin-uom-0.1.0.0 (lib) (configuration changed)
 - thoralf-plugin-uom-0.1.0.0 (test:force) (configuration changed)
Configuring library for thoralf-plugin-uom-0.1.0.0..
Preprocessing library for thoralf-plugin-uom-0.1.0.0..
Building library for thoralf-plugin-uom-0.1.0.0..
Configuring test suite 'force' for thoralf-plugin-uom-0.1.0.0..
Preprocessing test suite 'force' for thoralf-plugin-uom-0.1.0.0..
Building test suite 'force' for thoralf-plugin-uom-0.1.0.0..
[1 of 2] Compiling UnitDefs         ( test-suite-force/UnitDefs.hs, /Users/pdejoux/dev/src/blockscope/plugins-for-blobs/dist-newstyle/build/x86_64-osx/ghc-8.2.2/thoralf-plugin-uom-0.1.0.0/t/force/build/force/force-tmp/UnitDefs.o ) [Plugins.Thoralf.UoM changed]
newTcEvBinds unique = a4X
tcPluginInit thoralf-uom-plugin
tcPluginInit uom-eq-plugin
tcPluginInit uom-unpack-plugin
tcPolyExpr Check{Language.Haskell.TH.Lib.DecsQ}
tcPolyExprNC Check{Language.Haskell.TH.Lib.DecsQ}
tcSkolemise
tcInferId
  Language.Haskell.TH.Quote.quoteDec :: Language.Haskell.TH.Quote.QuasiQuoter
                                        -> String
                                        -> Language.Haskell.TH.Syntax.Q
                                             [Language.Haskell.TH.Syntax.Dec]
tcPolyExprNC Check{Language.Haskell.TH.Quote.QuasiQuoter}
tcSkolemise
tcInferId u :: Language.Haskell.TH.Quote.QuasiQuoter
tcCheckId
  u
  Language.Haskell.TH.Quote.QuasiQuoter
  Check{Language.Haskell.TH.Quote.QuasiQuoter}
tcWrapResult
  Actual:   Language.Haskell.TH.Quote.QuasiQuoter
  Expected: Check{Language.Haskell.TH.Quote.QuasiQuoter}
tc_sub_type_ds
  ty_actual   = Language.Haskell.TH.Quote.QuasiQuoter
  ty_expected = Language.Haskell.TH.Quote.QuasiQuoter
deeply_instantiate final subst
  origin: arising from a use of ‘u’
  type: Language.Haskell.TH.Quote.QuasiQuoter
  new type: Language.Haskell.TH.Quote.QuasiQuoter
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Language.Haskell.TH.Quote.QuasiQuoter
  ~
  Language.Haskell.TH.Quote.QuasiQuoter
  arising from a type equality Language.Haskell.TH.Quote.QuasiQuoter
                               ~
                               Language.Haskell.TH.Quote.QuasiQuoter
u_tys yields no coercion
tcPolyExprNC Check{String}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{String}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = String
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ String
  arising from a type equality [Char] ~ String
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ String
u_tys yields no coercion
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = Language.Haskell.TH.Syntax.Q
                  [Language.Haskell.TH.Syntax.Dec]
  ty_expected = Language.Haskell.TH.Lib.DecsQ
deeply_instantiate final subst
  origin: arising from a use of ‘Language.Haskell.TH.Quote.quoteDec’
  type: Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  new type: Language.Haskell.TH.Syntax.Q
              [Language.Haskell.TH.Syntax.Dec]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  ~
  Language.Haskell.TH.Lib.DecsQ
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 [Language.Haskell.TH.Syntax.Dec]
                               ~
                               Language.Haskell.TH.Lib.DecsQ
u_tys
  tclvl 1
  [Language.Haskell.TH.Syntax.Dec] ~ [Language.Haskell.TH.Syntax.Dec]
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 [Language.Haskell.TH.Syntax.Dec]
                               ~
                               Language.Haskell.TH.Lib.DecsQ
u_tys
  tclvl 1
  Language.Haskell.TH.Syntax.Dec ~ Language.Haskell.TH.Syntax.Dec
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 [Language.Haskell.TH.Syntax.Dec]
                               ~
                               Language.Haskell.TH.Lib.DecsQ
u_tys yields no coercion
u_tys yields no coercion
u_tys yields no coercion
simplifyTop { wanted =  WC {}
newTcEvBinds unique = a4iW
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyTop }
reportUnsolved {
newTcEvBinds unique = a4iX
reportUnsolved }
reportUnsolved (unsafe overlapping) {
reportUnsolved (unsafe overlapping) }
About to run Language.Haskell.TH.Quote.quoteDec u " m, kg, s "
About to run (desugared)
  Language.Haskell.TH.Quote.quoteDec
    u (GHC.CString.unpackCString# " m, kg, s "#)
Got TH result:
  type instance Data.UnitsOfMeasure.Syntax.MkUnit "m" = Data.Theory.UoM.Base "m"
instance Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
type instance Data.UnitsOfMeasure.Syntax.MkUnit "kg" = Data.Theory.UoM.Base "kg"
instance Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
type instance Data.UnitsOfMeasure.Syntax.MkUnit "s" = Data.Theory.UoM.Base "s"
instance Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
Got HsSyn result:
  [type instance Data.UnitsOfMeasure.Syntax.MkUnit "m" = Data.Theory.UoM.Base "m",
   instance Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m",
   type instance Data.UnitsOfMeasure.Syntax.MkUnit "kg" = Data.Theory.UoM.Base "kg",
   instance Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg",
   type instance Data.UnitsOfMeasure.Syntax.MkUnit "s" = Data.Theory.UoM.Base "s",
   instance Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"]
tcPolyExpr Check{Language.Haskell.TH.Lib.DecsQ}
tcPolyExprNC Check{Language.Haskell.TH.Lib.DecsQ}
tcSkolemise
tcInferId
  Language.Haskell.TH.Quote.quoteDec :: Language.Haskell.TH.Quote.QuasiQuoter
                                        -> String
                                        -> Language.Haskell.TH.Syntax.Q
                                             [Language.Haskell.TH.Syntax.Dec]
tcPolyExprNC Check{Language.Haskell.TH.Quote.QuasiQuoter}
tcSkolemise
tcInferId u :: Language.Haskell.TH.Quote.QuasiQuoter
tcCheckId
  u
  Language.Haskell.TH.Quote.QuasiQuoter
  Check{Language.Haskell.TH.Quote.QuasiQuoter}
tcWrapResult
  Actual:   Language.Haskell.TH.Quote.QuasiQuoter
  Expected: Check{Language.Haskell.TH.Quote.QuasiQuoter}
tc_sub_type_ds
  ty_actual   = Language.Haskell.TH.Quote.QuasiQuoter
  ty_expected = Language.Haskell.TH.Quote.QuasiQuoter
deeply_instantiate final subst
  origin: arising from a use of ‘u’
  type: Language.Haskell.TH.Quote.QuasiQuoter
  new type: Language.Haskell.TH.Quote.QuasiQuoter
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Language.Haskell.TH.Quote.QuasiQuoter
  ~
  Language.Haskell.TH.Quote.QuasiQuoter
  arising from a type equality Language.Haskell.TH.Quote.QuasiQuoter
                               ~
                               Language.Haskell.TH.Quote.QuasiQuoter
u_tys yields no coercion
tcPolyExprNC Check{String}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{String}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = String
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ String
  arising from a type equality [Char] ~ String
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ String
u_tys yields no coercion
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = Language.Haskell.TH.Syntax.Q
                  [Language.Haskell.TH.Syntax.Dec]
  ty_expected = Language.Haskell.TH.Lib.DecsQ
deeply_instantiate final subst
  origin: arising from a use of ‘Language.Haskell.TH.Quote.quoteDec’
  type: Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  new type: Language.Haskell.TH.Syntax.Q
              [Language.Haskell.TH.Syntax.Dec]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  ~
  Language.Haskell.TH.Lib.DecsQ
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 [Language.Haskell.TH.Syntax.Dec]
                               ~
                               Language.Haskell.TH.Lib.DecsQ
u_tys
  tclvl 1
  [Language.Haskell.TH.Syntax.Dec] ~ [Language.Haskell.TH.Syntax.Dec]
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 [Language.Haskell.TH.Syntax.Dec]
                               ~
                               Language.Haskell.TH.Lib.DecsQ
u_tys
  tclvl 1
  Language.Haskell.TH.Syntax.Dec ~ Language.Haskell.TH.Syntax.Dec
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 [Language.Haskell.TH.Syntax.Dec]
                               ~
                               Language.Haskell.TH.Lib.DecsQ
u_tys yields no coercion
u_tys yields no coercion
u_tys yields no coercion
simplifyTop { wanted =  WC {}
newTcEvBinds unique = a4tm
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyTop }
reportUnsolved {
newTcEvBinds unique = a4tn
reportUnsolved }
reportUnsolved (unsafe overlapping) {
reportUnsolved (unsafe overlapping) }
About to run
  Language.Haskell.TH.Quote.quoteDec u " N  = kg m / s^2 "
About to run (desugared)
  Language.Haskell.TH.Quote.quoteDec
    u (GHC.CString.unpackCString# " N  = kg m / s^2 "#)
Got TH result:
  type instance Data.UnitsOfMeasure.Syntax.MkUnit "N" = Data.Theory.UoM./: (Data.Theory.UoM.*: (Data.UnitsOfMeasure.Syntax.MkUnit "kg")
                                                                                             (Data.UnitsOfMeasure.Syntax.MkUnit "m"))
                                                                         (Data.Theory.UoM.^: (Data.UnitsOfMeasure.Syntax.MkUnit "s")
                                                                                             2)
Got HsSyn result:
  [type instance Data.UnitsOfMeasure.Syntax.MkUnit "N" = (Data.Theory.UoM./:) ((Data.Theory.UoM.*:) (Data.UnitsOfMeasure.Syntax.MkUnit "kg") (Data.UnitsOfMeasure.Syntax.MkUnit "m")) ((Data.Theory.UoM.^:) (Data.UnitsOfMeasure.Syntax.MkUnit "s") 2)]
Tc2 (src)
Tc3
txExtendKindEnvList []
txExtendKindEnvList []
-------- tcTyClGroup ------------
Decls for []
kcTyClGroup module UnitDefs
txExtendKindEnv []
kcTyClGroup: initial kinds []
txExtendKindEnv []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = a4tp
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = a4tq
reportAllUnsolved }
kcTyClGroup result
tcTyAndCl generalized kinds
txExtendKindEnv []
Starting synonym cycle check []
Done synonym cycle check []
Starting family consistency check []
Done family consistency []
Starting validity check []
Done validity check []
tcAddImplicits
  tycons []
  implicits []
txExtendKindEnvList []
env2 []
tcFamInstDecl Data.UnitsOfMeasure.Syntax.MkUnit
env2 []
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "N"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
instantiating tybinders:
lk1 Data.Theory.UoM./:
tcTyVar2b
  Data.Theory.UoM./: :: Data.Theory.UoM.Unit
                        -> Data.Theory.UoM.Unit -> Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  -> Data.Theory.UoM.Unit -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] Data.Theory.UoM.Unit
  ((Data.Theory.UoM.*:) (Data.UnitsOfMeasure.Syntax.MkUnit "kg") (Data.UnitsOfMeasure.Syntax.MkUnit "m"))
lk1 Data.Theory.UoM.*:
tcTyVar2b
  Data.Theory.UoM.*: :: Data.Theory.UoM.Unit
                        -> Data.Theory.UoM.Unit -> Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  -> Data.Theory.UoM.Unit -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] Data.Theory.UoM.Unit
  (Data.UnitsOfMeasure.Syntax.MkUnit "kg")
lk1 Data.UnitsOfMeasure.Syntax.MkUnit
tcTyVar2b
  Data.UnitsOfMeasure.Syntax.MkUnit :: GHC.Types.Symbol
                                       -> Data.Theory.UoM.Unit
  GHC.Types.Symbol -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "kg"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
tc_infer_args (vis)
  [anon] Data.Theory.UoM.Unit
  (Data.UnitsOfMeasure.Syntax.MkUnit "m")
lk1 Data.UnitsOfMeasure.Syntax.MkUnit
tcTyVar2b
  Data.UnitsOfMeasure.Syntax.MkUnit :: GHC.Types.Symbol
                                       -> Data.Theory.UoM.Unit
  GHC.Types.Symbol -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "m"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
tc_infer_args (vis)
  [anon] Data.Theory.UoM.Unit
  ((Data.Theory.UoM.^:) (Data.UnitsOfMeasure.Syntax.MkUnit "s") 2)
lk1 Data.Theory.UoM.^:
tcTyVar2b
  Data.Theory.UoM.^: :: Data.Theory.UoM.Unit
                        -> GHC.Types.Nat -> Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit -> GHC.Types.Nat -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] Data.Theory.UoM.Unit
  (Data.UnitsOfMeasure.Syntax.MkUnit "s")
lk1 Data.UnitsOfMeasure.Syntax.MkUnit
tcTyVar2b
  Data.UnitsOfMeasure.Syntax.MkUnit :: GHC.Types.Symbol
                                       -> Data.Theory.UoM.Unit
  GHC.Types.Symbol -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "s"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
tc_infer_args (vis)
  [anon] GHC.Types.Nat
  2
u_tys
  tclvl 1
  GHC.Types.Nat ~ GHC.Types.Nat
  arising from a type equality GHC.Types.Nat ~ GHC.Types.Nat
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Nat
  GHC.Types.Nat
  <GHC.Types.Nat>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
tcImplicitTKBndrs
  []
  []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = a4tt
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = a4tu
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
tcFamTyPats
  Data.UnitsOfMeasure.Syntax.MkUnit
  ["N"]
  []
env2 []
lk1 Data.Theory.UoM./:
tcTyVar2b
  Data.Theory.UoM./: :: Data.Theory.UoM.Unit
                        -> Data.Theory.UoM.Unit -> Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  -> Data.Theory.UoM.Unit -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] Data.Theory.UoM.Unit
  ((Data.Theory.UoM.*:) (Data.UnitsOfMeasure.Syntax.MkUnit "kg") (Data.UnitsOfMeasure.Syntax.MkUnit "m"))
lk1 Data.Theory.UoM.*:
tcTyVar2b
  Data.Theory.UoM.*: :: Data.Theory.UoM.Unit
                        -> Data.Theory.UoM.Unit -> Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  -> Data.Theory.UoM.Unit -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] Data.Theory.UoM.Unit
  (Data.UnitsOfMeasure.Syntax.MkUnit "kg")
lk1 Data.UnitsOfMeasure.Syntax.MkUnit
tcTyVar2b
  Data.UnitsOfMeasure.Syntax.MkUnit :: GHC.Types.Symbol
                                       -> Data.Theory.UoM.Unit
  GHC.Types.Symbol -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "kg"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
tc_infer_args (vis)
  [anon] Data.Theory.UoM.Unit
  (Data.UnitsOfMeasure.Syntax.MkUnit "m")
lk1 Data.UnitsOfMeasure.Syntax.MkUnit
tcTyVar2b
  Data.UnitsOfMeasure.Syntax.MkUnit :: GHC.Types.Symbol
                                       -> Data.Theory.UoM.Unit
  GHC.Types.Symbol -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "m"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
tc_infer_args (vis)
  [anon] Data.Theory.UoM.Unit
  ((Data.Theory.UoM.^:) (Data.UnitsOfMeasure.Syntax.MkUnit "s") 2)
lk1 Data.Theory.UoM.^:
tcTyVar2b
  Data.Theory.UoM.^: :: Data.Theory.UoM.Unit
                        -> GHC.Types.Nat -> Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit -> GHC.Types.Nat -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] Data.Theory.UoM.Unit
  (Data.UnitsOfMeasure.Syntax.MkUnit "s")
lk1 Data.UnitsOfMeasure.Syntax.MkUnit
tcTyVar2b
  Data.UnitsOfMeasure.Syntax.MkUnit :: GHC.Types.Symbol
                                       -> Data.Theory.UoM.Unit
  GHC.Types.Symbol -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "s"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
tc_infer_args (vis)
  [anon] GHC.Types.Nat
  2
u_tys
  tclvl 1
  GHC.Types.Nat ~ GHC.Types.Nat
  arising from a type equality GHC.Types.Nat ~ GHC.Types.Nat
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Nat
  GHC.Types.Nat
  <GHC.Types.Nat>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
solveEqualities { wanted =  WC {}
newTcEvBinds unique = a4tv
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = a4tw
reportAllUnsolved }
tcTyFamInstEqn Data.UnitsOfMeasure.Syntax.MkUnit
env2 []
lk1 Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
tcTyVar2a
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
  GHC.Types.Symbol -> Constraint
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "s"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Constraint ~ Constraint
  arising from a type equality Constraint ~ Constraint
u_tys yields no coercion
checkExpectedKind
  Constraint
  Constraint
  <Constraint>_N
tcImplicitTKBndrs
  []
  []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = a4ux
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = a4uy
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
checkValidInstance {
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
Ambiguity check for
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
tcSubType_NC
  an instance declaration
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
tc_sub_tc_type (general case)
  ty_actual   = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "s"
  ty_expected = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "s"
tcSkolemise
tc_sub_type_ds
  ty_actual   = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "s"
  ty_expected = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "s"
deeply_instantiate final subst
  origin: arising from a type equality Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                         "s"
                                       ~
                                       Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
  type: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
  new type: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
  ~
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
  arising from a type equality Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                 "s"
                               ~
                               Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
u_tys
  tclvl 1
  "s" ~ "s"
  arising from a type equality Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                 "s"
                               ~
                               Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
u_tys yields no coercion
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
  wanted =  WC {}
newTcEvBinds unique = a4uz
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = a4uA
reportUnsolved(ambig) }
Done ambiguity check for
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
cvi 2 Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
End checkValidInstance }
tcLocalInstDecl
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
env2 []
env2 []
mk_deflt_at_instance
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  Data.Theory.UoM.Base b_a4uo
  axiom UnitDefs.R:CanonicalBaseUnit"s" ::
    Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
      "s" = Data.Theory.UoM.Base "s"
      -- Defined at test-suite-force/UnitDefs.hs:20:4
doClsInstErrorChecks
  instance Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
    -- Defined at test-suite-force/UnitDefs.hs:20:4
tcFamInstDecl Data.UnitsOfMeasure.Syntax.MkUnit
env2 []
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "s"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
instantiating tybinders:
lk1 Data.Theory.UoM.Base
tcTyVar2b
  Data.Theory.UoM.Base :: GHC.Types.Symbol -> Data.Theory.UoM.Unit
  GHC.Types.Symbol -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "s"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
tcImplicitTKBndrs
  []
  []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = a4uB
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = a4uC
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
tcFamTyPats
  Data.UnitsOfMeasure.Syntax.MkUnit
  ["s"]
  []
env2 []
lk1 Data.Theory.UoM.Base
tcTyVar2b
  Data.Theory.UoM.Base :: GHC.Types.Symbol -> Data.Theory.UoM.Unit
  GHC.Types.Symbol -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "s"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
solveEqualities { wanted =  WC {}
newTcEvBinds unique = a4uD
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = a4uE
reportAllUnsolved }
tcTyFamInstEqn Data.UnitsOfMeasure.Syntax.MkUnit
env2 []
lk1 Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
tcTyVar2a
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
  GHC.Types.Symbol -> Constraint
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "kg"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Constraint ~ Constraint
  arising from a type equality Constraint ~ Constraint
u_tys yields no coercion
checkExpectedKind
  Constraint
  Constraint
  <Constraint>_N
tcImplicitTKBndrs
  []
  []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = a4uF
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = a4uG
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
checkValidInstance {
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
Ambiguity check for
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
tcSubType_NC
  an instance declaration
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
tc_sub_tc_type (general case)
  ty_actual   = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "kg"
  ty_expected = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "kg"
tcSkolemise
tc_sub_type_ds
  ty_actual   = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "kg"
  ty_expected = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "kg"
deeply_instantiate final subst
  origin: arising from a type equality Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                         "kg"
                                       ~
                                       Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
  type: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
  new type: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
  ~
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
  arising from a type equality Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                 "kg"
                               ~
                               Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
u_tys
  tclvl 1
  "kg" ~ "kg"
  arising from a type equality Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                 "kg"
                               ~
                               Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
u_tys yields no coercion
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
  wanted =  WC {}
newTcEvBinds unique = a4uH
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = a4uI
reportUnsolved(ambig) }
Done ambiguity check for
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
cvi 2 Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
End checkValidInstance }
tcLocalInstDecl
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
env2 []
env2 []
mk_deflt_at_instance
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  Data.Theory.UoM.Base b_a4uo
  axiom UnitDefs.R:CanonicalBaseUnit"kg" ::
    Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
      "kg" = Data.Theory.UoM.Base "kg"
      -- Defined at test-suite-force/UnitDefs.hs:20:4
doClsInstErrorChecks
  instance Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
    -- Defined at test-suite-force/UnitDefs.hs:20:4
tcFamInstDecl Data.UnitsOfMeasure.Syntax.MkUnit
env2 []
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "kg"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
instantiating tybinders:
lk1 Data.Theory.UoM.Base
tcTyVar2b
  Data.Theory.UoM.Base :: GHC.Types.Symbol -> Data.Theory.UoM.Unit
  GHC.Types.Symbol -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "kg"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
tcImplicitTKBndrs
  []
  []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = a4uJ
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = a4uK
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
tcFamTyPats
  Data.UnitsOfMeasure.Syntax.MkUnit
  ["kg"]
  []
env2 []
lk1 Data.Theory.UoM.Base
tcTyVar2b
  Data.Theory.UoM.Base :: GHC.Types.Symbol -> Data.Theory.UoM.Unit
  GHC.Types.Symbol -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "kg"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
solveEqualities { wanted =  WC {}
newTcEvBinds unique = a4uL
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = a4uM
reportAllUnsolved }
tcTyFamInstEqn Data.UnitsOfMeasure.Syntax.MkUnit
env2 []
lk1 Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
tcTyVar2a
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
  GHC.Types.Symbol -> Constraint
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "m"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Constraint ~ Constraint
  arising from a type equality Constraint ~ Constraint
u_tys yields no coercion
checkExpectedKind
  Constraint
  Constraint
  <Constraint>_N
tcImplicitTKBndrs
  []
  []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = a4uN
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = a4uO
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
checkValidInstance {
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
Ambiguity check for
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
tcSubType_NC
  an instance declaration
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
tc_sub_tc_type (general case)
  ty_actual   = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "m"
  ty_expected = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "m"
tcSkolemise
tc_sub_type_ds
  ty_actual   = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "m"
  ty_expected = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "m"
deeply_instantiate final subst
  origin: arising from a type equality Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                         "m"
                                       ~
                                       Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
  type: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
  new type: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
  ~
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
  arising from a type equality Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                 "m"
                               ~
                               Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
u_tys
  tclvl 1
  "m" ~ "m"
  arising from a type equality Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                 "m"
                               ~
                               Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
u_tys yields no coercion
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
  wanted =  WC {}
newTcEvBinds unique = a4uP
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = a4uQ
reportUnsolved(ambig) }
Done ambiguity check for
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
cvi 2 Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
End checkValidInstance }
tcLocalInstDecl
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
env2 []
env2 []
mk_deflt_at_instance
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  Data.Theory.UoM.Base b_a4uo
  axiom UnitDefs.R:CanonicalBaseUnit"m" ::
    Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
      "m" = Data.Theory.UoM.Base "m"
      -- Defined at test-suite-force/UnitDefs.hs:20:4
doClsInstErrorChecks
  instance Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
    -- Defined at test-suite-force/UnitDefs.hs:20:4
tcFamInstDecl Data.UnitsOfMeasure.Syntax.MkUnit
env2 []
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "m"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
instantiating tybinders:
lk1 Data.Theory.UoM.Base
tcTyVar2b
  Data.Theory.UoM.Base :: GHC.Types.Symbol -> Data.Theory.UoM.Unit
  GHC.Types.Symbol -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "m"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
tcImplicitTKBndrs
  []
  []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = a4uR
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = a4uS
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
tcFamTyPats
  Data.UnitsOfMeasure.Syntax.MkUnit
  ["m"]
  []
env2 []
lk1 Data.Theory.UoM.Base
tcTyVar2b
  Data.Theory.UoM.Base :: GHC.Types.Symbol -> Data.Theory.UoM.Unit
  GHC.Types.Symbol -> Data.Theory.UoM.Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "m"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Data.Theory.UoM.Unit ~ Data.Theory.UoM.Unit
  arising from a type equality Data.Theory.UoM.Unit
                               ~
                               Data.Theory.UoM.Unit
u_tys yields no coercion
checkExpectedKind
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  <Data.Theory.UoM.Unit>_N
solveEqualities { wanted =  WC {}
newTcEvBinds unique = a4uT
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = a4uU
reportAllUnsolved }
tcTyFamInstEqn Data.UnitsOfMeasure.Syntax.MkUnit
Adding instances:
  UnitDefs.$fHasCanonicalBaseUnit"s" :
    instance Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
      -- Defined at test-suite-force/UnitDefs.hs:20:4
  UnitDefs.$fHasCanonicalBaseUnit"kg" :
    instance Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
      -- Defined at test-suite-force/UnitDefs.hs:20:4
  UnitDefs.$fHasCanonicalBaseUnit"m" :
    instance Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
      -- Defined at test-suite-force/UnitDefs.hs:20:4
addLocalFamInst type instance Data.UnitsOfMeasure.Syntax.MkUnit "N"
alfi UnitDefs
checkForConflicts
  []
  type instance Data.UnitsOfMeasure.Syntax.MkUnit "N"
addLocalFamInst
  type Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
alfi UnitDefs
checkForConflicts
  []
  type Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
addLocalFamInst type instance Data.UnitsOfMeasure.Syntax.MkUnit "s"
alfi UnitDefs
checkForConflicts
  []
  type instance Data.UnitsOfMeasure.Syntax.MkUnit "s"
addLocalFamInst
  type Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
alfi UnitDefs
checkForConflicts
  []
  type Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
addLocalFamInst
  type instance Data.UnitsOfMeasure.Syntax.MkUnit "kg"
alfi UnitDefs
checkForConflicts
  []
  type instance Data.UnitsOfMeasure.Syntax.MkUnit "kg"
addLocalFamInst
  type Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
alfi UnitDefs
checkForConflicts
  []
  type Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
addLocalFamInst type instance Data.UnitsOfMeasure.Syntax.MkUnit "m"
alfi UnitDefs
checkForConflicts
  []
  type instance Data.UnitsOfMeasure.Syntax.MkUnit "m"
addFamInsts
  type instance Data.UnitsOfMeasure.Syntax.MkUnit "N"
  type Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
  type instance Data.UnitsOfMeasure.Syntax.MkUnit "s"
  type Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
  type instance Data.UnitsOfMeasure.Syntax.MkUnit "kg"
  type Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
  type instance Data.UnitsOfMeasure.Syntax.MkUnit "m"
tcAddImplicits
  tycons []
  implicits []
txExtendKindEnvList []
env2 []
tcDeriving False
tcDeriving 1 []
rnd
Adding instances:
Tc3b
Tc3c
tcSemigroupWarnings
Tc4
Tc4a
Tc5
txExtendKindEnvList []
env2 []
complete_matches
  []
  []
complete_matches []
txExtendKindEnvList []
env2 []
complete_matches
  []
  []
complete_matches []
Tc6
tcInstDecl2
  []
  ["s"]
  []
  [Data.UnitsOfMeasure.Canonical.IsCanonical
     (Data.UnitsOfMeasure.Syntax.Unpack
        (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"))]
newTcEvBinds unique = a9s5
newTcEvBinds unique = a9s7
addTcEvBind
  a9s7
  [W] irred_a9s9 = irred_a9s6
env2 []
tcInstMeth
  []
  {}
tc_def Data.UnitsOfMeasure.Canonical.conversionBase
tcMethodBody
  Data.UnitsOfMeasure.Canonical.conversionBase forall (b :: GHC.Types.Symbol).
                                               Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                 b =>
                                               forall (proxy :: GHC.Types.Symbol -> *).
                                               proxy b
                                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                    Rational
                                                    (Data.Theory.UoM.Base b
                                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                          b)
  test-suite-force/UnitDefs.hs:20:4-15
tcPolyCheck
  conversionBase_a9GH
  test-suite-force/UnitDefs.hs:20:4-15
tcExtendIdBndrs [conversionBase_a9GJ[<NotTopLevel>]]
env2 [(proxy_a9Gz, Type variable ‘proxy_a9Gz’ = proxy_a9GI[sk:4])]
tcMatchesFun
  conversionBase_a9GJ
  Check{proxy_a9GI[sk:4] "s"
        -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
             Rational
             (Data.Theory.UoM.Base "s"
              Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                   "s")}
tcSkolemise
tcBody
  Check{proxy_a9GI[sk:4] "s"
        -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
             Rational
             (Data.Theory.UoM.Base "s"
              Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                   "s")}
tcInferId
  Data.UnitsOfMeasure.Canonical.$dmconversionBase :: forall (b :: GHC.Types.Symbol).
                                                     Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                       b =>
                                                     forall (proxy :: GHC.Types.Symbol -> *).
                                                     ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                      ~
                                                      ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          b
                                                        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                             b) :: Data.Theory.UoM.Unit),
                                                      (Data.Theory.UoM.Base
                                                         b :: Data.Theory.UoM.Unit)
                                                      ~
                                                      (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                         b :: Data.Theory.UoM.Unit)) =>
                                                     proxy b
                                                     -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                          Rational
                                                          (Data.Theory.UoM.Base b
                                                           Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                b)
Instantiating
  all tyvars? False
  origin arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  type forall (b :: GHC.Types.Symbol).
       Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit b =>
       forall (proxy :: GHC.Types.Symbol -> *).
       ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
        ~
        ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit b
          Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                               b) :: Data.Theory.UoM.Unit),
        (Data.Theory.UoM.Base b :: Data.Theory.UoM.Unit)
        ~
        (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
           b :: Data.Theory.UoM.Unit)) =>
       proxy b
       -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
            Rational
            (Data.Theory.UoM.Base b
             Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                  b)
  theta [Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit b_a9sa]
  leave_bndrs [@b_a9sa]
  with []
  theta: []
env2 []
u_tys
  tclvl 4
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
checkValidType "s" :: GHC.Types.Symbol
Ambiguity check for "s"
tcSubType_NC
  a type argument
  "s"
  "s"
tc_sub_tc_type (general case)
  ty_actual   = "s"
  ty_expected = "s"
tcSkolemise
tc_sub_type_ds
  ty_actual   = "s"
  ty_expected = "s"
deeply_instantiate final subst
  origin: arising from a type equality "s" ~ "s"
  type: "s"
  new type: "s"
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 4
  "s" ~ "s"
  arising from a type equality "s" ~ "s"
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  "s"
  wanted =  WC {}
newTcEvBinds unique = a9GQ
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = a9GR
reportUnsolved(ambig) }
Done ambiguity check for "s"
checkValidType done "s" :: GHC.Types.Symbol
VTA
  b_a9sa
  GHC.Types.Symbol
  "s"
  GHC.Types.Symbol
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s" =>
  forall (proxy :: GHC.Types.Symbol -> *).
  ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
   ~
   ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "s") :: Data.Theory.UoM.Unit),
   (Data.Theory.UoM.Base "s" :: Data.Theory.UoM.Unit)
   ~
   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
      "s" :: Data.Theory.UoM.Unit)) =>
  proxy "s"
  -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
       Rational
       (Data.Theory.UoM.Base "s"
        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                             "s")
tc_sub_type_ds
  ty_actual   = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "s" =>
                forall (proxy :: GHC.Types.Symbol -> *).
                ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                 ~
                 ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
                   Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                        "s") :: Data.Theory.UoM.Unit),
                 (Data.Theory.UoM.Base "s" :: Data.Theory.UoM.Unit)
                 ~
                 (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                    "s" :: Data.Theory.UoM.Unit)) =>
                proxy "s"
                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                     Rational
                     (Data.Theory.UoM.Base "s"
                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "s")
  ty_expected = proxy_a9GI[sk:4] "s"
                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                     Rational
                     (Data.Theory.UoM.Base "s"
                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "s")
instCallConstraints [$dHasCanonicalBaseUnit_a9GS]
Instantiating
  all tyvars? True
  origin arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  type Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s" =>
       forall (proxy :: GHC.Types.Symbol -> *).
       ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
        ~
        ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
          Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                               "s") :: Data.Theory.UoM.Unit),
        (Data.Theory.UoM.Base "s" :: Data.Theory.UoM.Unit)
        ~
        (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
           "s" :: Data.Theory.UoM.Unit)) =>
       proxy "s"
       -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
            Rational
            (Data.Theory.UoM.Base "s"
             Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                  "s")
  theta [Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"]
  leave_bndrs []
  with []
  theta: [Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"]
instCallConstraints [$d~_a9GU, $d~_a9GV]
Instantiating
  all tyvars? True
  origin arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  type forall (proxy :: GHC.Types.Symbol -> *).
       ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
        ~
        ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
          Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                               "s") :: Data.Theory.UoM.Unit),
        (Data.Theory.UoM.Base "s" :: Data.Theory.UoM.Unit)
        ~
        (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
           "s" :: Data.Theory.UoM.Unit)) =>
       proxy "s"
       -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
            Rational
            (Data.Theory.UoM.Base "s"
             Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                  "s")
  theta [(Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
         ~
         ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
           Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                "s") :: Data.Theory.UoM.Unit),
         (Data.Theory.UoM.Base "s" :: Data.Theory.UoM.Unit)
         ~
         (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
            "s" :: Data.Theory.UoM.Unit)]
  leave_bndrs []
  with [proxy_a9GT[tau:4]]
  theta: [(Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
          ~
          ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                 "s") :: Data.Theory.UoM.Unit),
          (Data.Theory.UoM.Base "s" :: Data.Theory.UoM.Unit)
          ~
          (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
             "s" :: Data.Theory.UoM.Unit)]
tc_sub_type_ds
  ty_actual   = proxy0_a9GT[tau:4] "s"
                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                     Rational
                     (Data.Theory.UoM.Base "s"
                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "s")
  ty_expected = proxy_a9GI[sk:4] "s"
                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                     Rational
                     (Data.Theory.UoM.Base "s"
                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "s")
tc_sub_type_ds
  ty_actual   = Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                  Rational
                  (Data.Theory.UoM.Base "s"
                   Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                        "s")
  ty_expected = Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                  Rational
                  (Data.Theory.UoM.Base "s"
                   Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                        "s")
deeply_instantiate final subst
  origin: arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  type: Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
          Rational
          (Data.Theory.UoM.Base "s"
           Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                "s")
  new type: Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
              Rational
              (Data.Theory.UoM.Base "s"
               Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                    "s")
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 4
  Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
    Rational
    (Data.Theory.UoM.Base "s"
     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "s")
  ~
  Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
    Rational
    (Data.Theory.UoM.Base "s"
     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "s")
  arising from a type equality proxy0_a9GT[tau:4] "s"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")
                               ~
                               proxy_a9GI[sk:4] "s"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")
u_tys
  tclvl 4
  Rational ~ Rational
  arising from a type equality proxy0_a9GT[tau:4] "s"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")
                               ~
                               proxy_a9GI[sk:4] "s"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")
u_tys yields no coercion
u_tys
  tclvl 4
  Data.Theory.UoM.Base "s"
  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                       "s"
  ~
  Data.Theory.UoM.Base "s"
  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                       "s"
  arising from a type equality proxy0_a9GT[tau:4] "s"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")
                               ~
                               proxy_a9GI[sk:4] "s"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")
u_tys yields no coercion
u_tys yields no coercion
tc_sub_tc_type (general case)
  ty_actual   = proxy_a9GI[sk:4] "s"
  ty_expected = proxy0_a9GT[tau:4] "s"
tcSkolemise
tc_sub_type_ds
  ty_actual   = proxy_a9GI[sk:4] "s"
  ty_expected = proxy0_a9GT[tau:4] "s"
deeply_instantiate final subst
  origin: arising from a type expected by the context:
                         proxy_a9GI[sk:4] "s"
  type: proxy_a9GI[sk:4] "s"
  new type: proxy_a9GI[sk:4] "s"
  subst: [TCvSubst
            In scope: InScope {proxy_a9GI}
            Type env: []
            Co env: []]
u_tys
  tclvl 4
  proxy_a9GI[sk:4] "s" ~ proxy0_a9GT[tau:4] "s"
  arising from a type equality proxy0_a9GT[tau:4] "s"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")
                               ~
                               proxy_a9GI[sk:4] "s"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")
u_tys
  tclvl 4
  proxy_a9GI[sk:4] ~ proxy0_a9GT[tau:4]
  arising from a type equality proxy0_a9GT[tau:4] "s"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")
                               ~
                               proxy_a9GI[sk:4] "s"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")
u_tys
  tclvl 4
  GHC.Types.Symbol -> * ~ GHC.Types.Symbol -> *
  arising from a kind equality arising from
    proxy0_a9GT[tau:4] ~ proxy_a9GI[sk:4]
u_tys
  tclvl 4
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a kind equality arising from
    proxy0_a9GT[tau:4] ~ proxy_a9GI[sk:4]
u_tys yields no coercion
u_tys
  tclvl 4
  * ~ *
  arising from a kind equality arising from
    proxy0_a9GT[tau:4] ~ proxy_a9GI[sk:4]
u_tys
  tclvl 4
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    proxy0_a9GT[tau:4] ~ proxy_a9GI[sk:4]
u_tys yields no coercion
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar
  proxy_a9GT[tau:4] :: GHC.Types.Symbol -> * := proxy_a9GI[sk:4]
u_tys yields no coercion
u_tys
  tclvl 4
  "s" ~ "s"
  arising from a type equality proxy0_a9GT[tau:4] "s"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")
                               ~
                               proxy_a9GI[sk:4] "s"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")
u_tys yields no coercion
u_tys yields no coercion
newTcEvBinds unique = a9GW
tcSpecPrags conversionBase_a9GH []
newTcEvBinds unique = a9GX
tcSpecPrags $cconversionBase_a9GG []
tcInstDecl2
  []
  ["kg"]
  []
  [Data.UnitsOfMeasure.Canonical.IsCanonical
     (Data.UnitsOfMeasure.Syntax.Unpack
        (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"))]
newTcEvBinds unique = a9GZ
newTcEvBinds unique = a9H1
addTcEvBind
  a9H1
  [W] irred_a9H3 = irred_a9H0
env2 []
tcInstMeth
  []
  {}
tc_def Data.UnitsOfMeasure.Canonical.conversionBase
tcMethodBody
  Data.UnitsOfMeasure.Canonical.conversionBase forall (b :: GHC.Types.Symbol).
                                               Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                 b =>
                                               forall (proxy :: GHC.Types.Symbol -> *).
                                               proxy b
                                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                    Rational
                                                    (Data.Theory.UoM.Base b
                                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                          b)
  test-suite-force/UnitDefs.hs:20:4-15
tcPolyCheck
  conversionBase_a9H5
  test-suite-force/UnitDefs.hs:20:4-15
tcExtendIdBndrs [conversionBase_a9H7[<NotTopLevel>]]
env2 [(proxy_a9Gz, Type variable ‘proxy_a9Gz’ = proxy_a9H6[sk:4])]
tcMatchesFun
  conversionBase_a9H7
  Check{proxy_a9H6[sk:4] "kg"
        -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
             Rational
             (Data.Theory.UoM.Base "kg"
              Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                   "kg")}
tcSkolemise
tcBody
  Check{proxy_a9H6[sk:4] "kg"
        -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
             Rational
             (Data.Theory.UoM.Base "kg"
              Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                   "kg")}
tcInferId
  Data.UnitsOfMeasure.Canonical.$dmconversionBase :: forall (b :: GHC.Types.Symbol).
                                                     Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                       b =>
                                                     forall (proxy :: GHC.Types.Symbol -> *).
                                                     ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                      ~
                                                      ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          b
                                                        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                             b) :: Data.Theory.UoM.Unit),
                                                      (Data.Theory.UoM.Base
                                                         b :: Data.Theory.UoM.Unit)
                                                      ~
                                                      (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                         b :: Data.Theory.UoM.Unit)) =>
                                                     proxy b
                                                     -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                          Rational
                                                          (Data.Theory.UoM.Base b
                                                           Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                b)
Instantiating
  all tyvars? False
  origin arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  type forall (b :: GHC.Types.Symbol).
       Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit b =>
       forall (proxy :: GHC.Types.Symbol -> *).
       ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
        ~
        ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit b
          Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                               b) :: Data.Theory.UoM.Unit),
        (Data.Theory.UoM.Base b :: Data.Theory.UoM.Unit)
        ~
        (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
           b :: Data.Theory.UoM.Unit)) =>
       proxy b
       -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
            Rational
            (Data.Theory.UoM.Base b
             Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                  b)
  theta [Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit b_a9sa]
  leave_bndrs [@b_a9sa]
  with []
  theta: []
env2 []
u_tys
  tclvl 4
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
checkValidType "kg" :: GHC.Types.Symbol
Ambiguity check for "kg"
tcSubType_NC
  a type argument
  "kg"
  "kg"
tc_sub_tc_type (general case)
  ty_actual   = "kg"
  ty_expected = "kg"
tcSkolemise
tc_sub_type_ds
  ty_actual   = "kg"
  ty_expected = "kg"
deeply_instantiate final subst
  origin: arising from a type equality "kg" ~ "kg"
  type: "kg"
  new type: "kg"
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 4
  "kg" ~ "kg"
  arising from a type equality "kg" ~ "kg"
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  "kg"
  wanted =  WC {}
newTcEvBinds unique = a9H8
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = a9H9
reportUnsolved(ambig) }
Done ambiguity check for "kg"
checkValidType done "kg" :: GHC.Types.Symbol
VTA
  b_a9sa
  GHC.Types.Symbol
  "kg"
  GHC.Types.Symbol
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg" =>
  forall (proxy :: GHC.Types.Symbol -> *).
  ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
   ~
   ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "kg") :: Data.Theory.UoM.Unit),
   (Data.Theory.UoM.Base "kg" :: Data.Theory.UoM.Unit)
   ~
   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
      "kg" :: Data.Theory.UoM.Unit)) =>
  proxy "kg"
  -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
       Rational
       (Data.Theory.UoM.Base "kg"
        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                             "kg")
tc_sub_type_ds
  ty_actual   = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "kg" =>
                forall (proxy :: GHC.Types.Symbol -> *).
                ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                 ~
                 ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
                   Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                        "kg") :: Data.Theory.UoM.Unit),
                 (Data.Theory.UoM.Base "kg" :: Data.Theory.UoM.Unit)
                 ~
                 (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                    "kg" :: Data.Theory.UoM.Unit)) =>
                proxy "kg"
                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                     Rational
                     (Data.Theory.UoM.Base "kg"
                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "kg")
  ty_expected = proxy_a9H6[sk:4] "kg"
                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                     Rational
                     (Data.Theory.UoM.Base "kg"
                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "kg")
instCallConstraints [$dHasCanonicalBaseUnit_a9Ha]
Instantiating
  all tyvars? True
  origin arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  type Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg" =>
       forall (proxy :: GHC.Types.Symbol -> *).
       ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
        ~
        ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
          Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                               "kg") :: Data.Theory.UoM.Unit),
        (Data.Theory.UoM.Base "kg" :: Data.Theory.UoM.Unit)
        ~
        (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
           "kg" :: Data.Theory.UoM.Unit)) =>
       proxy "kg"
       -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
            Rational
            (Data.Theory.UoM.Base "kg"
             Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                  "kg")
  theta [Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"]
  leave_bndrs []
  with []
  theta: [Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"]
instCallConstraints [$d~_a9Hc, $d~_a9Hd]
Instantiating
  all tyvars? True
  origin arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  type forall (proxy :: GHC.Types.Symbol -> *).
       ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
        ~
        ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
          Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                               "kg") :: Data.Theory.UoM.Unit),
        (Data.Theory.UoM.Base "kg" :: Data.Theory.UoM.Unit)
        ~
        (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
           "kg" :: Data.Theory.UoM.Unit)) =>
       proxy "kg"
       -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
            Rational
            (Data.Theory.UoM.Base "kg"
             Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                  "kg")
  theta [(Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
         ~
         ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
           Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                "kg") :: Data.Theory.UoM.Unit),
         (Data.Theory.UoM.Base "kg" :: Data.Theory.UoM.Unit)
         ~
         (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
            "kg" :: Data.Theory.UoM.Unit)]
  leave_bndrs []
  with [proxy_a9Hb[tau:4]]
  theta: [(Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
          ~
          ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                 "kg") :: Data.Theory.UoM.Unit),
          (Data.Theory.UoM.Base "kg" :: Data.Theory.UoM.Unit)
          ~
          (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
             "kg" :: Data.Theory.UoM.Unit)]
tc_sub_type_ds
  ty_actual   = proxy0_a9Hb[tau:4] "kg"
                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                     Rational
                     (Data.Theory.UoM.Base "kg"
                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "kg")
  ty_expected = proxy_a9H6[sk:4] "kg"
                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                     Rational
                     (Data.Theory.UoM.Base "kg"
                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "kg")
tc_sub_type_ds
  ty_actual   = Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                  Rational
                  (Data.Theory.UoM.Base "kg"
                   Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                        "kg")
  ty_expected = Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                  Rational
                  (Data.Theory.UoM.Base "kg"
                   Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                        "kg")
deeply_instantiate final subst
  origin: arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  type: Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
          Rational
          (Data.Theory.UoM.Base "kg"
           Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                "kg")
  new type: Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
              Rational
              (Data.Theory.UoM.Base "kg"
               Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                    "kg")
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 4
  Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
    Rational
    (Data.Theory.UoM.Base "kg"
     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "kg")
  ~
  Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
    Rational
    (Data.Theory.UoM.Base "kg"
     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "kg")
  arising from a type equality proxy0_a9Hb[tau:4] "kg"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")
                               ~
                               proxy_a9H6[sk:4] "kg"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")
u_tys
  tclvl 4
  Rational ~ Rational
  arising from a type equality proxy0_a9Hb[tau:4] "kg"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")
                               ~
                               proxy_a9H6[sk:4] "kg"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")
u_tys yields no coercion
u_tys
  tclvl 4
  Data.Theory.UoM.Base "kg"
  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                       "kg"
  ~
  Data.Theory.UoM.Base "kg"
  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                       "kg"
  arising from a type equality proxy0_a9Hb[tau:4] "kg"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")
                               ~
                               proxy_a9H6[sk:4] "kg"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")
u_tys yields no coercion
u_tys yields no coercion
tc_sub_tc_type (general case)
  ty_actual   = proxy_a9H6[sk:4] "kg"
  ty_expected = proxy0_a9Hb[tau:4] "kg"
tcSkolemise
tc_sub_type_ds
  ty_actual   = proxy_a9H6[sk:4] "kg"
  ty_expected = proxy0_a9Hb[tau:4] "kg"
deeply_instantiate final subst
  origin: arising from a type expected by the context:
                         proxy_a9H6[sk:4] "kg"
  type: proxy_a9H6[sk:4] "kg"
  new type: proxy_a9H6[sk:4] "kg"
  subst: [TCvSubst
            In scope: InScope {proxy_a9H6}
            Type env: []
            Co env: []]
u_tys
  tclvl 4
  proxy_a9H6[sk:4] "kg" ~ proxy0_a9Hb[tau:4] "kg"
  arising from a type equality proxy0_a9Hb[tau:4] "kg"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")
                               ~
                               proxy_a9H6[sk:4] "kg"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")
u_tys
  tclvl 4
  proxy_a9H6[sk:4] ~ proxy0_a9Hb[tau:4]
  arising from a type equality proxy0_a9Hb[tau:4] "kg"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")
                               ~
                               proxy_a9H6[sk:4] "kg"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")
u_tys
  tclvl 4
  GHC.Types.Symbol -> * ~ GHC.Types.Symbol -> *
  arising from a kind equality arising from
    proxy0_a9Hb[tau:4] ~ proxy_a9H6[sk:4]
u_tys
  tclvl 4
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a kind equality arising from
    proxy0_a9Hb[tau:4] ~ proxy_a9H6[sk:4]
u_tys yields no coercion
u_tys
  tclvl 4
  * ~ *
  arising from a kind equality arising from
    proxy0_a9Hb[tau:4] ~ proxy_a9H6[sk:4]
u_tys
  tclvl 4
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    proxy0_a9Hb[tau:4] ~ proxy_a9H6[sk:4]
u_tys yields no coercion
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar
  proxy_a9Hb[tau:4] :: GHC.Types.Symbol -> * := proxy_a9H6[sk:4]
u_tys yields no coercion
u_tys
  tclvl 4
  "kg" ~ "kg"
  arising from a type equality proxy0_a9Hb[tau:4] "kg"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")
                               ~
                               proxy_a9H6[sk:4] "kg"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")
u_tys yields no coercion
u_tys yields no coercion
newTcEvBinds unique = a9He
tcSpecPrags conversionBase_a9H5 []
newTcEvBinds unique = a9Hf
tcSpecPrags $cconversionBase_a9H4 []
tcInstDecl2
  []
  ["m"]
  []
  [Data.UnitsOfMeasure.Canonical.IsCanonical
     (Data.UnitsOfMeasure.Syntax.Unpack
        (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"))]
newTcEvBinds unique = a9Hh
newTcEvBinds unique = a9Hj
addTcEvBind
  a9Hj
  [W] irred_a9Hl = irred_a9Hi
env2 []
tcInstMeth
  []
  {}
tc_def Data.UnitsOfMeasure.Canonical.conversionBase
tcMethodBody
  Data.UnitsOfMeasure.Canonical.conversionBase forall (b :: GHC.Types.Symbol).
                                               Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                 b =>
                                               forall (proxy :: GHC.Types.Symbol -> *).
                                               proxy b
                                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                    Rational
                                                    (Data.Theory.UoM.Base b
                                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                          b)
  test-suite-force/UnitDefs.hs:20:4-15
tcPolyCheck
  conversionBase_a9Hn
  test-suite-force/UnitDefs.hs:20:4-15
tcExtendIdBndrs [conversionBase_a9Hp[<NotTopLevel>]]
env2 [(proxy_a9Gz, Type variable ‘proxy_a9Gz’ = proxy_a9Ho[sk:4])]
tcMatchesFun
  conversionBase_a9Hp
  Check{proxy_a9Ho[sk:4] "m"
        -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
             Rational
             (Data.Theory.UoM.Base "m"
              Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                   "m")}
tcSkolemise
tcBody
  Check{proxy_a9Ho[sk:4] "m"
        -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
             Rational
             (Data.Theory.UoM.Base "m"
              Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                   "m")}
tcInferId
  Data.UnitsOfMeasure.Canonical.$dmconversionBase :: forall (b :: GHC.Types.Symbol).
                                                     Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                       b =>
                                                     forall (proxy :: GHC.Types.Symbol -> *).
                                                     ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                      ~
                                                      ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          b
                                                        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                             b) :: Data.Theory.UoM.Unit),
                                                      (Data.Theory.UoM.Base
                                                         b :: Data.Theory.UoM.Unit)
                                                      ~
                                                      (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                         b :: Data.Theory.UoM.Unit)) =>
                                                     proxy b
                                                     -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                          Rational
                                                          (Data.Theory.UoM.Base b
                                                           Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                b)
Instantiating
  all tyvars? False
  origin arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  type forall (b :: GHC.Types.Symbol).
       Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit b =>
       forall (proxy :: GHC.Types.Symbol -> *).
       ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
        ~
        ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit b
          Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                               b) :: Data.Theory.UoM.Unit),
        (Data.Theory.UoM.Base b :: Data.Theory.UoM.Unit)
        ~
        (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
           b :: Data.Theory.UoM.Unit)) =>
       proxy b
       -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
            Rational
            (Data.Theory.UoM.Base b
             Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                  b)
  theta [Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit b_a9sa]
  leave_bndrs [@b_a9sa]
  with []
  theta: []
env2 []
u_tys
  tclvl 4
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
checkValidType "m" :: GHC.Types.Symbol
Ambiguity check for "m"
tcSubType_NC
  a type argument
  "m"
  "m"
tc_sub_tc_type (general case)
  ty_actual   = "m"
  ty_expected = "m"
tcSkolemise
tc_sub_type_ds
  ty_actual   = "m"
  ty_expected = "m"
deeply_instantiate final subst
  origin: arising from a type equality "m" ~ "m"
  type: "m"
  new type: "m"
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 4
  "m" ~ "m"
  arising from a type equality "m" ~ "m"
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  "m"
  wanted =  WC {}
newTcEvBinds unique = a9Hq
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = a9Hr
reportUnsolved(ambig) }
Done ambiguity check for "m"
checkValidType done "m" :: GHC.Types.Symbol
VTA
  b_a9sa
  GHC.Types.Symbol
  "m"
  GHC.Types.Symbol
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m" =>
  forall (proxy :: GHC.Types.Symbol -> *).
  ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
   ~
   ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "m") :: Data.Theory.UoM.Unit),
   (Data.Theory.UoM.Base "m" :: Data.Theory.UoM.Unit)
   ~
   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
      "m" :: Data.Theory.UoM.Unit)) =>
  proxy "m"
  -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
       Rational
       (Data.Theory.UoM.Base "m"
        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                             "m")
tc_sub_type_ds
  ty_actual   = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                  "m" =>
                forall (proxy :: GHC.Types.Symbol -> *).
                ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                 ~
                 ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
                   Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                        "m") :: Data.Theory.UoM.Unit),
                 (Data.Theory.UoM.Base "m" :: Data.Theory.UoM.Unit)
                 ~
                 (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                    "m" :: Data.Theory.UoM.Unit)) =>
                proxy "m"
                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                     Rational
                     (Data.Theory.UoM.Base "m"
                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "m")
  ty_expected = proxy_a9Ho[sk:4] "m"
                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                     Rational
                     (Data.Theory.UoM.Base "m"
                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "m")
instCallConstraints [$dHasCanonicalBaseUnit_a9Hs]
Instantiating
  all tyvars? True
  origin arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  type Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m" =>
       forall (proxy :: GHC.Types.Symbol -> *).
       ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
        ~
        ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
          Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                               "m") :: Data.Theory.UoM.Unit),
        (Data.Theory.UoM.Base "m" :: Data.Theory.UoM.Unit)
        ~
        (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
           "m" :: Data.Theory.UoM.Unit)) =>
       proxy "m"
       -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
            Rational
            (Data.Theory.UoM.Base "m"
             Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                  "m")
  theta [Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"]
  leave_bndrs []
  with []
  theta: [Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"]
instCallConstraints [$d~_a9Hu, $d~_a9Hv]
Instantiating
  all tyvars? True
  origin arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  type forall (proxy :: GHC.Types.Symbol -> *).
       ((Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
        ~
        ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
          Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                               "m") :: Data.Theory.UoM.Unit),
        (Data.Theory.UoM.Base "m" :: Data.Theory.UoM.Unit)
        ~
        (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
           "m" :: Data.Theory.UoM.Unit)) =>
       proxy "m"
       -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
            Rational
            (Data.Theory.UoM.Base "m"
             Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                  "m")
  theta [(Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
         ~
         ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
           Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                "m") :: Data.Theory.UoM.Unit),
         (Data.Theory.UoM.Base "m" :: Data.Theory.UoM.Unit)
         ~
         (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
            "m" :: Data.Theory.UoM.Unit)]
  leave_bndrs []
  with [proxy_a9Ht[tau:4]]
  theta: [(Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
          ~
          ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                 "m") :: Data.Theory.UoM.Unit),
          (Data.Theory.UoM.Base "m" :: Data.Theory.UoM.Unit)
          ~
          (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
             "m" :: Data.Theory.UoM.Unit)]
tc_sub_type_ds
  ty_actual   = proxy0_a9Ht[tau:4] "m"
                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                     Rational
                     (Data.Theory.UoM.Base "m"
                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "m")
  ty_expected = proxy_a9Ho[sk:4] "m"
                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                     Rational
                     (Data.Theory.UoM.Base "m"
                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "m")
tc_sub_type_ds
  ty_actual   = Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                  Rational
                  (Data.Theory.UoM.Base "m"
                   Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                        "m")
  ty_expected = Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                  Rational
                  (Data.Theory.UoM.Base "m"
                   Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                        "m")
deeply_instantiate final subst
  origin: arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  type: Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
          Rational
          (Data.Theory.UoM.Base "m"
           Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                "m")
  new type: Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
              Rational
              (Data.Theory.UoM.Base "m"
               Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                    "m")
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 4
  Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
    Rational
    (Data.Theory.UoM.Base "m"
     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "m")
  ~
  Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
    Rational
    (Data.Theory.UoM.Base "m"
     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "m")
  arising from a type equality proxy0_a9Ht[tau:4] "m"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")
                               ~
                               proxy_a9Ho[sk:4] "m"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")
u_tys
  tclvl 4
  Rational ~ Rational
  arising from a type equality proxy0_a9Ht[tau:4] "m"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")
                               ~
                               proxy_a9Ho[sk:4] "m"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")
u_tys yields no coercion
u_tys
  tclvl 4
  Data.Theory.UoM.Base "m"
  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                       "m"
  ~
  Data.Theory.UoM.Base "m"
  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                       "m"
  arising from a type equality proxy0_a9Ht[tau:4] "m"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")
                               ~
                               proxy_a9Ho[sk:4] "m"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")
u_tys yields no coercion
u_tys yields no coercion
tc_sub_tc_type (general case)
  ty_actual   = proxy_a9Ho[sk:4] "m"
  ty_expected = proxy0_a9Ht[tau:4] "m"
tcSkolemise
tc_sub_type_ds
  ty_actual   = proxy_a9Ho[sk:4] "m"
  ty_expected = proxy0_a9Ht[tau:4] "m"
deeply_instantiate final subst
  origin: arising from a type expected by the context:
                         proxy_a9Ho[sk:4] "m"
  type: proxy_a9Ho[sk:4] "m"
  new type: proxy_a9Ho[sk:4] "m"
  subst: [TCvSubst
            In scope: InScope {proxy_a9Ho}
            Type env: []
            Co env: []]
u_tys
  tclvl 4
  proxy_a9Ho[sk:4] "m" ~ proxy0_a9Ht[tau:4] "m"
  arising from a type equality proxy0_a9Ht[tau:4] "m"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")
                               ~
                               proxy_a9Ho[sk:4] "m"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")
u_tys
  tclvl 4
  proxy_a9Ho[sk:4] ~ proxy0_a9Ht[tau:4]
  arising from a type equality proxy0_a9Ht[tau:4] "m"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")
                               ~
                               proxy_a9Ho[sk:4] "m"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")
u_tys
  tclvl 4
  GHC.Types.Symbol -> * ~ GHC.Types.Symbol -> *
  arising from a kind equality arising from
    proxy0_a9Ht[tau:4] ~ proxy_a9Ho[sk:4]
u_tys
  tclvl 4
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a kind equality arising from
    proxy0_a9Ht[tau:4] ~ proxy_a9Ho[sk:4]
u_tys yields no coercion
u_tys
  tclvl 4
  * ~ *
  arising from a kind equality arising from
    proxy0_a9Ht[tau:4] ~ proxy_a9Ho[sk:4]
u_tys
  tclvl 4
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    proxy0_a9Ht[tau:4] ~ proxy_a9Ho[sk:4]
u_tys yields no coercion
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar
  proxy_a9Ht[tau:4] :: GHC.Types.Symbol -> * := proxy_a9Ho[sk:4]
u_tys yields no coercion
u_tys
  tclvl 4
  "m" ~ "m"
  arising from a type equality proxy0_a9Ht[tau:4] "m"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")
                               ~
                               proxy_a9Ho[sk:4] "m"
                               -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                    Rational
                                    (Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")
u_tys yields no coercion
u_tys yields no coercion
newTcEvBinds unique = a9Hw
tcSpecPrags conversionBase_a9Hn []
newTcEvBinds unique = a9Hx
tcSpecPrags $cconversionBase_a9Hm []
Tc7
End of tcVectDecls: LIE:
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems =
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 3
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] irred_a9s6 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                    (Data.UnitsOfMeasure.Syntax.Unpack
                                                       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")) (CNonCanonical)}
                    Binds = EvBindsVar<a9s7>
                    Needed = []
                    the instance declaration }
                  Implic {
                    TcLevel = 3
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_impl =
                            Implic {
                              TcLevel = 4
                              Skolems = (proxy_a9GI[sk:4] :: GHC.Types.Symbol -> *)
                              No-eqs = False
                              Status = Unsolved
                              Given =
                              Wanted =
                                WC {wc_simple =
                                      [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                               "s" (CNonCanonical)
                                      [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                          ~
                                                          ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                              "s"
                                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                 "s") :: Data.Theory.UoM.Unit) (CNonCanonical)
                                      [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                                             "s" :: Data.Theory.UoM.Unit)
                                                          ~
                                                          (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                             "s" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                              Binds = EvBindsVar<a9GW>
                              Needed = []
                              the type signature for:
                                Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                                 -> *).
                                                                                proxy "s"
                                                                                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                                     Rational
                                                                                     (Data.Theory.UoM.Base
                                                                                        "s"
                                                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                           "s") }}
                    Binds = EvBindsVar<a9GX>
                    Needed = []
                    the instance declaration }}
          Binds = EvBindsVar<a9s5>
          Needed = []
          the instance declaration }
        Implic {
          TcLevel = 2
          Skolems =
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 3
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] irred_a9H0 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                    (Data.UnitsOfMeasure.Syntax.Unpack
                                                       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")) (CNonCanonical)}
                    Binds = EvBindsVar<a9H1>
                    Needed = []
                    the instance declaration }
                  Implic {
                    TcLevel = 3
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_impl =
                            Implic {
                              TcLevel = 4
                              Skolems = (proxy_a9H6[sk:4] :: GHC.Types.Symbol -> *)
                              No-eqs = False
                              Status = Unsolved
                              Given =
                              Wanted =
                                WC {wc_simple =
                                      [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                               "kg" (CNonCanonical)
                                      [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                          ~
                                                          ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                              "kg"
                                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                 "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)
                                      [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                                             "kg" :: Data.Theory.UoM.Unit)
                                                          ~
                                                          (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                             "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                              Binds = EvBindsVar<a9He>
                              Needed = []
                              the type signature for:
                                Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                                 -> *).
                                                                                proxy "kg"
                                                                                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                                     Rational
                                                                                     (Data.Theory.UoM.Base
                                                                                        "kg"
                                                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                           "kg") }}
                    Binds = EvBindsVar<a9Hf>
                    Needed = []
                    the instance declaration }}
          Binds = EvBindsVar<a9GZ>
          Needed = []
          the instance declaration }
        Implic {
          TcLevel = 2
          Skolems =
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 3
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] irred_a9Hi {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                    (Data.UnitsOfMeasure.Syntax.Unpack
                                                       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")) (CNonCanonical)}
                    Binds = EvBindsVar<a9Hj>
                    Needed = []
                    the instance declaration }
                  Implic {
                    TcLevel = 3
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_impl =
                            Implic {
                              TcLevel = 4
                              Skolems = (proxy_a9Ho[sk:4] :: GHC.Types.Symbol -> *)
                              No-eqs = False
                              Status = Unsolved
                              Given =
                              Wanted =
                                WC {wc_simple =
                                      [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                               "m" (CNonCanonical)
                                      [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                          ~
                                                          ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                              "m"
                                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                 "m") :: Data.Theory.UoM.Unit) (CNonCanonical)
                                      [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                                             "m" :: Data.Theory.UoM.Unit)
                                                          ~
                                                          (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                             "m" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                              Binds = EvBindsVar<a9Hw>
                              Needed = []
                              the type signature for:
                                Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                                 -> *).
                                                                                proxy "m"
                                                                                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                                     Rational
                                                                                     (Data.Theory.UoM.Base
                                                                                        "m"
                                                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                           "m") }}
                    Binds = EvBindsVar<a9Hx>
                    Needed = []
                    the instance declaration }}
          Binds = EvBindsVar<a9Hh>
          Needed = []
          the instance declaration }}
Tc7a
checkMain not Main UnitDefs
simplifyTop {
  wanted =  WC {wc_impl =
                  Implic {
                    TcLevel = 2
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_impl =
                            Implic {
                              TcLevel = 3
                              Skolems =
                              No-eqs = False
                              Status = Unsolved
                              Given =
                              Wanted =
                                WC {wc_simple =
                                      [WD] irred_a9s6 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                              (Data.UnitsOfMeasure.Syntax.Unpack
                                                                 (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                    "s")) (CNonCanonical)}
                              Binds = EvBindsVar<a9s7>
                              Needed = []
                              the instance declaration }
                            Implic {
                              TcLevel = 3
                              Skolems =
                              No-eqs = False
                              Status = Unsolved
                              Given =
                              Wanted =
                                WC {wc_impl =
                                      Implic {
                                        TcLevel = 4
                                        Skolems = (proxy_a9GI[sk:4] :: GHC.Types.Symbol -> *)
                                        No-eqs = False
                                        Status = Unsolved
                                        Given =
                                        Wanted =
                                          WC {wc_simple =
                                                [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                                         "s" (CNonCanonical)
                                                [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                                    ~
                                                                    ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                        "s"
                                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                           "s") :: Data.Theory.UoM.Unit) (CNonCanonical)
                                                [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                                                       "s" :: Data.Theory.UoM.Unit)
                                                                    ~
                                                                    (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                       "s" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                                        Binds = EvBindsVar<a9GW>
                                        Needed = []
                                        the type signature for:
                                          Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                                           -> *).
                                                                                          proxy "s"
                                                                                          -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                                               Rational
                                                                                               (Data.Theory.UoM.Base
                                                                                                  "s"
                                                                                                Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                                     "s") }}
                              Binds = EvBindsVar<a9GX>
                              Needed = []
                              the instance declaration }}
                    Binds = EvBindsVar<a9s5>
                    Needed = []
                    the instance declaration }
                  Implic {
                    TcLevel = 2
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_impl =
                            Implic {
                              TcLevel = 3
                              Skolems =
                              No-eqs = False
                              Status = Unsolved
                              Given =
                              Wanted =
                                WC {wc_simple =
                                      [WD] irred_a9H0 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                              (Data.UnitsOfMeasure.Syntax.Unpack
                                                                 (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                    "kg")) (CNonCanonical)}
                              Binds = EvBindsVar<a9H1>
                              Needed = []
                              the instance declaration }
                            Implic {
                              TcLevel = 3
                              Skolems =
                              No-eqs = False
                              Status = Unsolved
                              Given =
                              Wanted =
                                WC {wc_impl =
                                      Implic {
                                        TcLevel = 4
                                        Skolems = (proxy_a9H6[sk:4] :: GHC.Types.Symbol -> *)
                                        No-eqs = False
                                        Status = Unsolved
                                        Given =
                                        Wanted =
                                          WC {wc_simple =
                                                [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                                         "kg" (CNonCanonical)
                                                [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                                    ~
                                                                    ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                        "kg"
                                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                           "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)
                                                [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                                                       "kg" :: Data.Theory.UoM.Unit)
                                                                    ~
                                                                    (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                       "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                                        Binds = EvBindsVar<a9He>
                                        Needed = []
                                        the type signature for:
                                          Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                                           -> *).
                                                                                          proxy "kg"
                                                                                          -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                                               Rational
                                                                                               (Data.Theory.UoM.Base
                                                                                                  "kg"
                                                                                                Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                                     "kg") }}
                              Binds = EvBindsVar<a9Hf>
                              Needed = []
                              the instance declaration }}
                    Binds = EvBindsVar<a9GZ>
                    Needed = []
                    the instance declaration }
                  Implic {
                    TcLevel = 2
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_impl =
                            Implic {
                              TcLevel = 3
                              Skolems =
                              No-eqs = False
                              Status = Unsolved
                              Given =
                              Wanted =
                                WC {wc_simple =
                                      [WD] irred_a9Hi {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                              (Data.UnitsOfMeasure.Syntax.Unpack
                                                                 (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                    "m")) (CNonCanonical)}
                              Binds = EvBindsVar<a9Hj>
                              Needed = []
                              the instance declaration }
                            Implic {
                              TcLevel = 3
                              Skolems =
                              No-eqs = False
                              Status = Unsolved
                              Given =
                              Wanted =
                                WC {wc_impl =
                                      Implic {
                                        TcLevel = 4
                                        Skolems = (proxy_a9Ho[sk:4] :: GHC.Types.Symbol -> *)
                                        No-eqs = False
                                        Status = Unsolved
                                        Given =
                                        Wanted =
                                          WC {wc_simple =
                                                [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                                         "m" (CNonCanonical)
                                                [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                                    ~
                                                                    ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                        "m"
                                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                           "m") :: Data.Theory.UoM.Unit) (CNonCanonical)
                                                [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                                                       "m" :: Data.Theory.UoM.Unit)
                                                                    ~
                                                                    (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                       "m" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                                        Binds = EvBindsVar<a9Hw>
                                        Needed = []
                                        the type signature for:
                                          Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                                           -> *).
                                                                                          proxy "m"
                                                                                          -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                                               Rational
                                                                                               (Data.Theory.UoM.Base
                                                                                                  "m"
                                                                                                Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                                     "m") }}
                              Binds = EvBindsVar<a9Hx>
                              Needed = []
                              the instance declaration }}
                    Binds = EvBindsVar<a9Hh>
                    Needed = []
                    the instance declaration }}
newTcEvBinds unique = a9Hz
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 2
          Skolems =
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 3
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] irred_a9s6 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                    (Data.UnitsOfMeasure.Syntax.Unpack
                                                       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "s")) (CNonCanonical)}
                    Binds = EvBindsVar<a9s7>
                    Needed = []
                    the instance declaration }
                  Implic {
                    TcLevel = 3
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_impl =
                            Implic {
                              TcLevel = 4
                              Skolems = (proxy_a9GI[sk:4] :: GHC.Types.Symbol -> *)
                              No-eqs = False
                              Status = Unsolved
                              Given =
                              Wanted =
                                WC {wc_simple =
                                      [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                               "s" (CNonCanonical)
                                      [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                          ~
                                                          ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                              "s"
                                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                 "s") :: Data.Theory.UoM.Unit) (CNonCanonical)
                                      [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                                             "s" :: Data.Theory.UoM.Unit)
                                                          ~
                                                          (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                             "s" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                              Binds = EvBindsVar<a9GW>
                              Needed = []
                              the type signature for:
                                Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                                 -> *).
                                                                                proxy "s"
                                                                                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                                     Rational
                                                                                     (Data.Theory.UoM.Base
                                                                                        "s"
                                                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                           "s") }}
                    Binds = EvBindsVar<a9GX>
                    Needed = []
                    the instance declaration }}
          Binds = EvBindsVar<a9s5>
          Needed = []
          the instance declaration }
        Implic {
          TcLevel = 2
          Skolems =
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 3
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] irred_a9H0 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                    (Data.UnitsOfMeasure.Syntax.Unpack
                                                       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "kg")) (CNonCanonical)}
                    Binds = EvBindsVar<a9H1>
                    Needed = []
                    the instance declaration }
                  Implic {
                    TcLevel = 3
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_impl =
                            Implic {
                              TcLevel = 4
                              Skolems = (proxy_a9H6[sk:4] :: GHC.Types.Symbol -> *)
                              No-eqs = False
                              Status = Unsolved
                              Given =
                              Wanted =
                                WC {wc_simple =
                                      [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                               "kg" (CNonCanonical)
                                      [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                          ~
                                                          ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                              "kg"
                                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                 "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)
                                      [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                                             "kg" :: Data.Theory.UoM.Unit)
                                                          ~
                                                          (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                             "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                              Binds = EvBindsVar<a9He>
                              Needed = []
                              the type signature for:
                                Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                                 -> *).
                                                                                proxy "kg"
                                                                                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                                     Rational
                                                                                     (Data.Theory.UoM.Base
                                                                                        "kg"
                                                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                           "kg") }}
                    Binds = EvBindsVar<a9Hf>
                    Needed = []
                    the instance declaration }}
          Binds = EvBindsVar<a9GZ>
          Needed = []
          the instance declaration }
        Implic {
          TcLevel = 2
          Skolems =
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 3
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] irred_a9Hi {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                    (Data.UnitsOfMeasure.Syntax.Unpack
                                                       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                          "m")) (CNonCanonical)}
                    Binds = EvBindsVar<a9Hj>
                    Needed = []
                    the instance declaration }
                  Implic {
                    TcLevel = 3
                    Skolems =
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_impl =
                            Implic {
                              TcLevel = 4
                              Skolems = (proxy_a9Ho[sk:4] :: GHC.Types.Symbol -> *)
                              No-eqs = False
                              Status = Unsolved
                              Given =
                              Wanted =
                                WC {wc_simple =
                                      [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                               "m" (CNonCanonical)
                                      [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                          ~
                                                          ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                              "m"
                                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                 "m") :: Data.Theory.UoM.Unit) (CNonCanonical)
                                      [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                                             "m" :: Data.Theory.UoM.Unit)
                                                          ~
                                                          (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                             "m" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                              Binds = EvBindsVar<a9Hw>
                              Needed = []
                              the type signature for:
                                Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                                 -> *).
                                                                                proxy "m"
                                                                                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                                     Rational
                                                                                     (Data.Theory.UoM.Base
                                                                                        "m"
                                                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                           "m") }}
                    Binds = EvBindsVar<a9Hx>
                    Needed = []
                    the instance declaration }}
          Binds = EvBindsVar<a9Hh>
          Needed = []
          the instance declaration }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 2
    Skolems =
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_impl =
            Implic {
              TcLevel = 3
              Skolems =
              No-eqs = False
              Status = Unsolved
              Given =
              Wanted =
                WC {wc_simple =
                      [WD] irred_a9s6 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                              (Data.UnitsOfMeasure.Syntax.Unpack
                                                 (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                    "s")) (CNonCanonical)}
              Binds = EvBindsVar<a9s7>
              Needed = []
              the instance declaration }
            Implic {
              TcLevel = 3
              Skolems =
              No-eqs = False
              Status = Unsolved
              Given =
              Wanted =
                WC {wc_impl =
                      Implic {
                        TcLevel = 4
                        Skolems = (proxy_a9GI[sk:4] :: GHC.Types.Symbol -> *)
                        No-eqs = False
                        Status = Unsolved
                        Given =
                        Wanted =
                          WC {wc_simple =
                                [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                         "s" (CNonCanonical)
                                [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                    ~
                                                    ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                        "s"
                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                           "s") :: Data.Theory.UoM.Unit) (CNonCanonical)
                                [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                                       "s" :: Data.Theory.UoM.Unit)
                                                    ~
                                                    (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                       "s" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                        Binds = EvBindsVar<a9GW>
                        Needed = []
                        the type signature for:
                          Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                           -> *).
                                                                          proxy "s"
                                                                          -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                               Rational
                                                                               (Data.Theory.UoM.Base
                                                                                  "s"
                                                                                Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                     "s") }}
              Binds = EvBindsVar<a9GX>
              Needed = []
              the instance declaration }}
    Binds = EvBindsVar<a9s5>
    Needed = []
    the instance declaration }
  Inerts {Unsolved goals = 0}
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 3
          Skolems =
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] irred_a9s6 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                          (Data.UnitsOfMeasure.Syntax.Unpack
                                             (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                "s")) (CNonCanonical)}
          Binds = EvBindsVar<a9s7>
          Needed = []
          the instance declaration }
        Implic {
          TcLevel = 3
          Skolems =
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 4
                    Skolems = (proxy_a9GI[sk:4] :: GHC.Types.Symbol -> *)
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                     "s" (CNonCanonical)
                            [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                ~
                                                ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                    "s"
                                                  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                       "s") :: Data.Theory.UoM.Unit) (CNonCanonical)
                            [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                                   "s" :: Data.Theory.UoM.Unit)
                                                ~
                                                (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                   "s" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                    Binds = EvBindsVar<a9GW>
                    Needed = []
                    the type signature for:
                      Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                       -> *).
                                                                      proxy "s"
                                                                      -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                           Rational
                                                                           (Data.Theory.UoM.Base "s"
                                                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                 "s") }}
          Binds = EvBindsVar<a9GX>
          Needed = []
          the instance declaration }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 3
    Skolems =
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] irred_a9s6 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                    (Data.UnitsOfMeasure.Syntax.Unpack
                                       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "s")) (CNonCanonical)}
    Binds = EvBindsVar<a9s7>
    Needed = []
    the instance declaration }
  Inerts {Unsolved goals = 0}
solveWanteds {
  WC {wc_simple =
        [WD] irred_a9s6 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                (Data.UnitsOfMeasure.Syntax.Unpack
                                   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                      "s")) (CNonCanonical)}
solveSimpleWanteds {
  {[WD] irred_a9s6 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                           (Data.UnitsOfMeasure.Syntax.Unpack
                              (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                 "s")) (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_a9s6 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                      (Data.UnitsOfMeasure.Syntax.Unpack
                                         (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                            "s")) (CNonCanonical)
  inerts = {Unsolved goals = 0}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] irred_a9s6 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                        (Data.UnitsOfMeasure.Syntax.Unpack
                                           (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                              "s")) (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_a9s6 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                          (Data.UnitsOfMeasure.Syntax.Unpack
                             (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                "s")) (CNonCanonical)
canEvNC:irred
  Data.UnitsOfMeasure.Canonical.IsCanonical
    (Data.UnitsOfMeasure.Syntax.Unpack
       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"))
can_pred
  IrredPred =  Data.UnitsOfMeasure.Canonical.IsCanonical
                 (Data.UnitsOfMeasure.Syntax.Unpack
                    (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"))
flatten {
  FM_FlattenAll Data.UnitsOfMeasure.Canonical.IsCanonical
                  (Data.UnitsOfMeasure.Syntax.Unpack
                     (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"))
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical
              (Data.UnitsOfMeasure.Syntax.Unpack
                 (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"))
  Match failed
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack
              (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s")
  Match failed
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "s"
    Coercion: UnitDefs.R:CanonicalBaseUnit"s"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["s"]
  Data.Theory.UoM.Base "s"
  UnitDefs.R:CanonicalBaseUnit"s"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "s" ~ Data.Theory.UoM.Base "s"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
New coercion hole: aaIh
Emitting new coercion hole
  {aaIh} :: (Data.Theory.UoM.Base "s" :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit)
extendFlatCache
  Data.Theory.UoM.Base ["s"]
  [WD]
  s0_aaIg[fuv:0]
flatten/flat-cache miss
  Data.Theory.UoM.Base ["s"]
  s_aaIg[fuv:0]
  [WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                           "s" :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack s0_aaIg[fuv:0]
  Match failed
New coercion hole: aaIj
Emitting new coercion hole
  {aaIj} :: (Data.UnitsOfMeasure.Syntax.Unpack
               s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                   GHC.Types.Symbol)
            GHC.Prim.~#
            (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                 GHC.Types.Symbol)
extendFlatCache
  Data.UnitsOfMeasure.Syntax.Unpack [s0_aaIg[fuv:0]]
  [WD]
  s0_aaIi[fuv:0]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Syntax.Unpack [s0_aaIg[fuv:0]]
  s_aaIi[fuv:0]
  [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                           s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
                        GHC.Prim.~#
                        (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                             GHC.Types.Symbol)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical s0_aaIi[fuv:0]
  Match failed
New coercion hole: aaIl
Emitting new coercion hole
  {aaIl} :: (Data.UnitsOfMeasure.Canonical.IsCanonical
               s0_aaIi[fuv:0] :: Constraint)
            GHC.Prim.~#
            (s1_aaIk[fuv:0] :: Constraint)
extendFlatCache
  Data.UnitsOfMeasure.Canonical.IsCanonical [s0_aaIi[fuv:0]]
  [WD]
  s0_aaIk[fuv:0]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Canonical.IsCanonical [s0_aaIi[fuv:0]]
  s_aaIk[fuv:0]
  [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                           s0_aaIi[fuv:0] :: Constraint)
                        GHC.Prim.~#
                        (s1_aaIk[fuv:0] :: Constraint)
flatten } s0_aaIk[fuv:0]
Emitting new wanted
  irred_aaIm :: s0_aaIk[fuv:0]
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9s7
  [W] irred_a9s6
    = irred_aaIm `cast` (Sub
                           (Sym
                              U(hole:{aaIl}, Data.UnitsOfMeasure.Canonical.IsCanonical
                                               s0_aaIi[fuv:0], s0_aaIk[fuv:0])_N
                            ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                 (Trans
                                      (Sym {aaIj})
                                      (Data.UnitsOfMeasure.Syntax.Unpack
                                         (Sym (Trans
                                                   (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                   {aaIh})))_N))_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_aaIm {0}:: s0_aaIk[fuv:0] (CIrredEvCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] irred_aaIm {0}:: s0_aaIk[fuv:0] (CIrredEvCan)
doTopReact [WD] irred_aaIm {0}:: s0_aaIk[fuv:0] (CIrredEvCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] irred_aaIm {0}:: s0_aaIk[fuv:0] (CIrredEvCan)
addInertCan }
Step 1[l:3,d:0] Kept as inert: [WD] irred_aaIm {0}:: s0_aaIk[fuv:0]
End solver pipeline (kept as inert) }
  final_item = [WD] irred_aaIm {0}:: s0_aaIk[fuv:0] (CIrredEvCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                                       "s" :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Irreds = [WD] irred_aaIm {0}:: s0_aaIk[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                           s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                        GHC.Prim.~#
                                                        (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                             GHC.Types.Symbol) (CFunEqCan)
                                  [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           s0_aaIi[fuv:0] :: Constraint)
                                                        GHC.Prim.~#
                                                        (s1_aaIk[fuv:0] :: Constraint) (CFunEqCan)}
runStage canonicalization {
  workitem   =  [WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                                         "s" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many { "s"
flatten } "s"
extendFlatCache
  Data.Theory.UoM.Base ["s"]
  [WD]
  s0_aaIg[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                                         "s" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                                         "s" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                           "s" :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
improveTopFunEqs
  Data.Theory.UoM.Base ["s"] s_aaIg[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                                                                   "s" :: Data.Theory.UoM.Unit)
                                                                GHC.Prim.~#
                                                                (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 2[l:3,d:1] Kept as inert:
    [WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                             "s" :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                                        "s" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                       s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                                    GHC.Prim.~#
                                    (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                                                                "s" :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Irreds = [WD] irred_aaIm {0}:: s0_aaIk[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           s0_aaIi[fuv:0] :: Constraint)
                                                        GHC.Prim.~#
                                                        (s1_aaIk[fuv:0] :: Constraint) (CFunEqCan)}
runStage canonicalization {
  workitem   =  [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                         s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
flatten_many { s0_aaIg[fuv:0]
Unfilled tyvar s_aaIg[fuv:0]
flatten } s0_aaIg[fuv:0]
extendFlatCache
  Data.UnitsOfMeasure.Syntax.Unpack [s0_aaIg[fuv:0]]
  [WD]
  s0_aaIi[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                         s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                         s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
doTopReact
  [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                           s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
                        GHC.Prim.~#
                        (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                             GHC.Types.Symbol) (CFunEqCan)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack s0_aaIg[fuv:0]
  Match failed
improveTopFunEqs
  Data.UnitsOfMeasure.Syntax.Unpack [s0_aaIg[fuv:0]] s_aaIi[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                                   s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                       GHC.Types.Symbol)
                                                                GHC.Prim.~#
                                                                (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                     GHC.Types.Symbol) (CFunEqCan)
addInertCan }
Step 3[l:3,d:0] Kept as inert:
    [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                             s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                 GHC.Types.Symbol)
                          GHC.Prim.~#
                          (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                       s0_aaIi[fuv:0] :: Constraint)
                                    GHC.Prim.~#
                                    (s1_aaIk[fuv:0] :: Constraint) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                                                                "s" :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                                s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Irreds = [WD] irred_aaIm {0}:: s0_aaIk[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                         s0_aaIi[fuv:0] :: Constraint)
                                      GHC.Prim.~#
                                      (s1_aaIk[fuv:0] :: Constraint) (CFunEqCan)
flatten_many { s0_aaIi[fuv:0]
Unfilled tyvar s_aaIi[fuv:0]
flatten } s0_aaIi[fuv:0]
extendFlatCache
  Data.UnitsOfMeasure.Canonical.IsCanonical [s0_aaIi[fuv:0]]
  [WD]
  s0_aaIk[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                         s0_aaIi[fuv:0] :: Constraint)
                                      GHC.Prim.~#
                                      (s1_aaIk[fuv:0] :: Constraint) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                         s0_aaIi[fuv:0] :: Constraint)
                                      GHC.Prim.~#
                                      (s1_aaIk[fuv:0] :: Constraint) (CFunEqCan)
doTopReact
  [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                           s0_aaIi[fuv:0] :: Constraint)
                        GHC.Prim.~#
                        (s1_aaIk[fuv:0] :: Constraint) (CFunEqCan)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical s0_aaIi[fuv:0]
  Match failed
improveTopFunEqs
  Data.UnitsOfMeasure.Canonical.IsCanonical [s0_aaIi[fuv:0]] s_aaIk[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                                   s0_aaIi[fuv:0] :: Constraint)
                                                                GHC.Prim.~#
                                                                (s1_aaIk[fuv:0] :: Constraint) (CFunEqCan)
addInertCan }
Step 4[l:3,d:0] Kept as inert:
    [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                             s0_aaIi[fuv:0] :: Constraint)
                          GHC.Prim.~#
                          (s1_aaIk[fuv:0] :: Constraint)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                        s0_aaIi[fuv:0] :: Constraint)
                                     GHC.Prim.~#
                                     (s1_aaIk[fuv:0] :: Constraint) (CFunEqCan)
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {[WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                                      "s" :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan),
             [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                      s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                        GHC.Types.Symbol) (CFunEqCan),
             [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                      s0_aaIi[fuv:0] :: Constraint)
                                   GHC.Prim.~#
                                   (s1_aaIk[fuv:0] :: Constraint) (CFunEqCan)}
  insols = {}
  others = {[WD] irred_aaIm {0}:: s0_aaIk[fuv:0] (CIrredEvCan)}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{aaIh} {1}:: (Data.Theory.UoM.Base
                                     "s" :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s0_aaIg[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            [WD] hole{aaIj} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                     s0_aaIg[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol)
                                  GHC.Prim.~#
                                  (s1_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                       GHC.Types.Symbol) (CFunEqCan)
            [WD] hole{aaIl} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                     s0_aaIi[fuv:0] :: Constraint)
                                  GHC.Prim.~#
                                  (s1_aaIk[fuv:0] :: Constraint) (CFunEqCan)
   Tv eqs =}
Filling coercion hole
  aaIl := <Data.UnitsOfMeasure.Canonical.IsCanonical
             s0_aaIi[fuv:0]>_N
unflattenFmv
  s_aaIk[fuv:0] := Data.UnitsOfMeasure.Canonical.IsCanonical
                     s0_aaIi[fuv:0]
writeMetaTyVar
  s_aaIk[fuv:0] :: Constraint := Data.UnitsOfMeasure.Canonical.IsCanonical
                                   s0_aaIi[fuv:0]
Filling coercion hole
  aaIj := <Data.UnitsOfMeasure.Syntax.Unpack s0_aaIg[fuv:0]>_N
unflattenFmv
  s_aaIi[fuv:0] := Data.UnitsOfMeasure.Syntax.Unpack s0_aaIg[fuv:0]
writeMetaTyVar
  s_aaIi[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                     GHC.Types.Symbol := Data.UnitsOfMeasure.Syntax.Unpack
                                           s0_aaIg[fuv:0]
Filling coercion hole aaIh := <Data.Theory.UoM.Base "s">_N
unflattenFmv s_aaIg[fuv:0] := Data.Theory.UoM.Base "s"
writeMetaTyVar
  s_aaIg[fuv:0] :: Data.Theory.UoM.Unit := Data.Theory.UoM.Base "s"
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
zonkSimples done: {}
zonkSimples done:
  {[WD] irred_aaIm {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                           (Data.UnitsOfMeasure.Syntax.Unpack
                              (Data.Theory.UoM.Base "s")) (CNonCanonical)}
tcPluginSolve start thoralf-uom-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_aaIm {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                     (Data.UnitsOfMeasure.Syntax.Unpack
                                        (Data.Theory.UoM.Base "s")) (CNonCanonical)]
thoralf-solve gsConvCts Just [ ] [] []
thoralf-solve wsConvCts Just [ ] [] []
thoralf-solve decls []
thoralf-solve decls filtered []
thoralf-solve givens []
thoralf-solve givens filtered []
thoralf-solve wanteds
  [[WD] irred_aaIm {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                           (Data.UnitsOfMeasure.Syntax.Unpack
                              (Data.Theory.UoM.Base "s")) (CNonCanonical)]
thoralf-solve wanteds filtered
  [[WD] irred_aaIm {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                           (Data.UnitsOfMeasure.Syntax.Unpack
                              (Data.Theory.UoM.Base "s")) (CNonCanonical)]
thoralf-solve simplified given sexprs []
thoralf-solve simplified wanteds []
tcPluginSolve ok thoralf-uom-plugin
  solved = []
  new    = []
tcPluginSolve start uom-eq-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_aaIm {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                     (Data.UnitsOfMeasure.Syntax.Unpack
                                        (Data.Theory.UoM.Base "s")) (CNonCanonical)]
tcPluginSolve ok uom-eq-plugin
  solved = []
  new    = []
tcPluginSolve start uom-unpack-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_aaIm {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                     (Data.UnitsOfMeasure.Syntax.Unpack
                                        (Data.Theory.UoM.Base "s")) (CNonCanonical)]
addTcEvBind
  a9s7
  [G] cobox_aaIn
    = CO U(plugin:units, Data.UnitsOfMeasure.Syntax.Unpack
                           (Data.Theory.UoM.Base "s"), '["s"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '[])_N
tcPluginSolve ok uom-unpack-plugin
  solved = []
  new    = [[G] cobox_aaIn {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                    (Data.Theory.UoM.Base
                                       "s") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                 GHC.Types.Symbol)
                                 GHC.Prim.~#
                                 (('["s"]
                                   'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CNonCanonical)]
solveSimple going round again:
  0
  True
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_aaIn {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                      (Data.Theory.UoM.Base
                                         "s") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                   GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (('["s"]
                                     'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol) (CNonCanonical)
  inerts = {Unsolved goals = 0}
  rest of worklist = WL {Non-eqs = [WD] irred_aaIm {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           (Data.UnitsOfMeasure.Syntax.Unpack
                                                              (Data.Theory.UoM.Base
                                                                 "s")) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [G] cobox_aaIn {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        (Data.Theory.UoM.Base
                                           "s") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                     GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (('["s"]
                                       'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                GHC.Types.Symbol) (CNonCanonical)
canonicalize (non-canonical)
  [G] cobox_aaIn {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                          (Data.Theory.UoM.Base "s") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["s"]
                         'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol) (CNonCanonical)
canEvNC:eq
  Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "s")
  '["s"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
can_eq_nc
  False
  [G] cobox_aaIn {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                          (Data.Theory.UoM.Base "s") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["s"]
                         'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
  nominal equality
  Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "s")
  Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "s")
  '["s"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
  '["s"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
flatten {
  FM_FlattenAll Data.UnitsOfMeasure.Syntax.Unpack
                  (Data.Theory.UoM.Base "s")
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack
              (Data.Theory.UoM.Base "s")
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
addTcEvBind
  a9s7
  [G] cobox_aaIp = CO <Data.Theory.UoM.Base "s">_N
extendFlatCache
  Data.Theory.UoM.Base ["s"]
  [G]
  fsk0_aaIo[fsk]
flatten/flat-cache miss
  Data.Theory.UoM.Base ["s"]
  fsk_aaIo[fsk]
  [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                          "s" :: Data.Theory.UoM.Unit)
                       GHC.Prim.~#
                       (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaIo[fsk]
  Match failed
addTcEvBind
  a9s7
  [G] cobox_aaIr
    = CO <Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaIo[fsk]>_N
extendFlatCache
  Data.UnitsOfMeasure.Syntax.Unpack [fsk0_aaIo[fsk]]
  [G]
  fsk0_aaIq[fsk]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Syntax.Unpack [fsk0_aaIo[fsk]]
  fsk_aaIq[fsk]
  [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                          fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                       GHC.Prim.~#
                       (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol)
flatten } fsk0_aaIq[fsk]
flatten { FM_FlattenAll '["s"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
flatten } '["s"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (('["s"]
                                       'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                GHC.Types.Symbol) (CTyEqCan)
Can't solve tyvar equality
  LHS: fsk_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                          GHC.Types.Symbol
  RHS: '["s"]
       'Data.UnitsOfMeasure.Syntax.:/ '[] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol
addInertEq {
  Adding new inert equality: [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                       GHC.Types.Symbol)
                                                  GHC.Prim.~#
                                                  (('["s"]
                                                    'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                             GHC.Types.Symbol) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 5[l:3,d:0] Kept as inert:
    [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                         GHC.Prim.~#
                         (('["s"]
                           'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                    GHC.Types.Symbol)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                      "s" :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Equalities: [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["s"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Unsolved goals = 0}
  rest of worklist = WL {Funeqs = [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                          fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CFunEqCan)
                         Non-eqs = [WD] irred_aaIm {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           (Data.UnitsOfMeasure.Syntax.Unpack
                                                              (Data.Theory.UoM.Base
                                                                 "s")) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                        "s" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many { "s"
flatten } "s"
extendFlatCache
  Data.Theory.UoM.Base ["s"]
  [G]
  fsk0_aaIo[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                        "s" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                        "s" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                          "s" :: Data.Theory.UoM.Unit)
                       GHC.Prim.~#
                       (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                                                  "s" :: Data.Theory.UoM.Unit)
                                                               GHC.Prim.~#
                                                               (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 6[l:3,d:0] Kept as inert:
    [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                            "s" :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                       "s" :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                      fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                        GHC.Types.Symbol) (CFunEqCan)
  inerts = {Equalities: [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["s"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                                               "s" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Unsolved goals = 0}
  rest of worklist = WL {Non-eqs = [WD] irred_aaIm {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           (Data.UnitsOfMeasure.Syntax.Unpack
                                                              (Data.Theory.UoM.Base
                                                                 "s")) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
flatten_many { fsk0_aaIo[fsk]
Unfilled tyvar fsk_aaIo[fsk]
flatten } fsk0_aaIo[fsk]
extendFlatCache
  Data.UnitsOfMeasure.Syntax.Unpack [fsk0_aaIo[fsk]]
  [G]
  fsk0_aaIq[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
doTopReact
  [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                          fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                       GHC.Prim.~#
                       (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol) (CFunEqCan)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaIo[fsk]
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                                  fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                      GHC.Types.Symbol)
                                                               GHC.Prim.~#
                                                               (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol) (CFunEqCan)
addInertCan }
Step 7[l:3,d:0] Kept as inert:
    [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                            fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                GHC.Types.Symbol)
                         GHC.Prim.~#
                         (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                       fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                                    GHC.Prim.~#
                                    (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_aaIm {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                      (Data.UnitsOfMeasure.Syntax.Unpack
                                         (Data.Theory.UoM.Base "s")) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["s"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                                               "s" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] irred_aaIm {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                        (Data.UnitsOfMeasure.Syntax.Unpack
                                           (Data.Theory.UoM.Base "s")) (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_aaIm {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                          (Data.UnitsOfMeasure.Syntax.Unpack
                             (Data.Theory.UoM.Base "s")) (CNonCanonical)
canEvNC:irred
  Data.UnitsOfMeasure.Canonical.IsCanonical
    (Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "s"))
can_pred
  IrredPred =  Data.UnitsOfMeasure.Canonical.IsCanonical
                 (Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "s"))
flatten {
  FM_FlattenAll Data.UnitsOfMeasure.Canonical.IsCanonical
                  (Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "s"))
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical
              (Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "s"))
  Match failed
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack
              (Data.Theory.UoM.Base "s")
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["s"]
  fsk0_aaIo[fsk]
Unfilled tyvar fsk_aaIo[fsk]
flatten/flat-cache hit
  Data.UnitsOfMeasure.Syntax.Unpack [fsk0_aaIo[fsk]]
  fsk0_aaIq[fsk]
Unfilled tyvar fsk_aaIq[fsk]
Following inert tyvar
  FM_FlattenAll fsk_aaIq[fsk] = '["s"]
                                'Data.UnitsOfMeasure.Syntax.:/ '[]
  [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["s"]
                         'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical
              ('["s"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
  Match succeeded:
    Rewrites to: (Data.UnitsOfMeasure.Canonical.AllIsCanonical '["s"],
                  Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
    Coercion: Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                <'["s"]>_N <'[]>_N
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.IsCanonical
  ['["s"] 'Data.UnitsOfMeasure.Syntax.:/ '[]]
  (Data.UnitsOfMeasure.Canonical.AllIsCanonical '["s"],
   Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
  Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
    <'["s"]>_N <'[]>_N :: Data.UnitsOfMeasure.Canonical.IsCanonical
                            ('["s"]
                             'Data.UnitsOfMeasure.Syntax.:/ '[]) ~ (Data.UnitsOfMeasure.Canonical.AllIsCanonical
                                                                      '["s"],
                                                                    Data.UnitsOfMeasure.Canonical.AllIsCanonical
                                                                      '[])
  True
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.AllIsCanonical '["s"]
  Match succeeded:
    Rewrites to: ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                     "s" :: Data.Theory.UoM.Unit)
                  ~
                  (Data.Theory.UoM.Base "s" :: Data.Theory.UoM.Unit),
                  Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
    Coercion: Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                <"s">_N <'[]>_N
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.AllIsCanonical
  ['["s"]]
  ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
      "s" :: Data.Theory.UoM.Unit)
   ~
   (Data.Theory.UoM.Base "s" :: Data.Theory.UoM.Unit),
   Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
  Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
    <"s">_N <'[]>_N :: Data.UnitsOfMeasure.Canonical.AllIsCanonical
                         '["s"] ~ ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                      "s" :: Data.Theory.UoM.Unit)
                                   ~
                                   (Data.Theory.UoM.Base "s" :: Data.Theory.UoM.Unit),
                                   Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
  False
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "s"
    Coercion: UnitDefs.R:CanonicalBaseUnit"s"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["s"]
  Data.Theory.UoM.Base "s"
  UnitDefs.R:CanonicalBaseUnit"s"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "s" ~ Data.Theory.UoM.Base "s"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["s"]
  fsk0_aaIo[fsk]
Unfilled tyvar fsk_aaIo[fsk]
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["s"]
  fsk0_aaIo[fsk]
Unfilled tyvar fsk_aaIo[fsk]
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.AllIsCanonical '[]
  Match succeeded:
    Rewrites to: () :: Constraint
    Coercion: Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.AllIsCanonical
  ['[]]
  () :: Constraint
  Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0] :: Data.UnitsOfMeasure.Canonical.AllIsCanonical
                                                           '[] ~ () :: Constraint
  False
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.AllIsCanonical '[]
  Match succeeded:
    Rewrites to: () :: Constraint
    Coercion: Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.AllIsCanonical
  ['[]]
  () :: Constraint
  Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0] :: Data.UnitsOfMeasure.Canonical.AllIsCanonical
                                                           '[] ~ () :: Constraint
  False
extendFlatCache
  Data.UnitsOfMeasure.Canonical.IsCanonical ['["s"]
                                             'Data.UnitsOfMeasure.Syntax.:/ '[]]
  [WD]
  (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
    ~
    (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
    () :: Constraint),
   () :: Constraint)
flatten }
  (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
    ~
    (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
    () :: Constraint),
   () :: Constraint)
Emitting new wanted
  $d(%,%)_aaIF :: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                    ~
                    (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                    () :: Constraint),
                   () :: Constraint)
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9s7
  [W] irred_aaIm
    = $d(%,%)_aaIF `cast` (Sub
                             (Sym
                                (Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                                   <'["s"]>_N <'[]>_N
                                 ; Sym
                                     (GHC.Classes.(%,%)
                                        (Sym (Trans
                                                  (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                                                       <"s">_N <'[]>_N)
                                                  (Sym (GHC.Classes.(%,%)
                                                          ((~)
                                                             <Data.Theory.UoM.Unit>_N
                                                             (Sym (Trans
                                                                       (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                                       cobox))
                                                             (Sym cobox))_N
                                                          (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)))
                                        (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)
                              ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                   (Trans
                                        (Trans (Sym cobox) (Sym cobox))
                                        (Data.UnitsOfMeasure.Syntax.Unpack (Sym cobox))_N))_N))
flatten_many {
  ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
   ~
   (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
   () :: Constraint)
  () :: Constraint
Unfilled tyvar fsk_aaIo[fsk]
Unfilled tyvar fsk_aaIo[fsk]
flatten }
  ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
   ~
   (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
   () :: Constraint)
  () :: Constraint
canClass
  [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint),
                           () :: Constraint)
  (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
    ~
    (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
    () :: Constraint),
   () :: Constraint)
  ContinueWith [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                         ~
                                         (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                         () :: Constraint),
                                        () :: Constraint)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                          ~
                                          (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                          () :: Constraint),
                                         () :: Constraint) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                          ~
                                          (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                          () :: Constraint),
                                         () :: Constraint) (CDictCan(psc))
doTopReact
  [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint),
                           () :: Constraint) (CDictCan(psc))
matchClassInst
  pred = (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
           ~
           (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
           () :: Constraint),
          () :: Constraint) {
} matchClassInst result
  GenInst [((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
            ~
            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
            () :: Constraint),
           () :: Constraint]
          [safe]
doTopReact/found instance for
  [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint),
                           () :: Constraint)
updSolvedSetTcs:
  [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint),
                           () :: Constraint)
Emitting new wanted
  $d(%,%)_aaIG :: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                   ~
                   (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                   () :: Constraint)
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
Emitting new wanted
  $d(%%)_aaIH :: () :: Constraint
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9s7
  [W] $d(%,%)_aaIF
    = GHC.Classes.C:(%,%) @[((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                             ~
                             (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                             () :: Constraint),
                            () :: Constraint]
                          [$d(%,%)_aaIG, $d(%%)_aaIH]
Emitting fresh work
  [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint) (CNonCanonical)
  [WD] $d(%%)_aaIH {1}:: () :: Constraint (CNonCanonical)
end stage top-level reactions }
Step 8[l:3,d:0] Top react: Dict/Top (solved wanted):
    [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                              ~
                              (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                              () :: Constraint),
                             () :: Constraint)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                       ~
                                       (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                       () :: Constraint) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["s"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                                               "s" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaIH {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                         ~
                                         (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                         () :: Constraint) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint) (CNonCanonical)
canEvNC:cls
  GHC.Classes.(%,%) [(fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                     ~
                     (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                     () :: Constraint]
flatten_many {
  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  ~
  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  () :: Constraint
Unfilled tyvar fsk_aaIo[fsk]
Unfilled tyvar fsk_aaIo[fsk]
flatten }
  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  ~
  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  () :: Constraint
canClass
  [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint)
  ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
   ~
   (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
   () :: Constraint)
  ContinueWith [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                        ~
                                        (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                        () :: Constraint)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                         ~
                                         (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                         () :: Constraint) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                         ~
                                         (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                         () :: Constraint) (CDictCan(psc))
doTopReact
  [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint) (CDictCan(psc))
matchClassInst
  pred = ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
          ~
          (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
          () :: Constraint) {
} matchClassInst result
  GenInst [(fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
           ~
           (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
           () :: Constraint]
          [safe]
doTopReact/found instance for
  [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint)
updSolvedSetTcs:
  [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint)
Emitting new wanted
  $d~_aaII :: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
              ~
              (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
Emitting new wanted
  $d(%%)_aaIJ :: () :: Constraint
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9s7
  [W] $d(%,%)_aaIG
    = GHC.Classes.C:(%,%) @[(fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint]
                          [$d~_aaII, $d(%%)_aaIJ]
Emitting fresh work
  [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
  [WD] $d(%%)_aaIJ {2}:: () :: Constraint (CNonCanonical)
end stage top-level reactions }
Step 9[l:3,d:1] Top react: Dict/Top (solved wanted):
    [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                             ~
                             (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                             () :: Constraint)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                  ~
                                  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["s"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                                               "s" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaIJ {2}:: () :: Constraint (CNonCanonical)
                                   [WD] $d(%%)_aaIH {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                    ~
                                    (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~ [Data.Theory.UoM.Unit, fsk0_aaIo[fsk], fsk0_aaIo[fsk]]
flatten_many {
  Data.Theory.UoM.Unit
  fsk0_aaIo[fsk]
  fsk0_aaIo[fsk]
Unfilled tyvar fsk_aaIo[fsk]
Unfilled tyvar fsk_aaIo[fsk]
flatten }
  Data.Theory.UoM.Unit
  fsk0_aaIo[fsk]
  fsk0_aaIo[fsk]
canClass
  [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  ~
  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                   ~
                                   (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                    ~
                                    (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                    ~
                                    (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
         ~
         (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) {
matchClass success
  dict (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
       ~
       (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  witness Data.Type.Equality.$f~kab forall k (a :: k) (b :: k).
                                    (a :: k) ~~ (b :: k) =>
                                    (a :: k) ~ (b :: k)
} matchClassInst result
  GenInst [(fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
           ~~
           (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
Emitting new wanted
  $d~~_aaIO :: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
               ~~
               (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9s7
  [W] $d~_aaII
    = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, fsk0_aaIo[fsk],
                                  fsk0_aaIo[fsk]]
                                [$d~~_aaIO]
Emitting fresh work
  [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 10[l:3,d:2] Top react: Dict/Top (solved wanted):
    [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                        ~
                        (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                   ~~
                                   (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["s"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                                               "s" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
                        [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                            ~
                                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaIJ {2}:: () :: Constraint (CNonCanonical)
                                   [WD] $d(%%)_aaIH {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~~ [Data.Theory.UoM.Unit, Data.Theory.UoM.Unit, fsk0_aaIo[fsk],
      fsk0_aaIo[fsk]]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  fsk0_aaIo[fsk]
  fsk0_aaIo[fsk]
Unfilled tyvar fsk_aaIo[fsk]
Unfilled tyvar fsk_aaIo[fsk]
flatten }
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  fsk0_aaIo[fsk]
  fsk0_aaIo[fsk]
canClass
  [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  ~~
  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                    ~~
                                    (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
         ~~
         (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) {
} matchClassInst result
  GenInst [(fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
           GHC.Prim.~#
           (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
New coercion hole: aaIP
Emitting new coercion hole
  {aaIP} :: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
addTcEvBind
  a9s7
  [W] $d~~_aaIO
    = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                      fsk0_aaIo[fsk], fsk0_aaIo[fsk]]
                    [CO <fsk0_aaIo[fsk]>_N]
Emitting fresh work
  [WD] hole{aaIP} {4}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 11[l:3,d:3] Top react: Dict/Top (solved wanted):
    [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                         ~~
                         (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaIP} {4}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["s"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                                               "s" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
                        [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                            ~
                                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaIJ {2}:: () :: Constraint (CNonCanonical)
                                   [WD] $d(%%)_aaIH {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaIP} {4}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{aaIP} {4}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:eq
  fsk0_aaIo[fsk]
  fsk0_aaIo[fsk]
Filling coercion hole aaIP := <fsk0_aaIo[fsk]>_N
end stage canonicalization }
Step 12[l:3,d:4] Solved by reflexivity:
    [WD] hole{aaIP} {4}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d(%%)_aaIJ {2}:: () :: Constraint (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["s"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                                               "s" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
                        [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                            ~
                                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaIH {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d(%%)_aaIJ {2}:: () :: Constraint (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d(%%)_aaIJ {2}:: () :: Constraint (CNonCanonical)
canEvNC:cls GHC.Classes.(%%) []
flatten_many {
flatten }
canClass
  [WD] $d(%%)_aaIJ {2}:: () :: Constraint
  () :: Constraint
  ContinueWith [WD] $d(%%)_aaIJ {2}:: () :: Constraint
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d(%%)_aaIJ {2}:: () :: Constraint (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d(%%)_aaIJ {2}:: () :: Constraint (CDictCan)
doTopReact [WD] $d(%%)_aaIJ {2}:: () :: Constraint (CDictCan)
matchClassInst pred = () :: Constraint {
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for
  [WD] $d(%%)_aaIJ {2}:: () :: Constraint
updSolvedSetTcs: [WD] $d(%%)_aaIJ {2}:: () :: Constraint
addTcEvBind
  a9s7
  [W] $d(%%)_aaIJ = GHC.Classes.C:(%%) @[] []
end stage top-level reactions }
Step 13[l:3,d:2] Top react: Dict/Top (solved wanted):
    [WD] $d(%%)_aaIJ {2}:: () :: Constraint
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d(%%)_aaIH {1}:: () :: Constraint (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaIn {0}:: (fsk0_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["s"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaIp {0}:: (Data.Theory.UoM.Base
                                                               "s" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaIr {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaIo[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaIq[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaIG {1}:: ((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaIF {0}:: (((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
                        [WD] $d~_aaII {2}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                            ~
                                            (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaIO {3}:: (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                        [WD] $d(%%)_aaIJ {2}:: () :: Constraint
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $d(%%)_aaIH {1}:: () :: Constraint (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d(%%)_aaIH {1}:: () :: Constraint (CNonCanonical)
canEvNC:cls GHC.Classes.(%%) []
flatten_many {
flatten }
canClass
  [WD] $d(%%)_aaIH {1}:: () :: Constraint
  () :: Constraint
  ContinueWith [WD] $d(%%)_aaIH {1}:: () :: Constraint
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d(%%)_aaIH {1}:: () :: Constraint (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d(%%)_aaIH {1}:: () :: Constraint (CDictCan)
doTopReact [WD] $d(%%)_aaIH {1}:: () :: Constraint (CDictCan)
addTcEvBind
  a9s7
  [W] $d(%%)_aaIH = $d(%%)_aaIJ
end stage top-level reactions }
Step 14[l:3,d:1] Top react: Dict/Top (cached):
    [WD] $d(%%)_aaIH {1}:: () :: Constraint
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  insols = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs =
   Tv eqs =}
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
zonkSimples done: {}
solveSimpleWanteds end }
  iterations = 2
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {[W] irred_a9s9 = irred_a9s6,
                      [W] irred_a9s6
                        = irred_aaIm `cast` (Sub
                                               (Sym
                                                  U(hole:{aaIl}, Data.UnitsOfMeasure.Canonical.IsCanonical
                                                                   s0_aaIi[fuv:0], s0_aaIk[fuv:0])_N
                                                ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                     (Trans
                                                          (Sym {aaIj})
                                                          (Data.UnitsOfMeasure.Syntax.Unpack
                                                             (Sym (Trans
                                                                       (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                                       {aaIh})))_N))_N)),
                      [G] cobox_aaIn
                        = CO U(plugin:units, Data.UnitsOfMeasure.Syntax.Unpack
                                               (Data.Theory.UoM.Base "s"), '["s"]
                                                                           'Data.UnitsOfMeasure.Syntax.:/ '[])_N,
                      [G] cobox_aaIp = CO <Data.Theory.UoM.Base "s">_N,
                      [G] cobox_aaIr
                        = CO <Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaIo[fsk]>_N,
                      [W] irred_aaIm
                        = $d(%,%)_aaIF `cast` (Sub
                                                 (Sym
                                                    (Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                                                       <'["s"]>_N <'[]>_N
                                                     ; Sym
                                                         (GHC.Classes.(%,%)
                                                            (Sym (Trans
                                                                      (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                                                                           <"s">_N <'[]>_N)
                                                                      (Sym (GHC.Classes.(%,%)
                                                                              ((~)
                                                                                 <Data.Theory.UoM.Unit>_N
                                                                                 (Sym (Trans
                                                                                           (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                                                           cobox))
                                                                                 (Sym cobox))_N
                                                                              (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)))
                                                            (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)
                                                  ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                       (Trans
                                                            (Trans (Sym cobox) (Sym cobox))
                                                            (Data.UnitsOfMeasure.Syntax.Unpack
                                                               (Sym cobox))_N))_N)),
                      [W] $d(%,%)_aaIF
                        = GHC.Classes.C:(%,%) @[((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint),
                                                () :: Constraint]
                                              [$d(%,%)_aaIG, $d(%%)_aaIH],
                      [W] $d(%,%)_aaIG
                        = GHC.Classes.C:(%,%) @[(fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                ~
                                                (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                () :: Constraint]
                                              [$d~_aaII, $d(%%)_aaIJ],
                      [W] $d~_aaII
                        = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, fsk0_aaIo[fsk],
                                                      fsk0_aaIo[fsk]]
                                                    [$d~~_aaIO],
                      [W] $d~~_aaIO
                        = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                          fsk0_aaIo[fsk], fsk0_aaIo[fsk]]
                                        [CO <fsk0_aaIo[fsk]>_N],
                      [W] $d(%%)_aaIJ = GHC.Classes.C:(%%) @[] [],
                      [W] $d(%%)_aaIH = $d(%%)_aaIJ}
getNoGivenEqs
  False
  {Unsolved goals = 0}
  {}
floatEqualities
  Skols = []
  Simples = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus 2
  []
  ([a9s9 :-> [W] irred_a9s9 = irred_a9s6,
    a9s6 :-> [W] irred_a9s6
               = irred_aaIm `cast` (Sub
                                      (Sym
                                         U(hole:{aaIl}, Data.UnitsOfMeasure.Canonical.IsCanonical
                                                          s0_aaIi[fuv:0], s0_aaIk[fuv:0])_N
                                       ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                            (Trans
                                                 (Sym {aaIj})
                                                 (Data.UnitsOfMeasure.Syntax.Unpack
                                                    (Sym (Trans
                                                              (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                              {aaIh})))_N))_N)),
    aaIn :-> [G] cobox_aaIn
               = CO U(plugin:units, Data.UnitsOfMeasure.Syntax.Unpack
                                      (Data.Theory.UoM.Base "s"), '["s"]
                                                                  'Data.UnitsOfMeasure.Syntax.:/ '[])_N,
    aaIp :-> [G] cobox_aaIp = CO <Data.Theory.UoM.Base "s">_N,
    aaIr :-> [G] cobox_aaIr
               = CO <Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaIo[fsk]>_N,
    aaIm :-> [W] irred_aaIm
               = $d(%,%)_aaIF `cast` (Sub
                                        (Sym
                                           (Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                                              <'["s"]>_N <'[]>_N
                                            ; Sym
                                                (GHC.Classes.(%,%)
                                                   (Sym (Trans
                                                             (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                                                                  <"s">_N <'[]>_N)
                                                             (Sym (GHC.Classes.(%,%)
                                                                     ((~)
                                                                        <Data.Theory.UoM.Unit>_N
                                                                        (Sym (Trans
                                                                                  (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                                                  cobox))
                                                                        (Sym cobox))_N
                                                                     (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)))
                                                   (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)
                                         ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                              (Trans
                                                   (Trans (Sym cobox) (Sym cobox))
                                                   (Data.UnitsOfMeasure.Syntax.Unpack
                                                      (Sym cobox))_N))_N)),
    aaIF :-> [W] $d(%,%)_aaIF
               = GHC.Classes.C:(%,%) @[((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                        ~
                                        (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                        () :: Constraint),
                                       () :: Constraint]
                                     [$d(%,%)_aaIG, $d(%%)_aaIH],
    aaIG :-> [W] $d(%,%)_aaIG
               = GHC.Classes.C:(%,%) @[(fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                       ~
                                       (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                       () :: Constraint]
                                     [$d~_aaII, $d(%%)_aaIJ],
    aaII :-> [W] $d~_aaII
               = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, fsk0_aaIo[fsk],
                                             fsk0_aaIo[fsk]]
                                           [$d~~_aaIO],
    aaIO :-> [W] $d~~_aaIO
               = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                 fsk0_aaIo[fsk], fsk0_aaIo[fsk]]
                               [CO <fsk0_aaIo[fsk]>_N],
    aaIJ :-> [W] $d(%%)_aaIJ = GHC.Classes.C:(%%) @[] [],
    aaIH :-> [W] $d(%%)_aaIH = $d(%%)_aaIJ],
   [])
  []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {[W] irred_a9s9 = irred_a9s6,
                         [W] irred_a9s6
                           = irred_aaIm `cast` (Sub
                                                  (Sym
                                                     U(hole:{aaIl}, Data.UnitsOfMeasure.Canonical.IsCanonical
                                                                      s0_aaIi[fuv:0], s0_aaIk[fuv:0])_N
                                                   ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                        (Trans
                                                             (Sym {aaIj})
                                                             (Data.UnitsOfMeasure.Syntax.Unpack
                                                                (Sym (Trans
                                                                          (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                                          {aaIh})))_N))_N)),
                         [G] cobox_aaIn
                           = CO U(plugin:units, Data.UnitsOfMeasure.Syntax.Unpack
                                                  (Data.Theory.UoM.Base "s"), '["s"]
                                                                              'Data.UnitsOfMeasure.Syntax.:/ '[])_N,
                         [G] cobox_aaIp = CO <Data.Theory.UoM.Base "s">_N,
                         [G] cobox_aaIr
                           = CO <Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaIo[fsk]>_N,
                         [W] irred_aaIm
                           = $d(%,%)_aaIF `cast` (Sub
                                                    (Sym
                                                       (Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                                                          <'["s"]>_N <'[]>_N
                                                        ; Sym
                                                            (GHC.Classes.(%,%)
                                                               (Sym (Trans
                                                                         (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                                                                              <"s">_N <'[]>_N)
                                                                         (Sym (GHC.Classes.(%,%)
                                                                                 ((~)
                                                                                    <Data.Theory.UoM.Unit>_N
                                                                                    (Sym (Trans
                                                                                              (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                                                              cobox))
                                                                                    (Sym cobox))_N
                                                                                 (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)))
                                                               (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)
                                                     ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                          (Trans
                                                               (Trans (Sym cobox) (Sym cobox))
                                                               (Data.UnitsOfMeasure.Syntax.Unpack
                                                                  (Sym cobox))_N))_N)),
                         [W] $d(%,%)_aaIF
                           = GHC.Classes.C:(%,%) @[((fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                    ~
                                                    (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                    () :: Constraint),
                                                   () :: Constraint]
                                                 [$d(%,%)_aaIG, $d(%%)_aaIH],
                         [W] $d(%,%)_aaIG
                           = GHC.Classes.C:(%,%) @[(fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit)
                                                   ~
                                                   (fsk0_aaIo[fsk] :: Data.Theory.UoM.Unit),
                                                   () :: Constraint]
                                                 [$d~_aaII, $d(%%)_aaIJ],
                         [W] $d~_aaII
                           = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, fsk0_aaIo[fsk],
                                                         fsk0_aaIo[fsk]]
                                                       [$d~~_aaIO],
                         [W] $d~~_aaIO
                           = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                             fsk0_aaIo[fsk], fsk0_aaIo[fsk]]
                                           [CO <fsk0_aaIo[fsk]>_N],
                         [W] $d(%%)_aaIJ = GHC.Classes.C:(%%) @[] [],
                         [W] $d(%%)_aaIH = $d(%%)_aaIJ}
  implication tvcs = []
solveImplication {
  Implic {
    TcLevel = 3
    Skolems =
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_impl =
            Implic {
              TcLevel = 4
              Skolems = (proxy_a9GI[sk:4] :: GHC.Types.Symbol -> *)
              No-eqs = False
              Status = Unsolved
              Given =
              Wanted =
                WC {wc_simple =
                      [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                               "s" (CNonCanonical)
                      [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                          ~
                                          ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                 "s") :: Data.Theory.UoM.Unit) (CNonCanonical)
                      [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                             "s" :: Data.Theory.UoM.Unit)
                                          ~
                                          (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                             "s" :: Data.Theory.UoM.Unit) (CNonCanonical)}
              Binds = EvBindsVar<a9GW>
              Needed = []
              the type signature for:
                Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                 -> *).
                                                                proxy "s"
                                                                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                     Rational
                                                                     (Data.Theory.UoM.Base "s"
                                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                           "s") }}
    Binds = EvBindsVar<a9GX>
    Needed = []
    the instance declaration }
  Inerts {Unsolved goals = 0}
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 4
          Skolems = (proxy_a9GI[sk:4] :: GHC.Types.Symbol -> *)
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                           "s" (CNonCanonical)
                  [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                      ~
                                      ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
                                        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                             "s") :: Data.Theory.UoM.Unit) (CNonCanonical)
                  [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                         "s" :: Data.Theory.UoM.Unit)
                                      ~
                                      (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                         "s" :: Data.Theory.UoM.Unit) (CNonCanonical)}
          Binds = EvBindsVar<a9GW>
          Needed = []
          the type signature for:
            Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                             -> *).
                                                            proxy "s"
                                                            -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                 Rational
                                                                 (Data.Theory.UoM.Base "s"
                                                                  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                       "s") }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 4
    Skolems = (proxy_a9GI[sk:4] :: GHC.Types.Symbol -> *)
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                     "s" (CNonCanonical)
            [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                ~
                                ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
                                  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                       "s") :: Data.Theory.UoM.Unit) (CNonCanonical)
            [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                   "s" :: Data.Theory.UoM.Unit)
                                ~
                                (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                   "s" :: Data.Theory.UoM.Unit) (CNonCanonical)}
    Binds = EvBindsVar<a9GW>
    Needed = []
    the type signature for:
      Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                       -> *).
                                                      proxy "s"
                                                      -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                           Rational
                                                           (Data.Theory.UoM.Base "s"
                                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                 "s") }
  Inerts {Unsolved goals = 0}
solveWanteds {
  WC {wc_simple =
        [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                 "s" (CNonCanonical)
        [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                            ~
                            ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
                              Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                   "s") :: Data.Theory.UoM.Unit) (CNonCanonical)
        [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                               "s" :: Data.Theory.UoM.Unit)
                            ~
                            (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                               "s" :: Data.Theory.UoM.Unit) (CNonCanonical)}
solveSimpleWanteds {
  {[WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                            "s" (CNonCanonical),
   [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                       ~
                       ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
                         Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                              "s") :: Data.Theory.UoM.Unit) (CNonCanonical),
   [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                          "s" :: Data.Theory.UoM.Unit)
                       ~
                       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "s" :: Data.Theory.UoM.Unit) (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                  ~
                                  ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
                                    Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                         "s") :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Unsolved goals = 0}
  rest of worklist = WL {Eqs = [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                                      "s" :: Data.Theory.UoM.Unit)
                                                   ~
                                                   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                      "s" :: Data.Theory.UoM.Unit) (CNonCanonical)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "s" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                    ~
                                    ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                           "s") :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                      ~
                      ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
                        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                             "s") :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~ [Data.Theory.UoM.Unit, Data.Theory.UoM.One,
     Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "s"]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.One
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                       "s"
matchFamTcM
  Matching: Data.Theory.UoM.One
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.One
  Match failed
New coercion hole: aaIR
Emitting new coercion hole
  {aaIR} :: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
extendFlatCache
  Data.Theory.UoM.One []
  [WD]
  s0_aaIQ[fuv:0]
flatten/flat-cache miss
  Data.Theory.UoM.One []
  s_aaIQ[fuv:0]
  [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                 "s"
  Match failed
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "s"
    Coercion: UnitDefs.R:CanonicalBaseUnit"s"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["s"]
  Data.Theory.UoM.Base "s"
  UnitDefs.R:CanonicalBaseUnit"s"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "s" ~ Data.Theory.UoM.Base "s"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
New coercion hole: aaIT
Emitting new coercion hole
  {aaIT} :: (Data.Theory.UoM.Base "s" :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
extendFlatCache
  Data.Theory.UoM.Base ["s"]
  [WD]
  s0_aaIS[fuv:0]
flatten/flat-cache miss
  Data.Theory.UoM.Base ["s"]
  s_aaIS[fuv:0]
  [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                           "s" :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "s"
    Coercion: UnitDefs.R:CanonicalBaseUnit"s"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["s"]
  Data.Theory.UoM.Base "s"
  UnitDefs.R:CanonicalBaseUnit"s"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "s" ~ Data.Theory.UoM.Base "s"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["s"]
  s0_aaIS[fuv:0]
Unfilled tyvar s_aaIS[fuv:0]
matchFamTcM
  Matching: s0_aaIS[fuv:0] Data.Theory.UoM./: s0_aaIS[fuv:0]
  Match failed
New coercion hole: aaIV
Emitting new coercion hole
  {aaIV} :: ((s0_aaIS[fuv:0]
              Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
extendFlatCache
  Data.Theory.UoM./: [s0_aaIS[fuv:0], s0_aaIS[fuv:0]]
  [WD]
  s0_aaIU[fuv:0]
flatten/flat-cache miss
  Data.Theory.UoM./: [s0_aaIS[fuv:0], s0_aaIS[fuv:0]]
  s_aaIU[fuv:0]
  [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                          Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
flatten }
  Data.Theory.UoM.Unit
  s0_aaIQ[fuv:0]
  s0_aaIU[fuv:0]
Emitting new wanted
  $d~_aaIW :: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
              ~
              (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
  arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9GW
  [W] $d~_a9GU
    = $d~_aaIW `cast` ((~)
                         <Data.Theory.UoM.Unit>_N
                         (Sym {aaIR})
                         (Trans
                              (Sym {aaIV})
                              (Sym (Trans (UnitDefs.R:CanonicalBaseUnit"s"[0]) {aaIT})
                               Data.Theory.UoM./: Sym (Trans
                                                           (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                           {aaIT}))_N))_R
canClass
  [WD] $d~_a9GU {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                      ~
                      ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
                        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                             "s") :: Data.Theory.UoM.Unit)
  (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
  ~
  (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                   ~
                                   (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~
                                    (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~
                                    (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
         ~
         (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) {
matchClass success
  dict (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
       ~
       (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
  witness Data.Type.Equality.$f~kab forall k (a :: k) (b :: k).
                                    (a :: k) ~~ (b :: k) =>
                                    (a :: k) ~ (b :: k)
} matchClassInst result
  GenInst [(s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
           ~~
           (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
Emitting new wanted
  $d~~_aaIX :: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
               ~~
               (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
  arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9GW
  [W] $d~_aaIW
    = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaIQ[fuv:0],
                                  s0_aaIU[fuv:0]]
                                [$d~~_aaIX]
Emitting fresh work
  [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 15[l:4,d:0] Top react: Dict/Top (solved wanted):
    [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                        ~
                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                   ~~
                                   (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Solved dicts [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Eqs = [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                                      "s" :: Data.Theory.UoM.Unit)
                                                   ~
                                                   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                      "s" :: Data.Theory.UoM.Unit) (CNonCanonical)
                         Funeqs = [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                                           "s" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "s" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~~ [Data.Theory.UoM.Unit, Data.Theory.UoM.Unit, s0_aaIQ[fuv:0],
      s0_aaIU[fuv:0]]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  s0_aaIQ[fuv:0]
  s0_aaIU[fuv:0]
Unfilled tyvar s_aaIQ[fuv:0]
Unfilled tyvar s_aaIU[fuv:0]
flatten }
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  s0_aaIQ[fuv:0]
  s0_aaIU[fuv:0]
canClass
  [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
  (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
  ~~
  (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~~
                                    (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
         ~~
         (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) {
} matchClassInst result
  GenInst [(s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
           GHC.Prim.~#
           (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
New coercion hole: aaIY
Emitting new coercion hole
  {aaIY} :: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
addTcEvBind
  a9GW
  [W] $d~~_aaIX
    = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                      s0_aaIQ[fuv:0], s0_aaIU[fuv:0]]
                    [CO U(hole:{aaIY}, s0_aaIQ[fuv:0], s0_aaIU[fuv:0])_N]
Emitting fresh work
  [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 16[l:4,d:1] Top react: Dict/Top (solved wanted):
    [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                         ~~
                         (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Solved dicts [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Eqs = [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                                      "s" :: Data.Theory.UoM.Unit)
                                                   ~
                                                   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                      "s" :: Data.Theory.UoM.Unit) (CNonCanonical)
                         Funeqs = [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                                           "s" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "s" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:eq
  s0_aaIQ[fuv:0]
  s0_aaIU[fuv:0]
can_eq_nc
  False
  [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
  nominal equality
  s0_aaIQ[fuv:0]
  s0_aaIQ[fuv:0]
  s0_aaIU[fuv:0]
  s0_aaIU[fuv:0]
flatten { FM_FlattenAll s0_aaIQ[fuv:0]
Unfilled tyvar s_aaIQ[fuv:0]
flatten } s0_aaIQ[fuv:0]
flatten { FM_FlattenAll s0_aaIU[fuv:0]
Unfilled tyvar s_aaIU[fuv:0]
flatten } s0_aaIU[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_aaIQ[fuv:0] :: Data.Theory.UoM.Unit
      TcLevel of s_aaIQ[fuv:0] is 0
  RHS: s0_aaIU[fuv:0] :: Data.Theory.UoM.Unit
addInertEq {
  Adding new inert equality: [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                                   GHC.Prim.~#
                                                   (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 17[l:4,d:2] Kept as inert:
    [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                     "s" :: Data.Theory.UoM.Unit)
                                  ~
                                  (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                     "s" :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                                           "s" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "s" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                                       "s" :: Data.Theory.UoM.Unit)
                                    ~
                                    (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                       "s" :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                         "s" :: Data.Theory.UoM.Unit)
                      ~
                      (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                         "s" :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~ [Data.Theory.UoM.Unit, Data.Theory.UoM.Base "s",
     Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Base "s"
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["s"]
  s0_aaIS[fuv:0]
Unfilled tyvar s_aaIS[fuv:0]
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "s"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "s"
    Coercion: UnitDefs.R:CanonicalBaseUnit"s"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["s"]
  Data.Theory.UoM.Base "s"
  UnitDefs.R:CanonicalBaseUnit"s"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "s" ~ Data.Theory.UoM.Base "s"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["s"]
  s0_aaIS[fuv:0]
Unfilled tyvar s_aaIS[fuv:0]
flatten }
  Data.Theory.UoM.Unit
  s0_aaIS[fuv:0]
  s0_aaIS[fuv:0]
Emitting new wanted
  $d~_aaIZ :: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
              ~
              (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9GW
  [W] $d~_a9GV
    = $d~_aaIZ `cast` ((~)
                         <Data.Theory.UoM.Unit>_N
                         (Sym {aaIT})
                         (Sym (Trans (UnitDefs.R:CanonicalBaseUnit"s"[0]) {aaIT})))_R
canClass
  [WD] $d~_a9GV {0}:: (Data.Theory.UoM.Base
                         "s" :: Data.Theory.UoM.Unit)
                      ~
                      (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                         "s" :: Data.Theory.UoM.Unit)
  (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  ~
  (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                   ~
                                   (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~
                                    (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~
                                    (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
         ~
         (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) {
matchClass success
  dict (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
       ~
       (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  witness Data.Type.Equality.$f~kab forall k (a :: k) (b :: k).
                                    (a :: k) ~~ (b :: k) =>
                                    (a :: k) ~ (b :: k)
} matchClassInst result
  GenInst [(s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
           ~~
           (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
Emitting new wanted
  $d~~_aaJ0 :: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
               ~~
               (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9GW
  [W] $d~_aaIZ
    = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaIS[fuv:0],
                                  s0_aaIS[fuv:0]]
                                [$d~~_aaJ0]
Emitting fresh work
  [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 18[l:4,d:0] Top react: Dict/Top (solved wanted):
    [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                        ~
                        (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                   ~~
                                   (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                                           "s" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "s" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~~ [Data.Theory.UoM.Unit, Data.Theory.UoM.Unit, s0_aaIS[fuv:0],
      s0_aaIS[fuv:0]]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  s0_aaIS[fuv:0]
  s0_aaIS[fuv:0]
Unfilled tyvar s_aaIS[fuv:0]
Unfilled tyvar s_aaIS[fuv:0]
flatten }
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  s0_aaIS[fuv:0]
  s0_aaIS[fuv:0]
canClass
  [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  ~~
  (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~~
                                    (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
         ~~
         (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) {
} matchClassInst result
  GenInst [(s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
           GHC.Prim.~#
           (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
New coercion hole: aaJ1
Emitting new coercion hole
  {aaJ1} :: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
addTcEvBind
  a9GW
  [W] $d~~_aaJ0
    = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                      s0_aaIS[fuv:0], s0_aaIS[fuv:0]]
                    [CO <s0_aaIS[fuv:0]>_N]
Emitting fresh work
  [WD] hole{aaJ1} {2}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 19[l:4,d:1] Top react: Dict/Top (solved wanted):
    [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                         ~~
                         (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJ1} {2}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                                           "s" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "s" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJ1} {2}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{aaJ1} {2}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:eq
  s0_aaIS[fuv:0]
  s0_aaIS[fuv:0]
Filling coercion hole aaJ1 := <s0_aaIS[fuv:0]>_N
end stage canonicalization }
Step 20[l:4,d:2] Solved by reflexivity:
    [WD] hole{aaJ1} {2}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                                           "s" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "s" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many {
flatten }
extendFlatCache
  Data.Theory.UoM.One []
  [WD]
  s0_aaIQ[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: Data.Theory.UoM.One
  Match failed
improveTopFunEqs
  Data.Theory.UoM.One [] s_aaIQ[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                                GHC.Prim.~#
                                                                (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 21[l:4,d:0] Kept as inert:
    [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                       "s" :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "s" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                         "s" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many { "s"
flatten } "s"
extendFlatCache
  Data.Theory.UoM.Base ["s"]
  [WD]
  s0_aaIS[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                         "s" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                         "s" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                           "s" :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: Data.Theory.UoM.Base "s"
  Match failed
improveTopFunEqs
  Data.Theory.UoM.Base ["s"] s_aaIS[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                                                   "s" :: Data.Theory.UoM.Unit)
                                                                GHC.Prim.~#
                                                                (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 22[l:4,d:1] Kept as inert:
    [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                             "s" :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                        "s" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                      Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                                                "s" :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Non-eqs = [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "s" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                        Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many {
  s0_aaIS[fuv:0]
  s0_aaIS[fuv:0]
Unfilled tyvar s_aaIS[fuv:0]
Unfilled tyvar s_aaIS[fuv:0]
flatten }
  s0_aaIS[fuv:0]
  s0_aaIS[fuv:0]
extendFlatCache
  Data.Theory.UoM./: [s0_aaIS[fuv:0], s0_aaIS[fuv:0]]
  [WD]
  s0_aaIU[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                        Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                        Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                          Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_aaIS[fuv:0] Data.Theory.UoM./: s0_aaIS[fuv:0]
  Match failed
improveTopFunEqs
  Data.Theory.UoM./: [s0_aaIS[fuv:0], s0_aaIS[fuv:0]] s_aaIU[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                                                  Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                                GHC.Prim.~#
                                                                (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 23[l:4,d:0] Kept as inert:
    [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                            Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                       Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                       "s" (CNonCanonical)
  inerts = {Equalities: [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                                                "s" :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                                               Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaIW {0}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaIZ {0}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaIX {1}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJ0 {1}:: (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                         "s" (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "s" (CNonCanonical)
canEvNC:cls
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit ["s"]
flatten_many { "s"
flatten } "s"
canClass
  [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "s"
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
  ContinueWith [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                        "s"
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                         "s" (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                         "s" (CDictCan(psc))
doTopReact
  [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "s" (CDictCan(psc))
matchClassInst
  pred = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s" {
matchClass success
  dict Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "s"
  witness UnitDefs.$fHasCanonicalBaseUnit"s" Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                               "s"
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for
  [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "s"
updSolvedSetTcs:
  [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "s"
addTcEvBind
  a9GW
  [W] $dHasCanonicalBaseUnit_a9GS
    = UnitDefs.$fHasCanonicalBaseUnit"s" @[] []
end stage top-level reactions }
Step 24[l:4,d:0] Top react: Dict/Top (solved wanted):
    [WD] $dHasCanonicalBaseUnit_a9GS {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                             "s"
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {[WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)}
  fun eqs = {[WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan),
             [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                      "s" :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan),
             [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                     Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)}
  insols = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{aaIR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            [WD] hole{aaIT} {1}:: (Data.Theory.UoM.Base
                                     "s" :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s0_aaIS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            [WD] hole{aaIV} {0}:: ((s0_aaIS[fuv:0]
                                    Data.Theory.UoM./: s0_aaIS[fuv:0]) :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
   Tv eqs = [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)}
Filling coercion hole
  aaIV := <s0_aaIS[fuv:0] Data.Theory.UoM./: s0_aaIS[fuv:0]>_N
unflattenFmv
  s_aaIU[fuv:0] := s0_aaIS[fuv:0] Data.Theory.UoM./: s0_aaIS[fuv:0]
writeMetaTyVar
  s_aaIU[fuv:0] :: Data.Theory.UoM.Unit := s0_aaIS[fuv:0]
                                           Data.Theory.UoM./: s0_aaIS[fuv:0]
Filling coercion hole aaIT := <Data.Theory.UoM.Base "s">_N
unflattenFmv s_aaIS[fuv:0] := Data.Theory.UoM.Base "s"
writeMetaTyVar
  s_aaIS[fuv:0] :: Data.Theory.UoM.Unit := Data.Theory.UoM.Base "s"
Filling coercion hole aaIR := <Data.Theory.UoM.One>_N
unflattenFmv s_aaIQ[fuv:0] := Data.Theory.UoM.One
writeMetaTyVar
  s_aaIQ[fuv:0] :: Data.Theory.UoM.Unit := Data.Theory.UoM.One
Unflattening 1 {}
unflatten_eq 2
  [WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
Unflattening 2
  {[WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)}
Unflattening 3 {}
Unflattening done
  {[WD] hole{aaIY} {2}:: (s0_aaIQ[fuv:0] :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         (s1_aaIU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)}
zonkSimples done:
  {[WD] hole{aaIY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         ((Data.Theory.UoM.Base "s"
                           Data.Theory.UoM./: Data.Theory.UoM.Base
                                                "s") :: Data.Theory.UoM.Unit) (CNonCanonical)}
zonkSimples done:
  {[WD] hole{aaIY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         ((Data.Theory.UoM.Base "s"
                           Data.Theory.UoM./: Data.Theory.UoM.Base
                                                "s") :: Data.Theory.UoM.Unit) (CNonCanonical)}
tcPluginSolve start thoralf-uom-plugin
  given   = []
  derived = []
  wanted  = [[WD] hole{aaIY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   ((Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.Theory.UoM.Base
                                                          "s") :: Data.Theory.UoM.Unit) (CNonCanonical)]
thoralf-solve gsConvCts Just [ ] [] []
thoralf-solve wsConvCts
  Just [ (= ((as const (Array String Int)) 0) ((_ map (- (Int Int) Int)) (store base "s" n1) (store base "s" n1))) ] [[WD] hole{aaIY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                                                                                                            GHC.Prim.~#
                                                                                                                                            ((Data.Theory.UoM.Base
                                                                                                                                                "s"
                                                                                                                                              Data.Theory.UoM./: Data.Theory.UoM.Base
                                                                                                                                                                   "s") :: Data.Theory.UoM.Unit) (CNonCanonical)] []
thoralf-solve decls []
thoralf-solve decls filtered []
thoralf-solve givens []
thoralf-solve givens filtered []
thoralf-solve wanteds
  [[WD] hole{aaIY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         ((Data.Theory.UoM.Base "s"
                           Data.Theory.UoM./: Data.Theory.UoM.Base
                                                "s") :: Data.Theory.UoM.Unit) (CNonCanonical)]
thoralf-solve wanteds filtered
  [[WD] hole{aaIY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         ((Data.Theory.UoM.Base "s"
                           Data.Theory.UoM./: Data.Theory.UoM.Base
                                                "s") :: Data.Theory.UoM.Unit) (CNonCanonical)]
thoralf-solve simplified given sexprs []
thoralf-solve simplified wanteds
  [(CO U(plugin:thoralf, Data.Theory.UoM.One, Data.Theory.UoM.Base
                                                "s"
                                              Data.Theory.UoM./: Data.Theory.UoM.Base "s")_N,
    [WD] hole{aaIY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          ((Data.Theory.UoM.Base "s"
                            Data.Theory.UoM./: Data.Theory.UoM.Base
                                                 "s") :: Data.Theory.UoM.Unit) (CNonCanonical))]
tcPluginSolve ok thoralf-uom-plugin
  solved = [(CO U(plugin:thoralf, Data.Theory.UoM.One, Data.Theory.UoM.Base
                                                         "s"
                                                       Data.Theory.UoM./: Data.Theory.UoM.Base
                                                                            "s")_N,
             [WD] hole{aaIY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   ((Data.Theory.UoM.Base "s"
                                     Data.Theory.UoM./: Data.Theory.UoM.Base
                                                          "s") :: Data.Theory.UoM.Unit) (CNonCanonical))]
  new    = []
tcPluginSolve start uom-eq-plugin
  given   = []
  derived = []
  wanted  = []
tcPluginSolve ok uom-eq-plugin
  solved = []
  new    = []
tcPluginSolve start uom-unpack-plugin
  given   = []
  derived = []
  wanted  = []
tcPluginSolve ok uom-unpack-plugin
  solved = []
  new    = []
Filling coercion hole
  aaIY := U(plugin:thoralf, Data.Theory.UoM.One, Data.Theory.UoM.Base
                                                   "s"
                                                 Data.Theory.UoM./: Data.Theory.UoM.Base "s")_N
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {[W] $d~_a9GU
                        = $d~_aaIW `cast` ((~)
                                             <Data.Theory.UoM.Unit>_N
                                             (Sym {aaIR})
                                             (Trans
                                                  (Sym {aaIV})
                                                  (Sym (Trans
                                                            (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                            {aaIT})
                                                   Data.Theory.UoM./: Sym (Trans
                                                                               (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                                               {aaIT}))_N))_R,
                      [W] $d~_aaIW
                        = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaIQ[fuv:0],
                                                      s0_aaIU[fuv:0]]
                                                    [$d~~_aaIX],
                      [W] $d~~_aaIX
                        = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                          s0_aaIQ[fuv:0], s0_aaIU[fuv:0]]
                                        [CO U(hole:{aaIY}, s0_aaIQ[fuv:0], s0_aaIU[fuv:0])_N],
                      [W] $d~_a9GV
                        = $d~_aaIZ `cast` ((~)
                                             <Data.Theory.UoM.Unit>_N
                                             (Sym {aaIT})
                                             (Sym (Trans
                                                       (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                       {aaIT})))_R,
                      [W] $d~_aaIZ
                        = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaIS[fuv:0],
                                                      s0_aaIS[fuv:0]]
                                                    [$d~~_aaJ0],
                      [W] $d~~_aaJ0
                        = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                          s0_aaIS[fuv:0], s0_aaIS[fuv:0]]
                                        [CO <s0_aaIS[fuv:0]>_N],
                      [W] $dHasCanonicalBaseUnit_a9GS
                        = UnitDefs.$fHasCanonicalBaseUnit"s" @[] []}
getNoGivenEqs
  False
  {Unsolved goals = 0}
  {}
floatEqualities
  Skols = [proxy_a9GI[sk:4]]
  Simples = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus 2
  []
  ([a9GU :-> [W] $d~_a9GU
               = $d~_aaIW `cast` ((~)
                                    <Data.Theory.UoM.Unit>_N
                                    (Sym {aaIR})
                                    (Trans
                                         (Sym {aaIV})
                                         (Sym (Trans (UnitDefs.R:CanonicalBaseUnit"s"[0]) {aaIT})
                                          Data.Theory.UoM./: Sym (Trans
                                                                      (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                                      {aaIT}))_N))_R,
    aaIW :-> [W] $d~_aaIW
               = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaIQ[fuv:0],
                                             s0_aaIU[fuv:0]]
                                           [$d~~_aaIX],
    aaIX :-> [W] $d~~_aaIX
               = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                 s0_aaIQ[fuv:0], s0_aaIU[fuv:0]]
                               [CO U(hole:{aaIY}, s0_aaIQ[fuv:0], s0_aaIU[fuv:0])_N],
    a9GV :-> [W] $d~_a9GV
               = $d~_aaIZ `cast` ((~)
                                    <Data.Theory.UoM.Unit>_N
                                    (Sym {aaIT})
                                    (Sym (Trans (UnitDefs.R:CanonicalBaseUnit"s"[0]) {aaIT})))_R,
    aaIZ :-> [W] $d~_aaIZ
               = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaIS[fuv:0],
                                             s0_aaIS[fuv:0]]
                                           [$d~~_aaJ0],
    aaJ0 :-> [W] $d~~_aaJ0
               = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                 s0_aaIS[fuv:0], s0_aaIS[fuv:0]]
                               [CO <s0_aaIS[fuv:0]>_N],
    a9GS :-> [W] $dHasCanonicalBaseUnit_a9GS
               = UnitDefs.$fHasCanonicalBaseUnit"s" @[] []],
   [])
  []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {[W] $d~_a9GU
                           = $d~_aaIW `cast` ((~)
                                                <Data.Theory.UoM.Unit>_N
                                                (Sym {aaIR})
                                                (Trans
                                                     (Sym {aaIV})
                                                     (Sym (Trans
                                                               (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                               {aaIT})
                                                      Data.Theory.UoM./: Sym (Trans
                                                                                  (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                                                  {aaIT}))_N))_R,
                         [W] $d~_aaIW
                           = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaIQ[fuv:0],
                                                         s0_aaIU[fuv:0]]
                                                       [$d~~_aaIX],
                         [W] $d~~_aaIX
                           = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                             s0_aaIQ[fuv:0], s0_aaIU[fuv:0]]
                                           [CO U(hole:{aaIY}, s0_aaIQ[fuv:0], s0_aaIU[fuv:0])_N],
                         [W] $d~_a9GV
                           = $d~_aaIZ `cast` ((~)
                                                <Data.Theory.UoM.Unit>_N
                                                (Sym {aaIT})
                                                (Sym (Trans
                                                          (UnitDefs.R:CanonicalBaseUnit"s"[0])
                                                          {aaIT})))_R,
                         [W] $d~_aaIZ
                           = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaIS[fuv:0],
                                                         s0_aaIS[fuv:0]]
                                                       [$d~~_aaJ0],
                         [W] $d~~_aaJ0
                           = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                             s0_aaIS[fuv:0], s0_aaIS[fuv:0]]
                                           [CO <s0_aaIS[fuv:0]>_N],
                         [W] $dHasCanonicalBaseUnit_a9GS
                           = UnitDefs.$fHasCanonicalBaseUnit"s" @[] []}
  implication tvcs = []
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Nothing}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
getNoGivenEqs
  False
  {Unsolved goals = 0}
  {}
floatEqualities
  Skols = []
  Simples = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus 2
  []
  ([], [])
  []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {}
  implication tvcs = []
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Nothing, Nothing}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
getNoGivenEqs
  False
  {Unsolved goals = 0}
  {}
floatEqualities
  Skols = []
  Simples = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus 2
  []
  ([], [])
  []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {}
  implication tvcs = []
solveImplication {
  Implic {
    TcLevel = 2
    Skolems =
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_impl =
            Implic {
              TcLevel = 3
              Skolems =
              No-eqs = False
              Status = Unsolved
              Given =
              Wanted =
                WC {wc_simple =
                      [WD] irred_a9H0 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                              (Data.UnitsOfMeasure.Syntax.Unpack
                                                 (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                    "kg")) (CNonCanonical)}
              Binds = EvBindsVar<a9H1>
              Needed = []
              the instance declaration }
            Implic {
              TcLevel = 3
              Skolems =
              No-eqs = False
              Status = Unsolved
              Given =
              Wanted =
                WC {wc_impl =
                      Implic {
                        TcLevel = 4
                        Skolems = (proxy_a9H6[sk:4] :: GHC.Types.Symbol -> *)
                        No-eqs = False
                        Status = Unsolved
                        Given =
                        Wanted =
                          WC {wc_simple =
                                [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                         "kg" (CNonCanonical)
                                [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                    ~
                                                    ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                        "kg"
                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                           "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)
                                [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                                       "kg" :: Data.Theory.UoM.Unit)
                                                    ~
                                                    (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                       "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                        Binds = EvBindsVar<a9He>
                        Needed = []
                        the type signature for:
                          Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                           -> *).
                                                                          proxy "kg"
                                                                          -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                               Rational
                                                                               (Data.Theory.UoM.Base
                                                                                  "kg"
                                                                                Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                     "kg") }}
              Binds = EvBindsVar<a9Hf>
              Needed = []
              the instance declaration }}
    Binds = EvBindsVar<a9GZ>
    Needed = []
    the instance declaration }
  Inerts {Unsolved goals = 0}
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 3
          Skolems =
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] irred_a9H0 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                          (Data.UnitsOfMeasure.Syntax.Unpack
                                             (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                "kg")) (CNonCanonical)}
          Binds = EvBindsVar<a9H1>
          Needed = []
          the instance declaration }
        Implic {
          TcLevel = 3
          Skolems =
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 4
                    Skolems = (proxy_a9H6[sk:4] :: GHC.Types.Symbol -> *)
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                     "kg" (CNonCanonical)
                            [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                ~
                                                ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                    "kg"
                                                  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                       "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)
                            [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                                   "kg" :: Data.Theory.UoM.Unit)
                                                ~
                                                (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                   "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                    Binds = EvBindsVar<a9He>
                    Needed = []
                    the type signature for:
                      Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                       -> *).
                                                                      proxy "kg"
                                                                      -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                           Rational
                                                                           (Data.Theory.UoM.Base
                                                                              "kg"
                                                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                 "kg") }}
          Binds = EvBindsVar<a9Hf>
          Needed = []
          the instance declaration }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 3
    Skolems =
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] irred_a9H0 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                    (Data.UnitsOfMeasure.Syntax.Unpack
                                       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "kg")) (CNonCanonical)}
    Binds = EvBindsVar<a9H1>
    Needed = []
    the instance declaration }
  Inerts {Unsolved goals = 0}
solveWanteds {
  WC {wc_simple =
        [WD] irred_a9H0 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                (Data.UnitsOfMeasure.Syntax.Unpack
                                   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                      "kg")) (CNonCanonical)}
solveSimpleWanteds {
  {[WD] irred_a9H0 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                           (Data.UnitsOfMeasure.Syntax.Unpack
                              (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                 "kg")) (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_a9H0 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                      (Data.UnitsOfMeasure.Syntax.Unpack
                                         (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                            "kg")) (CNonCanonical)
  inerts = {Unsolved goals = 0}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] irred_a9H0 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                        (Data.UnitsOfMeasure.Syntax.Unpack
                                           (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                              "kg")) (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_a9H0 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                          (Data.UnitsOfMeasure.Syntax.Unpack
                             (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                "kg")) (CNonCanonical)
canEvNC:irred
  Data.UnitsOfMeasure.Canonical.IsCanonical
    (Data.UnitsOfMeasure.Syntax.Unpack
       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"))
can_pred
  IrredPred =  Data.UnitsOfMeasure.Canonical.IsCanonical
                 (Data.UnitsOfMeasure.Syntax.Unpack
                    (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"))
flatten {
  FM_FlattenAll Data.UnitsOfMeasure.Canonical.IsCanonical
                  (Data.UnitsOfMeasure.Syntax.Unpack
                     (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"))
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical
              (Data.UnitsOfMeasure.Syntax.Unpack
                 (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"))
  Match failed
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack
              (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg")
  Match failed
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "kg"
    Coercion: UnitDefs.R:CanonicalBaseUnit"kg"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["kg"]
  Data.Theory.UoM.Base "kg"
  UnitDefs.R:CanonicalBaseUnit"kg"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "kg" ~ Data.Theory.UoM.Base "kg"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
New coercion hole: aaJ3
Emitting new coercion hole
  {aaJ3} :: (Data.Theory.UoM.Base "kg" :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit)
extendFlatCache
  Data.Theory.UoM.Base ["kg"]
  [WD]
  s0_aaJ2[fuv:0]
flatten/flat-cache miss
  Data.Theory.UoM.Base ["kg"]
  s_aaJ2[fuv:0]
  [WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                           "kg" :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack s0_aaJ2[fuv:0]
  Match failed
New coercion hole: aaJ5
Emitting new coercion hole
  {aaJ5} :: (Data.UnitsOfMeasure.Syntax.Unpack
               s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                   GHC.Types.Symbol)
            GHC.Prim.~#
            (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                 GHC.Types.Symbol)
extendFlatCache
  Data.UnitsOfMeasure.Syntax.Unpack [s0_aaJ2[fuv:0]]
  [WD]
  s0_aaJ4[fuv:0]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Syntax.Unpack [s0_aaJ2[fuv:0]]
  s_aaJ4[fuv:0]
  [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                           s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
                        GHC.Prim.~#
                        (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                             GHC.Types.Symbol)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical s0_aaJ4[fuv:0]
  Match failed
New coercion hole: aaJ7
Emitting new coercion hole
  {aaJ7} :: (Data.UnitsOfMeasure.Canonical.IsCanonical
               s0_aaJ4[fuv:0] :: Constraint)
            GHC.Prim.~#
            (s1_aaJ6[fuv:0] :: Constraint)
extendFlatCache
  Data.UnitsOfMeasure.Canonical.IsCanonical [s0_aaJ4[fuv:0]]
  [WD]
  s0_aaJ6[fuv:0]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Canonical.IsCanonical [s0_aaJ4[fuv:0]]
  s_aaJ6[fuv:0]
  [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                           s0_aaJ4[fuv:0] :: Constraint)
                        GHC.Prim.~#
                        (s1_aaJ6[fuv:0] :: Constraint)
flatten } s0_aaJ6[fuv:0]
Emitting new wanted
  irred_aaJ8 :: s0_aaJ6[fuv:0]
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9H1
  [W] irred_a9H0
    = irred_aaJ8 `cast` (Sub
                           (Sym
                              U(hole:{aaJ7}, Data.UnitsOfMeasure.Canonical.IsCanonical
                                               s0_aaJ4[fuv:0], s0_aaJ6[fuv:0])_N
                            ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                 (Trans
                                      (Sym {aaJ5})
                                      (Data.UnitsOfMeasure.Syntax.Unpack
                                         (Sym (Trans
                                                   (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                   {aaJ3})))_N))_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_aaJ8 {0}:: s0_aaJ6[fuv:0] (CIrredEvCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] irred_aaJ8 {0}:: s0_aaJ6[fuv:0] (CIrredEvCan)
doTopReact [WD] irred_aaJ8 {0}:: s0_aaJ6[fuv:0] (CIrredEvCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] irred_aaJ8 {0}:: s0_aaJ6[fuv:0] (CIrredEvCan)
addInertCan }
Step 25[l:3,d:0] Kept as inert:
    [WD] irred_aaJ8 {0}:: s0_aaJ6[fuv:0]
End solver pipeline (kept as inert) }
  final_item = [WD] irred_aaJ8 {0}:: s0_aaJ6[fuv:0] (CIrredEvCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                                       "kg" :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Irreds = [WD] irred_aaJ8 {0}:: s0_aaJ6[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                           s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                        GHC.Prim.~#
                                                        (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                             GHC.Types.Symbol) (CFunEqCan)
                                  [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           s0_aaJ4[fuv:0] :: Constraint)
                                                        GHC.Prim.~#
                                                        (s1_aaJ6[fuv:0] :: Constraint) (CFunEqCan)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                                         "kg" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many { "kg"
flatten } "kg"
extendFlatCache
  Data.Theory.UoM.Base ["kg"]
  [WD]
  s0_aaJ2[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                                         "kg" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                                         "kg" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                           "kg" :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
improveTopFunEqs
  Data.Theory.UoM.Base ["kg"] s_aaJ2[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                                                                   "kg" :: Data.Theory.UoM.Unit)
                                                                GHC.Prim.~#
                                                                (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 26[l:3,d:1] Kept as inert:
    [WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                             "kg" :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                                        "kg" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                       s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                                    GHC.Prim.~#
                                    (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                                                                "kg" :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Irreds = [WD] irred_aaJ8 {0}:: s0_aaJ6[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           s0_aaJ4[fuv:0] :: Constraint)
                                                        GHC.Prim.~#
                                                        (s1_aaJ6[fuv:0] :: Constraint) (CFunEqCan)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                         s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
flatten_many { s0_aaJ2[fuv:0]
Unfilled tyvar s_aaJ2[fuv:0]
flatten } s0_aaJ2[fuv:0]
extendFlatCache
  Data.UnitsOfMeasure.Syntax.Unpack [s0_aaJ2[fuv:0]]
  [WD]
  s0_aaJ4[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                         s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                         s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
doTopReact
  [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                           s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
                        GHC.Prim.~#
                        (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                             GHC.Types.Symbol) (CFunEqCan)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack s0_aaJ2[fuv:0]
  Match failed
improveTopFunEqs
  Data.UnitsOfMeasure.Syntax.Unpack [s0_aaJ2[fuv:0]] s_aaJ4[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                                   s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                       GHC.Types.Symbol)
                                                                GHC.Prim.~#
                                                                (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                     GHC.Types.Symbol) (CFunEqCan)
addInertCan }
Step 27[l:3,d:0] Kept as inert:
    [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                             s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                 GHC.Types.Symbol)
                          GHC.Prim.~#
                          (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                       s0_aaJ4[fuv:0] :: Constraint)
                                    GHC.Prim.~#
                                    (s1_aaJ6[fuv:0] :: Constraint) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                                                                "kg" :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                                s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Irreds = [WD] irred_aaJ8 {0}:: s0_aaJ6[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                         s0_aaJ4[fuv:0] :: Constraint)
                                      GHC.Prim.~#
                                      (s1_aaJ6[fuv:0] :: Constraint) (CFunEqCan)
flatten_many { s0_aaJ4[fuv:0]
Unfilled tyvar s_aaJ4[fuv:0]
flatten } s0_aaJ4[fuv:0]
extendFlatCache
  Data.UnitsOfMeasure.Canonical.IsCanonical [s0_aaJ4[fuv:0]]
  [WD]
  s0_aaJ6[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                         s0_aaJ4[fuv:0] :: Constraint)
                                      GHC.Prim.~#
                                      (s1_aaJ6[fuv:0] :: Constraint) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                         s0_aaJ4[fuv:0] :: Constraint)
                                      GHC.Prim.~#
                                      (s1_aaJ6[fuv:0] :: Constraint) (CFunEqCan)
doTopReact
  [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                           s0_aaJ4[fuv:0] :: Constraint)
                        GHC.Prim.~#
                        (s1_aaJ6[fuv:0] :: Constraint) (CFunEqCan)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical s0_aaJ4[fuv:0]
  Match failed
improveTopFunEqs
  Data.UnitsOfMeasure.Canonical.IsCanonical [s0_aaJ4[fuv:0]] s_aaJ6[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                                   s0_aaJ4[fuv:0] :: Constraint)
                                                                GHC.Prim.~#
                                                                (s1_aaJ6[fuv:0] :: Constraint) (CFunEqCan)
addInertCan }
Step 28[l:3,d:0] Kept as inert:
    [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                             s0_aaJ4[fuv:0] :: Constraint)
                          GHC.Prim.~#
                          (s1_aaJ6[fuv:0] :: Constraint)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                        s0_aaJ4[fuv:0] :: Constraint)
                                     GHC.Prim.~#
                                     (s1_aaJ6[fuv:0] :: Constraint) (CFunEqCan)
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {[WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                                      "kg" :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan),
             [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                      s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                        GHC.Types.Symbol) (CFunEqCan),
             [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                      s0_aaJ4[fuv:0] :: Constraint)
                                   GHC.Prim.~#
                                   (s1_aaJ6[fuv:0] :: Constraint) (CFunEqCan)}
  insols = {}
  others = {[WD] irred_aaJ8 {0}:: s0_aaJ6[fuv:0] (CIrredEvCan)}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{aaJ3} {1}:: (Data.Theory.UoM.Base
                                     "kg" :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s0_aaJ2[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            [WD] hole{aaJ5} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                     s0_aaJ2[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol)
                                  GHC.Prim.~#
                                  (s1_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                       GHC.Types.Symbol) (CFunEqCan)
            [WD] hole{aaJ7} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                     s0_aaJ4[fuv:0] :: Constraint)
                                  GHC.Prim.~#
                                  (s1_aaJ6[fuv:0] :: Constraint) (CFunEqCan)
   Tv eqs =}
Filling coercion hole
  aaJ7 := <Data.UnitsOfMeasure.Canonical.IsCanonical
             s0_aaJ4[fuv:0]>_N
unflattenFmv
  s_aaJ6[fuv:0] := Data.UnitsOfMeasure.Canonical.IsCanonical
                     s0_aaJ4[fuv:0]
writeMetaTyVar
  s_aaJ6[fuv:0] :: Constraint := Data.UnitsOfMeasure.Canonical.IsCanonical
                                   s0_aaJ4[fuv:0]
Filling coercion hole
  aaJ5 := <Data.UnitsOfMeasure.Syntax.Unpack s0_aaJ2[fuv:0]>_N
unflattenFmv
  s_aaJ4[fuv:0] := Data.UnitsOfMeasure.Syntax.Unpack s0_aaJ2[fuv:0]
writeMetaTyVar
  s_aaJ4[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                     GHC.Types.Symbol := Data.UnitsOfMeasure.Syntax.Unpack
                                           s0_aaJ2[fuv:0]
Filling coercion hole aaJ3 := <Data.Theory.UoM.Base "kg">_N
unflattenFmv s_aaJ2[fuv:0] := Data.Theory.UoM.Base "kg"
writeMetaTyVar
  s_aaJ2[fuv:0] :: Data.Theory.UoM.Unit := Data.Theory.UoM.Base "kg"
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
zonkSimples done: {}
zonkSimples done:
  {[WD] irred_aaJ8 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                           (Data.UnitsOfMeasure.Syntax.Unpack
                              (Data.Theory.UoM.Base "kg")) (CNonCanonical)}
tcPluginSolve start thoralf-uom-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_aaJ8 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                     (Data.UnitsOfMeasure.Syntax.Unpack
                                        (Data.Theory.UoM.Base "kg")) (CNonCanonical)]
thoralf-solve gsConvCts Just [ ] [] []
thoralf-solve wsConvCts Just [ ] [] []
thoralf-solve decls []
thoralf-solve decls filtered []
thoralf-solve givens []
thoralf-solve givens filtered []
thoralf-solve wanteds
  [[WD] irred_aaJ8 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                           (Data.UnitsOfMeasure.Syntax.Unpack
                              (Data.Theory.UoM.Base "kg")) (CNonCanonical)]
thoralf-solve wanteds filtered
  [[WD] irred_aaJ8 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                           (Data.UnitsOfMeasure.Syntax.Unpack
                              (Data.Theory.UoM.Base "kg")) (CNonCanonical)]
thoralf-solve simplified given sexprs []
thoralf-solve simplified wanteds []
tcPluginSolve ok thoralf-uom-plugin
  solved = []
  new    = []
tcPluginSolve start uom-eq-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_aaJ8 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                     (Data.UnitsOfMeasure.Syntax.Unpack
                                        (Data.Theory.UoM.Base "kg")) (CNonCanonical)]
tcPluginSolve ok uom-eq-plugin
  solved = []
  new    = []
tcPluginSolve start uom-unpack-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_aaJ8 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                     (Data.UnitsOfMeasure.Syntax.Unpack
                                        (Data.Theory.UoM.Base "kg")) (CNonCanonical)]
addTcEvBind
  a9H1
  [G] cobox_aaJ9
    = CO U(plugin:units, Data.UnitsOfMeasure.Syntax.Unpack
                           (Data.Theory.UoM.Base "kg"), '["kg"]
                                                        'Data.UnitsOfMeasure.Syntax.:/ '[])_N
tcPluginSolve ok uom-unpack-plugin
  solved = []
  new    = [[G] cobox_aaJ9 {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                    (Data.Theory.UoM.Base
                                       "kg") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                  GHC.Types.Symbol)
                                 GHC.Prim.~#
                                 (('["kg"]
                                   'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CNonCanonical)]
solveSimple going round again:
  0
  True
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_aaJ9 {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                      (Data.Theory.UoM.Base
                                         "kg") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                    GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (('["kg"]
                                     'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol) (CNonCanonical)
  inerts = {Unsolved goals = 0}
  rest of worklist = WL {Non-eqs = [WD] irred_aaJ8 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           (Data.UnitsOfMeasure.Syntax.Unpack
                                                              (Data.Theory.UoM.Base
                                                                 "kg")) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [G] cobox_aaJ9 {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        (Data.Theory.UoM.Base
                                           "kg") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                      GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (('["kg"]
                                       'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                GHC.Types.Symbol) (CNonCanonical)
canonicalize (non-canonical)
  [G] cobox_aaJ9 {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                          (Data.Theory.UoM.Base
                             "kg") :: Data.UnitsOfMeasure.Syntax.UnitSyntax GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["kg"]
                         'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol) (CNonCanonical)
canEvNC:eq
  Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "kg")
  '["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
can_eq_nc
  False
  [G] cobox_aaJ9 {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                          (Data.Theory.UoM.Base
                             "kg") :: Data.UnitsOfMeasure.Syntax.UnitSyntax GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["kg"]
                         'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
  nominal equality
  Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "kg")
  Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "kg")
  '["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
  '["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
flatten {
  FM_FlattenAll Data.UnitsOfMeasure.Syntax.Unpack
                  (Data.Theory.UoM.Base "kg")
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack
              (Data.Theory.UoM.Base "kg")
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
addTcEvBind
  a9H1
  [G] cobox_aaJb = CO <Data.Theory.UoM.Base "kg">_N
extendFlatCache
  Data.Theory.UoM.Base ["kg"]
  [G]
  fsk0_aaJa[fsk]
flatten/flat-cache miss
  Data.Theory.UoM.Base ["kg"]
  fsk_aaJa[fsk]
  [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                          "kg" :: Data.Theory.UoM.Unit)
                       GHC.Prim.~#
                       (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaJa[fsk]
  Match failed
addTcEvBind
  a9H1
  [G] cobox_aaJd
    = CO <Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaJa[fsk]>_N
extendFlatCache
  Data.UnitsOfMeasure.Syntax.Unpack [fsk0_aaJa[fsk]]
  [G]
  fsk0_aaJc[fsk]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Syntax.Unpack [fsk0_aaJa[fsk]]
  fsk_aaJc[fsk]
  [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                          fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                       GHC.Prim.~#
                       (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol)
flatten } fsk0_aaJc[fsk]
flatten { FM_FlattenAll '["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
flatten } '["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (('["kg"]
                                       'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                GHC.Types.Symbol) (CTyEqCan)
Can't solve tyvar equality
  LHS: fsk_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                          GHC.Types.Symbol
  RHS: '["kg"]
       'Data.UnitsOfMeasure.Syntax.:/ '[] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol
addInertEq {
  Adding new inert equality: [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                       GHC.Types.Symbol)
                                                  GHC.Prim.~#
                                                  (('["kg"]
                                                    'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                             GHC.Types.Symbol) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 29[l:3,d:0] Kept as inert:
    [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                         GHC.Prim.~#
                         (('["kg"]
                           'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                    GHC.Types.Symbol)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                      "kg" :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Equalities: [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Unsolved goals = 0}
  rest of worklist = WL {Funeqs = [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                          fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CFunEqCan)
                         Non-eqs = [WD] irred_aaJ8 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           (Data.UnitsOfMeasure.Syntax.Unpack
                                                              (Data.Theory.UoM.Base
                                                                 "kg")) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                        "kg" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many { "kg"
flatten } "kg"
extendFlatCache
  Data.Theory.UoM.Base ["kg"]
  [G]
  fsk0_aaJa[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                        "kg" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                        "kg" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                          "kg" :: Data.Theory.UoM.Unit)
                       GHC.Prim.~#
                       (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                                                  "kg" :: Data.Theory.UoM.Unit)
                                                               GHC.Prim.~#
                                                               (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 30[l:3,d:0] Kept as inert:
    [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                            "kg" :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                       "kg" :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                      fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                        GHC.Types.Symbol) (CFunEqCan)
  inerts = {Equalities: [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                                               "kg" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Unsolved goals = 0}
  rest of worklist = WL {Non-eqs = [WD] irred_aaJ8 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           (Data.UnitsOfMeasure.Syntax.Unpack
                                                              (Data.Theory.UoM.Base
                                                                 "kg")) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
flatten_many { fsk0_aaJa[fsk]
Unfilled tyvar fsk_aaJa[fsk]
flatten } fsk0_aaJa[fsk]
extendFlatCache
  Data.UnitsOfMeasure.Syntax.Unpack [fsk0_aaJa[fsk]]
  [G]
  fsk0_aaJc[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
doTopReact
  [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                          fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                       GHC.Prim.~#
                       (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol) (CFunEqCan)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaJa[fsk]
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                                  fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                      GHC.Types.Symbol)
                                                               GHC.Prim.~#
                                                               (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol) (CFunEqCan)
addInertCan }
Step 31[l:3,d:0] Kept as inert:
    [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                            fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                GHC.Types.Symbol)
                         GHC.Prim.~#
                         (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                       fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                                    GHC.Prim.~#
                                    (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_aaJ8 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                      (Data.UnitsOfMeasure.Syntax.Unpack
                                         (Data.Theory.UoM.Base "kg")) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                                               "kg" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] irred_aaJ8 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                        (Data.UnitsOfMeasure.Syntax.Unpack
                                           (Data.Theory.UoM.Base "kg")) (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_aaJ8 {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                          (Data.UnitsOfMeasure.Syntax.Unpack
                             (Data.Theory.UoM.Base "kg")) (CNonCanonical)
canEvNC:irred
  Data.UnitsOfMeasure.Canonical.IsCanonical
    (Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "kg"))
can_pred
  IrredPred =  Data.UnitsOfMeasure.Canonical.IsCanonical
                 (Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "kg"))
flatten {
  FM_FlattenAll Data.UnitsOfMeasure.Canonical.IsCanonical
                  (Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "kg"))
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical
              (Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "kg"))
  Match failed
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack
              (Data.Theory.UoM.Base "kg")
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["kg"]
  fsk0_aaJa[fsk]
Unfilled tyvar fsk_aaJa[fsk]
flatten/flat-cache hit
  Data.UnitsOfMeasure.Syntax.Unpack [fsk0_aaJa[fsk]]
  fsk0_aaJc[fsk]
Unfilled tyvar fsk_aaJc[fsk]
Following inert tyvar
  FM_FlattenAll fsk_aaJc[fsk] = '["kg"]
                                'Data.UnitsOfMeasure.Syntax.:/ '[]
  [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["kg"]
                         'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical
              ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
  Match succeeded:
    Rewrites to: (Data.UnitsOfMeasure.Canonical.AllIsCanonical '["kg"],
                  Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
    Coercion: Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                <'["kg"]>_N <'[]>_N
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.IsCanonical
  ['["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]]
  (Data.UnitsOfMeasure.Canonical.AllIsCanonical '["kg"],
   Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
  Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
    <'["kg"]>_N <'[]>_N :: Data.UnitsOfMeasure.Canonical.IsCanonical
                             ('["kg"]
                              'Data.UnitsOfMeasure.Syntax.:/ '[]) ~ (Data.UnitsOfMeasure.Canonical.AllIsCanonical
                                                                       '["kg"],
                                                                     Data.UnitsOfMeasure.Canonical.AllIsCanonical
                                                                       '[])
  True
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.AllIsCanonical '["kg"]
  Match succeeded:
    Rewrites to: ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                     "kg" :: Data.Theory.UoM.Unit)
                  ~
                  (Data.Theory.UoM.Base "kg" :: Data.Theory.UoM.Unit),
                  Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
    Coercion: Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                <"kg">_N <'[]>_N
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.AllIsCanonical
  ['["kg"]]
  ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
      "kg" :: Data.Theory.UoM.Unit)
   ~
   (Data.Theory.UoM.Base "kg" :: Data.Theory.UoM.Unit),
   Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
  Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
    <"kg">_N <'[]>_N :: Data.UnitsOfMeasure.Canonical.AllIsCanonical
                          '["kg"] ~ ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                        "kg" :: Data.Theory.UoM.Unit)
                                     ~
                                     (Data.Theory.UoM.Base "kg" :: Data.Theory.UoM.Unit),
                                     Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
  False
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "kg"
    Coercion: UnitDefs.R:CanonicalBaseUnit"kg"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["kg"]
  Data.Theory.UoM.Base "kg"
  UnitDefs.R:CanonicalBaseUnit"kg"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "kg" ~ Data.Theory.UoM.Base "kg"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["kg"]
  fsk0_aaJa[fsk]
Unfilled tyvar fsk_aaJa[fsk]
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["kg"]
  fsk0_aaJa[fsk]
Unfilled tyvar fsk_aaJa[fsk]
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.AllIsCanonical '[]
  Match succeeded:
    Rewrites to: () :: Constraint
    Coercion: Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.AllIsCanonical
  ['[]]
  () :: Constraint
  Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0] :: Data.UnitsOfMeasure.Canonical.AllIsCanonical
                                                           '[] ~ () :: Constraint
  False
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.AllIsCanonical '[]
  Match succeeded:
    Rewrites to: () :: Constraint
    Coercion: Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.AllIsCanonical
  ['[]]
  () :: Constraint
  Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0] :: Data.UnitsOfMeasure.Canonical.AllIsCanonical
                                                           '[] ~ () :: Constraint
  False
extendFlatCache
  Data.UnitsOfMeasure.Canonical.IsCanonical ['["kg"]
                                             'Data.UnitsOfMeasure.Syntax.:/ '[]]
  [WD]
  (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
    ~
    (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
    () :: Constraint),
   () :: Constraint)
flatten }
  (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
    ~
    (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
    () :: Constraint),
   () :: Constraint)
Emitting new wanted
  $d(%,%)_aaJe :: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                    ~
                    (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                    () :: Constraint),
                   () :: Constraint)
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9H1
  [W] irred_aaJ8
    = $d(%,%)_aaJe `cast` (Sub
                             (Sym
                                (Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                                   <'["kg"]>_N <'[]>_N
                                 ; Sym
                                     (GHC.Classes.(%,%)
                                        (Sym (Trans
                                                  (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                                                       <"kg">_N <'[]>_N)
                                                  (Sym (GHC.Classes.(%,%)
                                                          ((~)
                                                             <Data.Theory.UoM.Unit>_N
                                                             (Sym (Trans
                                                                       (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                                       cobox))
                                                             (Sym cobox))_N
                                                          (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)))
                                        (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)
                              ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                   (Trans
                                        (Trans (Sym cobox) (Sym cobox))
                                        (Data.UnitsOfMeasure.Syntax.Unpack (Sym cobox))_N))_N))
flatten_many {
  ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
   ~
   (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
   () :: Constraint)
  () :: Constraint
Unfilled tyvar fsk_aaJa[fsk]
Unfilled tyvar fsk_aaJa[fsk]
flatten }
  ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
   ~
   (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
   () :: Constraint)
  () :: Constraint
canClass
  [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint),
                           () :: Constraint)
  (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
    ~
    (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
    () :: Constraint),
   () :: Constraint)
  ContinueWith [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                         ~
                                         (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                         () :: Constraint),
                                        () :: Constraint)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                          ~
                                          (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                          () :: Constraint),
                                         () :: Constraint) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                          ~
                                          (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                          () :: Constraint),
                                         () :: Constraint) (CDictCan(psc))
doTopReact
  [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint),
                           () :: Constraint) (CDictCan(psc))
matchClassInst
  pred = (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
           ~
           (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
           () :: Constraint),
          () :: Constraint) {
} matchClassInst result
  GenInst [((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
            ~
            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
            () :: Constraint),
           () :: Constraint]
          [safe]
doTopReact/found instance for
  [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint),
                           () :: Constraint)
updSolvedSetTcs:
  [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint),
                           () :: Constraint)
Emitting new wanted
  $d(%,%)_aaJf :: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                   ~
                   (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                   () :: Constraint)
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
Emitting new wanted
  $d(%%)_aaJg :: () :: Constraint
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9H1
  [W] $d(%,%)_aaJe
    = GHC.Classes.C:(%,%) @[((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                             ~
                             (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                             () :: Constraint),
                            () :: Constraint]
                          [$d(%,%)_aaJf, $d(%%)_aaJg]
Emitting fresh work
  [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint) (CNonCanonical)
  [WD] $d(%%)_aaJg {1}:: () :: Constraint (CNonCanonical)
end stage top-level reactions }
Step 32[l:3,d:0] Top react: Dict/Top (solved wanted):
    [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                              ~
                              (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                              () :: Constraint),
                             () :: Constraint)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                       ~
                                       (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                       () :: Constraint) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                                               "kg" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaJg {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                         ~
                                         (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                         () :: Constraint) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint) (CNonCanonical)
canEvNC:cls
  GHC.Classes.(%,%) [(fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                     ~
                     (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                     () :: Constraint]
flatten_many {
  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  ~
  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  () :: Constraint
Unfilled tyvar fsk_aaJa[fsk]
Unfilled tyvar fsk_aaJa[fsk]
flatten }
  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  ~
  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  () :: Constraint
canClass
  [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint)
  ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
   ~
   (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
   () :: Constraint)
  ContinueWith [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                        ~
                                        (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                        () :: Constraint)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                         ~
                                         (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                         () :: Constraint) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                         ~
                                         (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                         () :: Constraint) (CDictCan(psc))
doTopReact
  [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint) (CDictCan(psc))
matchClassInst
  pred = ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
          ~
          (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
          () :: Constraint) {
} matchClassInst result
  GenInst [(fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
           ~
           (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
           () :: Constraint]
          [safe]
doTopReact/found instance for
  [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint)
updSolvedSetTcs:
  [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint)
Emitting new wanted
  $d~_aaJh :: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
              ~
              (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
Emitting new wanted
  $d(%%)_aaJi :: () :: Constraint
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9H1
  [W] $d(%,%)_aaJf
    = GHC.Classes.C:(%,%) @[(fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint]
                          [$d~_aaJh, $d(%%)_aaJi]
Emitting fresh work
  [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
  [WD] $d(%%)_aaJi {2}:: () :: Constraint (CNonCanonical)
end stage top-level reactions }
Step 33[l:3,d:1] Top react: Dict/Top (solved wanted):
    [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                             ~
                             (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                             () :: Constraint)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                  ~
                                  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                                               "kg" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaJi {2}:: () :: Constraint (CNonCanonical)
                                   [WD] $d(%%)_aaJg {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                    ~
                                    (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~ [Data.Theory.UoM.Unit, fsk0_aaJa[fsk], fsk0_aaJa[fsk]]
flatten_many {
  Data.Theory.UoM.Unit
  fsk0_aaJa[fsk]
  fsk0_aaJa[fsk]
Unfilled tyvar fsk_aaJa[fsk]
Unfilled tyvar fsk_aaJa[fsk]
flatten }
  Data.Theory.UoM.Unit
  fsk0_aaJa[fsk]
  fsk0_aaJa[fsk]
canClass
  [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  ~
  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                   ~
                                   (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                    ~
                                    (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                    ~
                                    (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
         ~
         (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) {
matchClass success
  dict (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
       ~
       (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  witness Data.Type.Equality.$f~kab forall k (a :: k) (b :: k).
                                    (a :: k) ~~ (b :: k) =>
                                    (a :: k) ~ (b :: k)
} matchClassInst result
  GenInst [(fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
           ~~
           (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
Emitting new wanted
  $d~~_aaJj :: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
               ~~
               (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9H1
  [W] $d~_aaJh
    = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, fsk0_aaJa[fsk],
                                  fsk0_aaJa[fsk]]
                                [$d~~_aaJj]
Emitting fresh work
  [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 34[l:3,d:2] Top react: Dict/Top (solved wanted):
    [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                        ~
                        (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                   ~~
                                   (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                                               "kg" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
                        [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                            ~
                                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaJi {2}:: () :: Constraint (CNonCanonical)
                                   [WD] $d(%%)_aaJg {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~~ [Data.Theory.UoM.Unit, Data.Theory.UoM.Unit, fsk0_aaJa[fsk],
      fsk0_aaJa[fsk]]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  fsk0_aaJa[fsk]
  fsk0_aaJa[fsk]
Unfilled tyvar fsk_aaJa[fsk]
Unfilled tyvar fsk_aaJa[fsk]
flatten }
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  fsk0_aaJa[fsk]
  fsk0_aaJa[fsk]
canClass
  [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  ~~
  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                    ~~
                                    (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
         ~~
         (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) {
} matchClassInst result
  GenInst [(fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
           GHC.Prim.~#
           (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
New coercion hole: aaJk
Emitting new coercion hole
  {aaJk} :: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
addTcEvBind
  a9H1
  [W] $d~~_aaJj
    = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                      fsk0_aaJa[fsk], fsk0_aaJa[fsk]]
                    [CO <fsk0_aaJa[fsk]>_N]
Emitting fresh work
  [WD] hole{aaJk} {4}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 35[l:3,d:3] Top react: Dict/Top (solved wanted):
    [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                         ~~
                         (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJk} {4}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                                               "kg" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
                        [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                            ~
                                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaJi {2}:: () :: Constraint (CNonCanonical)
                                   [WD] $d(%%)_aaJg {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJk} {4}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{aaJk} {4}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:eq
  fsk0_aaJa[fsk]
  fsk0_aaJa[fsk]
Filling coercion hole aaJk := <fsk0_aaJa[fsk]>_N
end stage canonicalization }
Step 36[l:3,d:4] Solved by reflexivity:
    [WD] hole{aaJk} {4}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d(%%)_aaJi {2}:: () :: Constraint (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                                               "kg" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
                        [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                            ~
                                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaJg {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d(%%)_aaJi {2}:: () :: Constraint (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d(%%)_aaJi {2}:: () :: Constraint (CNonCanonical)
canEvNC:cls GHC.Classes.(%%) []
flatten_many {
flatten }
canClass
  [WD] $d(%%)_aaJi {2}:: () :: Constraint
  () :: Constraint
  ContinueWith [WD] $d(%%)_aaJi {2}:: () :: Constraint
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d(%%)_aaJi {2}:: () :: Constraint (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d(%%)_aaJi {2}:: () :: Constraint (CDictCan)
doTopReact [WD] $d(%%)_aaJi {2}:: () :: Constraint (CDictCan)
matchClassInst pred = () :: Constraint {
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for
  [WD] $d(%%)_aaJi {2}:: () :: Constraint
updSolvedSetTcs: [WD] $d(%%)_aaJi {2}:: () :: Constraint
addTcEvBind
  a9H1
  [W] $d(%%)_aaJi = GHC.Classes.C:(%%) @[] []
end stage top-level reactions }
Step 37[l:3,d:2] Top react: Dict/Top (solved wanted):
    [WD] $d(%%)_aaJi {2}:: () :: Constraint
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d(%%)_aaJg {1}:: () :: Constraint (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJ9 {0}:: (fsk0_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJb {0}:: (Data.Theory.UoM.Base
                                                               "kg" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJd {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJa[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJc[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaJf {1}:: ((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaJe {0}:: (((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
                        [WD] $d~_aaJh {2}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                            ~
                                            (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJj {3}:: (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                        [WD] $d(%%)_aaJi {2}:: () :: Constraint
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $d(%%)_aaJg {1}:: () :: Constraint (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d(%%)_aaJg {1}:: () :: Constraint (CNonCanonical)
canEvNC:cls GHC.Classes.(%%) []
flatten_many {
flatten }
canClass
  [WD] $d(%%)_aaJg {1}:: () :: Constraint
  () :: Constraint
  ContinueWith [WD] $d(%%)_aaJg {1}:: () :: Constraint
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d(%%)_aaJg {1}:: () :: Constraint (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d(%%)_aaJg {1}:: () :: Constraint (CDictCan)
doTopReact [WD] $d(%%)_aaJg {1}:: () :: Constraint (CDictCan)
addTcEvBind
  a9H1
  [W] $d(%%)_aaJg = $d(%%)_aaJi
end stage top-level reactions }
Step 38[l:3,d:1] Top react: Dict/Top (cached):
    [WD] $d(%%)_aaJg {1}:: () :: Constraint
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  insols = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs =
   Tv eqs =}
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
zonkSimples done: {}
solveSimpleWanteds end }
  iterations = 2
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {[W] irred_a9H3 = irred_a9H0,
                      [W] irred_a9H0
                        = irred_aaJ8 `cast` (Sub
                                               (Sym
                                                  U(hole:{aaJ7}, Data.UnitsOfMeasure.Canonical.IsCanonical
                                                                   s0_aaJ4[fuv:0], s0_aaJ6[fuv:0])_N
                                                ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                     (Trans
                                                          (Sym {aaJ5})
                                                          (Data.UnitsOfMeasure.Syntax.Unpack
                                                             (Sym (Trans
                                                                       (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                                       {aaJ3})))_N))_N)),
                      [G] cobox_aaJ9
                        = CO U(plugin:units, Data.UnitsOfMeasure.Syntax.Unpack
                                               (Data.Theory.UoM.Base "kg"), '["kg"]
                                                                            'Data.UnitsOfMeasure.Syntax.:/ '[])_N,
                      [G] cobox_aaJb = CO <Data.Theory.UoM.Base "kg">_N,
                      [G] cobox_aaJd
                        = CO <Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaJa[fsk]>_N,
                      [W] irred_aaJ8
                        = $d(%,%)_aaJe `cast` (Sub
                                                 (Sym
                                                    (Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                                                       <'["kg"]>_N <'[]>_N
                                                     ; Sym
                                                         (GHC.Classes.(%,%)
                                                            (Sym (Trans
                                                                      (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                                                                           <"kg">_N <'[]>_N)
                                                                      (Sym (GHC.Classes.(%,%)
                                                                              ((~)
                                                                                 <Data.Theory.UoM.Unit>_N
                                                                                 (Sym (Trans
                                                                                           (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                                                           cobox))
                                                                                 (Sym cobox))_N
                                                                              (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)))
                                                            (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)
                                                  ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                       (Trans
                                                            (Trans (Sym cobox) (Sym cobox))
                                                            (Data.UnitsOfMeasure.Syntax.Unpack
                                                               (Sym cobox))_N))_N)),
                      [W] $d(%,%)_aaJe
                        = GHC.Classes.C:(%,%) @[((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint),
                                                () :: Constraint]
                                              [$d(%,%)_aaJf, $d(%%)_aaJg],
                      [W] $d(%,%)_aaJf
                        = GHC.Classes.C:(%,%) @[(fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                ~
                                                (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                () :: Constraint]
                                              [$d~_aaJh, $d(%%)_aaJi],
                      [W] $d~_aaJh
                        = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, fsk0_aaJa[fsk],
                                                      fsk0_aaJa[fsk]]
                                                    [$d~~_aaJj],
                      [W] $d~~_aaJj
                        = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                          fsk0_aaJa[fsk], fsk0_aaJa[fsk]]
                                        [CO <fsk0_aaJa[fsk]>_N],
                      [W] $d(%%)_aaJi = GHC.Classes.C:(%%) @[] [],
                      [W] $d(%%)_aaJg = $d(%%)_aaJi}
getNoGivenEqs
  False
  {Unsolved goals = 0}
  {}
floatEqualities
  Skols = []
  Simples = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus 2
  []
  ([a9H3 :-> [W] irred_a9H3 = irred_a9H0,
    a9H0 :-> [W] irred_a9H0
               = irred_aaJ8 `cast` (Sub
                                      (Sym
                                         U(hole:{aaJ7}, Data.UnitsOfMeasure.Canonical.IsCanonical
                                                          s0_aaJ4[fuv:0], s0_aaJ6[fuv:0])_N
                                       ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                            (Trans
                                                 (Sym {aaJ5})
                                                 (Data.UnitsOfMeasure.Syntax.Unpack
                                                    (Sym (Trans
                                                              (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                              {aaJ3})))_N))_N)),
    aaJ9 :-> [G] cobox_aaJ9
               = CO U(plugin:units, Data.UnitsOfMeasure.Syntax.Unpack
                                      (Data.Theory.UoM.Base "kg"), '["kg"]
                                                                   'Data.UnitsOfMeasure.Syntax.:/ '[])_N,
    aaJb :-> [G] cobox_aaJb = CO <Data.Theory.UoM.Base "kg">_N,
    aaJd :-> [G] cobox_aaJd
               = CO <Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaJa[fsk]>_N,
    aaJ8 :-> [W] irred_aaJ8
               = $d(%,%)_aaJe `cast` (Sub
                                        (Sym
                                           (Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                                              <'["kg"]>_N <'[]>_N
                                            ; Sym
                                                (GHC.Classes.(%,%)
                                                   (Sym (Trans
                                                             (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                                                                  <"kg">_N <'[]>_N)
                                                             (Sym (GHC.Classes.(%,%)
                                                                     ((~)
                                                                        <Data.Theory.UoM.Unit>_N
                                                                        (Sym (Trans
                                                                                  (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                                                  cobox))
                                                                        (Sym cobox))_N
                                                                     (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)))
                                                   (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)
                                         ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                              (Trans
                                                   (Trans (Sym cobox) (Sym cobox))
                                                   (Data.UnitsOfMeasure.Syntax.Unpack
                                                      (Sym cobox))_N))_N)),
    aaJe :-> [W] $d(%,%)_aaJe
               = GHC.Classes.C:(%,%) @[((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                        ~
                                        (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                        () :: Constraint),
                                       () :: Constraint]
                                     [$d(%,%)_aaJf, $d(%%)_aaJg],
    aaJf :-> [W] $d(%,%)_aaJf
               = GHC.Classes.C:(%,%) @[(fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                       ~
                                       (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                       () :: Constraint]
                                     [$d~_aaJh, $d(%%)_aaJi],
    aaJh :-> [W] $d~_aaJh
               = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, fsk0_aaJa[fsk],
                                             fsk0_aaJa[fsk]]
                                           [$d~~_aaJj],
    aaJj :-> [W] $d~~_aaJj
               = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                 fsk0_aaJa[fsk], fsk0_aaJa[fsk]]
                               [CO <fsk0_aaJa[fsk]>_N],
    aaJi :-> [W] $d(%%)_aaJi = GHC.Classes.C:(%%) @[] [],
    aaJg :-> [W] $d(%%)_aaJg = $d(%%)_aaJi],
   [])
  []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {[W] irred_a9H3 = irred_a9H0,
                         [W] irred_a9H0
                           = irred_aaJ8 `cast` (Sub
                                                  (Sym
                                                     U(hole:{aaJ7}, Data.UnitsOfMeasure.Canonical.IsCanonical
                                                                      s0_aaJ4[fuv:0], s0_aaJ6[fuv:0])_N
                                                   ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                        (Trans
                                                             (Sym {aaJ5})
                                                             (Data.UnitsOfMeasure.Syntax.Unpack
                                                                (Sym (Trans
                                                                          (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                                          {aaJ3})))_N))_N)),
                         [G] cobox_aaJ9
                           = CO U(plugin:units, Data.UnitsOfMeasure.Syntax.Unpack
                                                  (Data.Theory.UoM.Base "kg"), '["kg"]
                                                                               'Data.UnitsOfMeasure.Syntax.:/ '[])_N,
                         [G] cobox_aaJb = CO <Data.Theory.UoM.Base "kg">_N,
                         [G] cobox_aaJd
                           = CO <Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaJa[fsk]>_N,
                         [W] irred_aaJ8
                           = $d(%,%)_aaJe `cast` (Sub
                                                    (Sym
                                                       (Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                                                          <'["kg"]>_N <'[]>_N
                                                        ; Sym
                                                            (GHC.Classes.(%,%)
                                                               (Sym (Trans
                                                                         (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                                                                              <"kg">_N <'[]>_N)
                                                                         (Sym (GHC.Classes.(%,%)
                                                                                 ((~)
                                                                                    <Data.Theory.UoM.Unit>_N
                                                                                    (Sym (Trans
                                                                                              (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                                                              cobox))
                                                                                    (Sym cobox))_N
                                                                                 (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)))
                                                               (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)
                                                     ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                          (Trans
                                                               (Trans (Sym cobox) (Sym cobox))
                                                               (Data.UnitsOfMeasure.Syntax.Unpack
                                                                  (Sym cobox))_N))_N)),
                         [W] $d(%,%)_aaJe
                           = GHC.Classes.C:(%,%) @[((fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                    ~
                                                    (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                    () :: Constraint),
                                                   () :: Constraint]
                                                 [$d(%,%)_aaJf, $d(%%)_aaJg],
                         [W] $d(%,%)_aaJf
                           = GHC.Classes.C:(%,%) @[(fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit)
                                                   ~
                                                   (fsk0_aaJa[fsk] :: Data.Theory.UoM.Unit),
                                                   () :: Constraint]
                                                 [$d~_aaJh, $d(%%)_aaJi],
                         [W] $d~_aaJh
                           = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, fsk0_aaJa[fsk],
                                                         fsk0_aaJa[fsk]]
                                                       [$d~~_aaJj],
                         [W] $d~~_aaJj
                           = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                             fsk0_aaJa[fsk], fsk0_aaJa[fsk]]
                                           [CO <fsk0_aaJa[fsk]>_N],
                         [W] $d(%%)_aaJi = GHC.Classes.C:(%%) @[] [],
                         [W] $d(%%)_aaJg = $d(%%)_aaJi}
  implication tvcs = []
solveImplication {
  Implic {
    TcLevel = 3
    Skolems =
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_impl =
            Implic {
              TcLevel = 4
              Skolems = (proxy_a9H6[sk:4] :: GHC.Types.Symbol -> *)
              No-eqs = False
              Status = Unsolved
              Given =
              Wanted =
                WC {wc_simple =
                      [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                               "kg" (CNonCanonical)
                      [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                          ~
                                          ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                 "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)
                      [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                             "kg" :: Data.Theory.UoM.Unit)
                                          ~
                                          (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                             "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)}
              Binds = EvBindsVar<a9He>
              Needed = []
              the type signature for:
                Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                 -> *).
                                                                proxy "kg"
                                                                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                     Rational
                                                                     (Data.Theory.UoM.Base "kg"
                                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                           "kg") }}
    Binds = EvBindsVar<a9Hf>
    Needed = []
    the instance declaration }
  Inerts {Unsolved goals = 0}
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 4
          Skolems = (proxy_a9H6[sk:4] :: GHC.Types.Symbol -> *)
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                           "kg" (CNonCanonical)
                  [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                      ~
                                      ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
                                        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                             "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)
                  [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                         "kg" :: Data.Theory.UoM.Unit)
                                      ~
                                      (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                         "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)}
          Binds = EvBindsVar<a9He>
          Needed = []
          the type signature for:
            Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                             -> *).
                                                            proxy "kg"
                                                            -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                 Rational
                                                                 (Data.Theory.UoM.Base "kg"
                                                                  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                       "kg") }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 4
    Skolems = (proxy_a9H6[sk:4] :: GHC.Types.Symbol -> *)
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                     "kg" (CNonCanonical)
            [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                ~
                                ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
                                  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                       "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)
            [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                   "kg" :: Data.Theory.UoM.Unit)
                                ~
                                (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                   "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)}
    Binds = EvBindsVar<a9He>
    Needed = []
    the type signature for:
      Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                       -> *).
                                                      proxy "kg"
                                                      -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                           Rational
                                                           (Data.Theory.UoM.Base "kg"
                                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                 "kg") }
  Inerts {Unsolved goals = 0}
solveWanteds {
  WC {wc_simple =
        [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                 "kg" (CNonCanonical)
        [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                            ~
                            ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
                              Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                   "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)
        [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                               "kg" :: Data.Theory.UoM.Unit)
                            ~
                            (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                               "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)}
solveSimpleWanteds {
  {[WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                            "kg" (CNonCanonical),
   [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                       ~
                       ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
                         Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                              "kg") :: Data.Theory.UoM.Unit) (CNonCanonical),
   [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                          "kg" :: Data.Theory.UoM.Unit)
                       ~
                       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                  ~
                                  ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
                                    Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                         "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Unsolved goals = 0}
  rest of worklist = WL {Eqs = [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                                      "kg" :: Data.Theory.UoM.Unit)
                                                   ~
                                                   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                      "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "kg" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                    ~
                                    ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                           "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                      ~
                      ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
                        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                             "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~ [Data.Theory.UoM.Unit, Data.Theory.UoM.One,
     Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "kg"]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.One
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                       "kg"
matchFamTcM
  Matching: Data.Theory.UoM.One
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.One
  Match failed
New coercion hole: aaJm
Emitting new coercion hole
  {aaJm} :: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
extendFlatCache
  Data.Theory.UoM.One []
  [WD]
  s0_aaJl[fuv:0]
flatten/flat-cache miss
  Data.Theory.UoM.One []
  s_aaJl[fuv:0]
  [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                 "kg"
  Match failed
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "kg"
    Coercion: UnitDefs.R:CanonicalBaseUnit"kg"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["kg"]
  Data.Theory.UoM.Base "kg"
  UnitDefs.R:CanonicalBaseUnit"kg"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "kg" ~ Data.Theory.UoM.Base "kg"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
New coercion hole: aaJo
Emitting new coercion hole
  {aaJo} :: (Data.Theory.UoM.Base "kg" :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
extendFlatCache
  Data.Theory.UoM.Base ["kg"]
  [WD]
  s0_aaJn[fuv:0]
flatten/flat-cache miss
  Data.Theory.UoM.Base ["kg"]
  s_aaJn[fuv:0]
  [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                           "kg" :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "kg"
    Coercion: UnitDefs.R:CanonicalBaseUnit"kg"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["kg"]
  Data.Theory.UoM.Base "kg"
  UnitDefs.R:CanonicalBaseUnit"kg"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "kg" ~ Data.Theory.UoM.Base "kg"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["kg"]
  s0_aaJn[fuv:0]
Unfilled tyvar s_aaJn[fuv:0]
matchFamTcM
  Matching: s0_aaJn[fuv:0] Data.Theory.UoM./: s0_aaJn[fuv:0]
  Match failed
New coercion hole: aaJq
Emitting new coercion hole
  {aaJq} :: ((s0_aaJn[fuv:0]
              Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
extendFlatCache
  Data.Theory.UoM./: [s0_aaJn[fuv:0], s0_aaJn[fuv:0]]
  [WD]
  s0_aaJp[fuv:0]
flatten/flat-cache miss
  Data.Theory.UoM./: [s0_aaJn[fuv:0], s0_aaJn[fuv:0]]
  s_aaJp[fuv:0]
  [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                          Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
flatten }
  Data.Theory.UoM.Unit
  s0_aaJl[fuv:0]
  s0_aaJp[fuv:0]
Emitting new wanted
  $d~_aaJr :: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
              ~
              (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
  arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9He
  [W] $d~_a9Hc
    = $d~_aaJr `cast` ((~)
                         <Data.Theory.UoM.Unit>_N
                         (Sym {aaJm})
                         (Trans
                              (Sym {aaJq})
                              (Sym (Trans (UnitDefs.R:CanonicalBaseUnit"kg"[0]) {aaJo})
                               Data.Theory.UoM./: Sym (Trans
                                                           (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                           {aaJo}))_N))_R
canClass
  [WD] $d~_a9Hc {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                      ~
                      ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
                        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                             "kg") :: Data.Theory.UoM.Unit)
  (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
  ~
  (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                   ~
                                   (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~
                                    (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~
                                    (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
         ~
         (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) {
matchClass success
  dict (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
       ~
       (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
  witness Data.Type.Equality.$f~kab forall k (a :: k) (b :: k).
                                    (a :: k) ~~ (b :: k) =>
                                    (a :: k) ~ (b :: k)
} matchClassInst result
  GenInst [(s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
           ~~
           (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
Emitting new wanted
  $d~~_aaJs :: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
               ~~
               (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
  arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9He
  [W] $d~_aaJr
    = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJl[fuv:0],
                                  s0_aaJp[fuv:0]]
                                [$d~~_aaJs]
Emitting fresh work
  [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 39[l:4,d:0] Top react: Dict/Top (solved wanted):
    [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                        ~
                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                   ~~
                                   (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Solved dicts [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Eqs = [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                                      "kg" :: Data.Theory.UoM.Unit)
                                                   ~
                                                   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                      "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)
                         Funeqs = [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                                           "kg" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "kg" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~~ [Data.Theory.UoM.Unit, Data.Theory.UoM.Unit, s0_aaJl[fuv:0],
      s0_aaJp[fuv:0]]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  s0_aaJl[fuv:0]
  s0_aaJp[fuv:0]
Unfilled tyvar s_aaJl[fuv:0]
Unfilled tyvar s_aaJp[fuv:0]
flatten }
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  s0_aaJl[fuv:0]
  s0_aaJp[fuv:0]
canClass
  [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
  (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
  ~~
  (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~~
                                    (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
         ~~
         (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) {
} matchClassInst result
  GenInst [(s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
           GHC.Prim.~#
           (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
New coercion hole: aaJt
Emitting new coercion hole
  {aaJt} :: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
addTcEvBind
  a9He
  [W] $d~~_aaJs
    = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                      s0_aaJl[fuv:0], s0_aaJp[fuv:0]]
                    [CO U(hole:{aaJt}, s0_aaJl[fuv:0], s0_aaJp[fuv:0])_N]
Emitting fresh work
  [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 40[l:4,d:1] Top react: Dict/Top (solved wanted):
    [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                         ~~
                         (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Solved dicts [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Eqs = [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                                      "kg" :: Data.Theory.UoM.Unit)
                                                   ~
                                                   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                      "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)
                         Funeqs = [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                                           "kg" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "kg" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:eq
  s0_aaJl[fuv:0]
  s0_aaJp[fuv:0]
can_eq_nc
  False
  [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
  nominal equality
  s0_aaJl[fuv:0]
  s0_aaJl[fuv:0]
  s0_aaJp[fuv:0]
  s0_aaJp[fuv:0]
flatten { FM_FlattenAll s0_aaJl[fuv:0]
Unfilled tyvar s_aaJl[fuv:0]
flatten } s0_aaJl[fuv:0]
flatten { FM_FlattenAll s0_aaJp[fuv:0]
Unfilled tyvar s_aaJp[fuv:0]
flatten } s0_aaJp[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_aaJl[fuv:0] :: Data.Theory.UoM.Unit
      TcLevel of s_aaJl[fuv:0] is 0
  RHS: s0_aaJp[fuv:0] :: Data.Theory.UoM.Unit
addInertEq {
  Adding new inert equality: [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                                   GHC.Prim.~#
                                                   (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 41[l:4,d:2] Kept as inert:
    [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                     "kg" :: Data.Theory.UoM.Unit)
                                  ~
                                  (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                     "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                                           "kg" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "kg" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                                       "kg" :: Data.Theory.UoM.Unit)
                                    ~
                                    (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                       "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                         "kg" :: Data.Theory.UoM.Unit)
                      ~
                      (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                         "kg" :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~ [Data.Theory.UoM.Unit, Data.Theory.UoM.Base "kg",
     Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Base "kg"
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["kg"]
  s0_aaJn[fuv:0]
Unfilled tyvar s_aaJn[fuv:0]
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "kg"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "kg"
    Coercion: UnitDefs.R:CanonicalBaseUnit"kg"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["kg"]
  Data.Theory.UoM.Base "kg"
  UnitDefs.R:CanonicalBaseUnit"kg"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                           "kg" ~ Data.Theory.UoM.Base "kg"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["kg"]
  s0_aaJn[fuv:0]
Unfilled tyvar s_aaJn[fuv:0]
flatten }
  Data.Theory.UoM.Unit
  s0_aaJn[fuv:0]
  s0_aaJn[fuv:0]
Emitting new wanted
  $d~_aaJu :: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
              ~
              (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9He
  [W] $d~_a9Hd
    = $d~_aaJu `cast` ((~)
                         <Data.Theory.UoM.Unit>_N
                         (Sym {aaJo})
                         (Sym (Trans (UnitDefs.R:CanonicalBaseUnit"kg"[0]) {aaJo})))_R
canClass
  [WD] $d~_a9Hd {0}:: (Data.Theory.UoM.Base
                         "kg" :: Data.Theory.UoM.Unit)
                      ~
                      (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                         "kg" :: Data.Theory.UoM.Unit)
  (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  ~
  (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                   ~
                                   (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~
                                    (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~
                                    (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
         ~
         (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) {
matchClass success
  dict (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
       ~
       (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  witness Data.Type.Equality.$f~kab forall k (a :: k) (b :: k).
                                    (a :: k) ~~ (b :: k) =>
                                    (a :: k) ~ (b :: k)
} matchClassInst result
  GenInst [(s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
           ~~
           (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
Emitting new wanted
  $d~~_aaJv :: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
               ~~
               (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9He
  [W] $d~_aaJu
    = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJn[fuv:0],
                                  s0_aaJn[fuv:0]]
                                [$d~~_aaJv]
Emitting fresh work
  [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 42[l:4,d:0] Top react: Dict/Top (solved wanted):
    [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                        ~
                        (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                   ~~
                                   (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                                           "kg" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "kg" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~~ [Data.Theory.UoM.Unit, Data.Theory.UoM.Unit, s0_aaJn[fuv:0],
      s0_aaJn[fuv:0]]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  s0_aaJn[fuv:0]
  s0_aaJn[fuv:0]
Unfilled tyvar s_aaJn[fuv:0]
Unfilled tyvar s_aaJn[fuv:0]
flatten }
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  s0_aaJn[fuv:0]
  s0_aaJn[fuv:0]
canClass
  [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  ~~
  (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~~
                                    (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
         ~~
         (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) {
} matchClassInst result
  GenInst [(s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
           GHC.Prim.~#
           (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
New coercion hole: aaJw
Emitting new coercion hole
  {aaJw} :: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
addTcEvBind
  a9He
  [W] $d~~_aaJv
    = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                      s0_aaJn[fuv:0], s0_aaJn[fuv:0]]
                    [CO <s0_aaJn[fuv:0]>_N]
Emitting fresh work
  [WD] hole{aaJw} {2}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 43[l:4,d:1] Top react: Dict/Top (solved wanted):
    [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                         ~~
                         (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJw} {2}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                                           "kg" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "kg" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJw} {2}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{aaJw} {2}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:eq
  s0_aaJn[fuv:0]
  s0_aaJn[fuv:0]
Filling coercion hole aaJw := <s0_aaJn[fuv:0]>_N
end stage canonicalization }
Step 44[l:4,d:2] Solved by reflexivity:
    [WD] hole{aaJw} {2}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                                           "kg" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "kg" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many {
flatten }
extendFlatCache
  Data.Theory.UoM.One []
  [WD]
  s0_aaJl[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: Data.Theory.UoM.One
  Match failed
improveTopFunEqs
  Data.Theory.UoM.One [] s_aaJl[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                                GHC.Prim.~#
                                                                (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 45[l:4,d:0] Kept as inert:
    [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                       "kg" :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "kg" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                         "kg" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many { "kg"
flatten } "kg"
extendFlatCache
  Data.Theory.UoM.Base ["kg"]
  [WD]
  s0_aaJn[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                         "kg" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                         "kg" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                           "kg" :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: Data.Theory.UoM.Base "kg"
  Match failed
improveTopFunEqs
  Data.Theory.UoM.Base ["kg"] s_aaJn[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                                                   "kg" :: Data.Theory.UoM.Unit)
                                                                GHC.Prim.~#
                                                                (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 46[l:4,d:1] Kept as inert:
    [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                             "kg" :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                        "kg" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                      Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                                                "kg" :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "kg" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                        Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many {
  s0_aaJn[fuv:0]
  s0_aaJn[fuv:0]
Unfilled tyvar s_aaJn[fuv:0]
Unfilled tyvar s_aaJn[fuv:0]
flatten }
  s0_aaJn[fuv:0]
  s0_aaJn[fuv:0]
extendFlatCache
  Data.Theory.UoM./: [s0_aaJn[fuv:0], s0_aaJn[fuv:0]]
  [WD]
  s0_aaJp[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                        Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                        Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                          Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_aaJn[fuv:0] Data.Theory.UoM./: s0_aaJn[fuv:0]
  Match failed
improveTopFunEqs
  Data.Theory.UoM./: [s0_aaJn[fuv:0], s0_aaJn[fuv:0]] s_aaJp[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                                                  Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                                                GHC.Prim.~#
                                                                (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 47[l:4,d:0] Kept as inert:
    [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                            Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                       Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                       "kg" (CNonCanonical)
  inerts = {Equalities: [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                                                "kg" :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                                               Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaJr {0}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJu {0}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJs {1}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJv {1}:: (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                         "kg" (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "kg" (CNonCanonical)
canEvNC:cls
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit ["kg"]
flatten_many { "kg"
flatten } "kg"
canClass
  [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "kg"
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
  ContinueWith [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                        "kg"
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                         "kg" (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                         "kg" (CDictCan(psc))
doTopReact
  [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "kg" (CDictCan(psc))
matchClassInst
  pred = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg" {
matchClass success
  dict Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "kg"
  witness UnitDefs.$fHasCanonicalBaseUnit"kg" Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                "kg"
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for
  [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "kg"
updSolvedSetTcs:
  [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "kg"
addTcEvBind
  a9He
  [W] $dHasCanonicalBaseUnit_a9Ha
    = UnitDefs.$fHasCanonicalBaseUnit"kg" @[] []
end stage top-level reactions }
Step 48[l:4,d:0] Top react: Dict/Top (solved wanted):
    [WD] $dHasCanonicalBaseUnit_a9Ha {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                             "kg"
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {[WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)}
  fun eqs = {[WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan),
             [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                      "kg" :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan),
             [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                     Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)}
  insols = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{aaJm} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            [WD] hole{aaJo} {1}:: (Data.Theory.UoM.Base
                                     "kg" :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s0_aaJn[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            [WD] hole{aaJq} {0}:: ((s0_aaJn[fuv:0]
                                    Data.Theory.UoM./: s0_aaJn[fuv:0]) :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
   Tv eqs = [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)}
Filling coercion hole
  aaJq := <s0_aaJn[fuv:0] Data.Theory.UoM./: s0_aaJn[fuv:0]>_N
unflattenFmv
  s_aaJp[fuv:0] := s0_aaJn[fuv:0] Data.Theory.UoM./: s0_aaJn[fuv:0]
writeMetaTyVar
  s_aaJp[fuv:0] :: Data.Theory.UoM.Unit := s0_aaJn[fuv:0]
                                           Data.Theory.UoM./: s0_aaJn[fuv:0]
Filling coercion hole aaJo := <Data.Theory.UoM.Base "kg">_N
unflattenFmv s_aaJn[fuv:0] := Data.Theory.UoM.Base "kg"
writeMetaTyVar
  s_aaJn[fuv:0] :: Data.Theory.UoM.Unit := Data.Theory.UoM.Base "kg"
Filling coercion hole aaJm := <Data.Theory.UoM.One>_N
unflattenFmv s_aaJl[fuv:0] := Data.Theory.UoM.One
writeMetaTyVar
  s_aaJl[fuv:0] :: Data.Theory.UoM.Unit := Data.Theory.UoM.One
Unflattening 1 {}
unflatten_eq 2
  [WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
Unflattening 2
  {[WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)}
Unflattening 3 {}
Unflattening done
  {[WD] hole{aaJt} {2}:: (s0_aaJl[fuv:0] :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         (s1_aaJp[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)}
zonkSimples done:
  {[WD] hole{aaJt} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         ((Data.Theory.UoM.Base "kg"
                           Data.Theory.UoM./: Data.Theory.UoM.Base
                                                "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)}
zonkSimples done:
  {[WD] hole{aaJt} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         ((Data.Theory.UoM.Base "kg"
                           Data.Theory.UoM./: Data.Theory.UoM.Base
                                                "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)}
tcPluginSolve start thoralf-uom-plugin
  given   = []
  derived = []
  wanted  = [[WD] hole{aaJt} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   ((Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.Theory.UoM.Base
                                                          "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)]
thoralf-solve gsConvCts Just [ ] [] []
thoralf-solve wsConvCts
  Just [ (= ((as const (Array String Int)) 0) ((_ map (- (Int Int) Int)) (store base "kg" n1) (store base "kg" n1))) ] [[WD] hole{aaJt} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                                                                                                              GHC.Prim.~#
                                                                                                                                              ((Data.Theory.UoM.Base
                                                                                                                                                  "kg"
                                                                                                                                                Data.Theory.UoM./: Data.Theory.UoM.Base
                                                                                                                                                                     "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)] []
thoralf-solve decls []
thoralf-solve decls filtered []
thoralf-solve givens []
thoralf-solve givens filtered []
thoralf-solve wanteds
  [[WD] hole{aaJt} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         ((Data.Theory.UoM.Base "kg"
                           Data.Theory.UoM./: Data.Theory.UoM.Base
                                                "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)]
thoralf-solve wanteds filtered
  [[WD] hole{aaJt} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         ((Data.Theory.UoM.Base "kg"
                           Data.Theory.UoM./: Data.Theory.UoM.Base
                                                "kg") :: Data.Theory.UoM.Unit) (CNonCanonical)]
thoralf-solve simplified given sexprs []
thoralf-solve simplified wanteds
  [(CO U(plugin:thoralf, Data.Theory.UoM.One, Data.Theory.UoM.Base
                                                "kg"
                                              Data.Theory.UoM./: Data.Theory.UoM.Base "kg")_N,
    [WD] hole{aaJt} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          ((Data.Theory.UoM.Base "kg"
                            Data.Theory.UoM./: Data.Theory.UoM.Base
                                                 "kg") :: Data.Theory.UoM.Unit) (CNonCanonical))]
tcPluginSolve ok thoralf-uom-plugin
  solved = [(CO U(plugin:thoralf, Data.Theory.UoM.One, Data.Theory.UoM.Base
                                                         "kg"
                                                       Data.Theory.UoM./: Data.Theory.UoM.Base
                                                                            "kg")_N,
             [WD] hole{aaJt} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   ((Data.Theory.UoM.Base "kg"
                                     Data.Theory.UoM./: Data.Theory.UoM.Base
                                                          "kg") :: Data.Theory.UoM.Unit) (CNonCanonical))]
  new    = []
tcPluginSolve start uom-eq-plugin
  given   = []
  derived = []
  wanted  = []
tcPluginSolve ok uom-eq-plugin
  solved = []
  new    = []
tcPluginSolve start uom-unpack-plugin
  given   = []
  derived = []
  wanted  = []
tcPluginSolve ok uom-unpack-plugin
  solved = []
  new    = []
Filling coercion hole
  aaJt := U(plugin:thoralf, Data.Theory.UoM.One, Data.Theory.UoM.Base
                                                   "kg"
                                                 Data.Theory.UoM./: Data.Theory.UoM.Base "kg")_N
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {[W] $d~_a9Hc
                        = $d~_aaJr `cast` ((~)
                                             <Data.Theory.UoM.Unit>_N
                                             (Sym {aaJm})
                                             (Trans
                                                  (Sym {aaJq})
                                                  (Sym (Trans
                                                            (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                            {aaJo})
                                                   Data.Theory.UoM./: Sym (Trans
                                                                               (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                                               {aaJo}))_N))_R,
                      [W] $d~_aaJr
                        = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJl[fuv:0],
                                                      s0_aaJp[fuv:0]]
                                                    [$d~~_aaJs],
                      [W] $d~~_aaJs
                        = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                          s0_aaJl[fuv:0], s0_aaJp[fuv:0]]
                                        [CO U(hole:{aaJt}, s0_aaJl[fuv:0], s0_aaJp[fuv:0])_N],
                      [W] $d~_a9Hd
                        = $d~_aaJu `cast` ((~)
                                             <Data.Theory.UoM.Unit>_N
                                             (Sym {aaJo})
                                             (Sym (Trans
                                                       (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                       {aaJo})))_R,
                      [W] $d~_aaJu
                        = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJn[fuv:0],
                                                      s0_aaJn[fuv:0]]
                                                    [$d~~_aaJv],
                      [W] $d~~_aaJv
                        = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                          s0_aaJn[fuv:0], s0_aaJn[fuv:0]]
                                        [CO <s0_aaJn[fuv:0]>_N],
                      [W] $dHasCanonicalBaseUnit_a9Ha
                        = UnitDefs.$fHasCanonicalBaseUnit"kg" @[] []}
getNoGivenEqs
  False
  {Unsolved goals = 0}
  {}
floatEqualities
  Skols = [proxy_a9H6[sk:4]]
  Simples = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus 2
  []
  ([a9Hc :-> [W] $d~_a9Hc
               = $d~_aaJr `cast` ((~)
                                    <Data.Theory.UoM.Unit>_N
                                    (Sym {aaJm})
                                    (Trans
                                         (Sym {aaJq})
                                         (Sym (Trans (UnitDefs.R:CanonicalBaseUnit"kg"[0]) {aaJo})
                                          Data.Theory.UoM./: Sym (Trans
                                                                      (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                                      {aaJo}))_N))_R,
    aaJr :-> [W] $d~_aaJr
               = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJl[fuv:0],
                                             s0_aaJp[fuv:0]]
                                           [$d~~_aaJs],
    aaJs :-> [W] $d~~_aaJs
               = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                 s0_aaJl[fuv:0], s0_aaJp[fuv:0]]
                               [CO U(hole:{aaJt}, s0_aaJl[fuv:0], s0_aaJp[fuv:0])_N],
    a9Hd :-> [W] $d~_a9Hd
               = $d~_aaJu `cast` ((~)
                                    <Data.Theory.UoM.Unit>_N
                                    (Sym {aaJo})
                                    (Sym (Trans (UnitDefs.R:CanonicalBaseUnit"kg"[0]) {aaJo})))_R,
    aaJu :-> [W] $d~_aaJu
               = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJn[fuv:0],
                                             s0_aaJn[fuv:0]]
                                           [$d~~_aaJv],
    aaJv :-> [W] $d~~_aaJv
               = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                 s0_aaJn[fuv:0], s0_aaJn[fuv:0]]
                               [CO <s0_aaJn[fuv:0]>_N],
    a9Ha :-> [W] $dHasCanonicalBaseUnit_a9Ha
               = UnitDefs.$fHasCanonicalBaseUnit"kg" @[] []],
   [])
  []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {[W] $d~_a9Hc
                           = $d~_aaJr `cast` ((~)
                                                <Data.Theory.UoM.Unit>_N
                                                (Sym {aaJm})
                                                (Trans
                                                     (Sym {aaJq})
                                                     (Sym (Trans
                                                               (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                               {aaJo})
                                                      Data.Theory.UoM./: Sym (Trans
                                                                                  (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                                                  {aaJo}))_N))_R,
                         [W] $d~_aaJr
                           = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJl[fuv:0],
                                                         s0_aaJp[fuv:0]]
                                                       [$d~~_aaJs],
                         [W] $d~~_aaJs
                           = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                             s0_aaJl[fuv:0], s0_aaJp[fuv:0]]
                                           [CO U(hole:{aaJt}, s0_aaJl[fuv:0], s0_aaJp[fuv:0])_N],
                         [W] $d~_a9Hd
                           = $d~_aaJu `cast` ((~)
                                                <Data.Theory.UoM.Unit>_N
                                                (Sym {aaJo})
                                                (Sym (Trans
                                                          (UnitDefs.R:CanonicalBaseUnit"kg"[0])
                                                          {aaJo})))_R,
                         [W] $d~_aaJu
                           = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJn[fuv:0],
                                                         s0_aaJn[fuv:0]]
                                                       [$d~~_aaJv],
                         [W] $d~~_aaJv
                           = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                             s0_aaJn[fuv:0], s0_aaJn[fuv:0]]
                                           [CO <s0_aaJn[fuv:0]>_N],
                         [W] $dHasCanonicalBaseUnit_a9Ha
                           = UnitDefs.$fHasCanonicalBaseUnit"kg" @[] []}
  implication tvcs = []
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Nothing}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
getNoGivenEqs
  False
  {Unsolved goals = 0}
  {}
floatEqualities
  Skols = []
  Simples = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus 2
  []
  ([], [])
  []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {}
  implication tvcs = []
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Nothing, Nothing}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
getNoGivenEqs
  False
  {Unsolved goals = 0}
  {}
floatEqualities
  Skols = []
  Simples = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus 2
  []
  ([], [])
  []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {}
  implication tvcs = []
solveImplication {
  Implic {
    TcLevel = 2
    Skolems =
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_impl =
            Implic {
              TcLevel = 3
              Skolems =
              No-eqs = False
              Status = Unsolved
              Given =
              Wanted =
                WC {wc_simple =
                      [WD] irred_a9Hi {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                              (Data.UnitsOfMeasure.Syntax.Unpack
                                                 (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                    "m")) (CNonCanonical)}
              Binds = EvBindsVar<a9Hj>
              Needed = []
              the instance declaration }
            Implic {
              TcLevel = 3
              Skolems =
              No-eqs = False
              Status = Unsolved
              Given =
              Wanted =
                WC {wc_impl =
                      Implic {
                        TcLevel = 4
                        Skolems = (proxy_a9Ho[sk:4] :: GHC.Types.Symbol -> *)
                        No-eqs = False
                        Status = Unsolved
                        Given =
                        Wanted =
                          WC {wc_simple =
                                [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                         "m" (CNonCanonical)
                                [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                    ~
                                                    ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                        "m"
                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                           "m") :: Data.Theory.UoM.Unit) (CNonCanonical)
                                [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                                       "m" :: Data.Theory.UoM.Unit)
                                                    ~
                                                    (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                       "m" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                        Binds = EvBindsVar<a9Hw>
                        Needed = []
                        the type signature for:
                          Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                           -> *).
                                                                          proxy "m"
                                                                          -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                               Rational
                                                                               (Data.Theory.UoM.Base
                                                                                  "m"
                                                                                Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                     "m") }}
              Binds = EvBindsVar<a9Hx>
              Needed = []
              the instance declaration }}
    Binds = EvBindsVar<a9Hh>
    Needed = []
    the instance declaration }
  Inerts {Unsolved goals = 0}
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 3
          Skolems =
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] irred_a9Hi {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                          (Data.UnitsOfMeasure.Syntax.Unpack
                                             (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                "m")) (CNonCanonical)}
          Binds = EvBindsVar<a9Hj>
          Needed = []
          the instance declaration }
        Implic {
          TcLevel = 3
          Skolems =
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_impl =
                  Implic {
                    TcLevel = 4
                    Skolems = (proxy_a9Ho[sk:4] :: GHC.Types.Symbol -> *)
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                     "m" (CNonCanonical)
                            [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                ~
                                                ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                    "m"
                                                  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                       "m") :: Data.Theory.UoM.Unit) (CNonCanonical)
                            [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                                   "m" :: Data.Theory.UoM.Unit)
                                                ~
                                                (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                   "m" :: Data.Theory.UoM.Unit) (CNonCanonical)}
                    Binds = EvBindsVar<a9Hw>
                    Needed = []
                    the type signature for:
                      Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                       -> *).
                                                                      proxy "m"
                                                                      -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                           Rational
                                                                           (Data.Theory.UoM.Base "m"
                                                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                                 "m") }}
          Binds = EvBindsVar<a9Hx>
          Needed = []
          the instance declaration }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 3
    Skolems =
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] irred_a9Hi {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                    (Data.UnitsOfMeasure.Syntax.Unpack
                                       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "m")) (CNonCanonical)}
    Binds = EvBindsVar<a9Hj>
    Needed = []
    the instance declaration }
  Inerts {Unsolved goals = 0}
solveWanteds {
  WC {wc_simple =
        [WD] irred_a9Hi {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                (Data.UnitsOfMeasure.Syntax.Unpack
                                   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                      "m")) (CNonCanonical)}
solveSimpleWanteds {
  {[WD] irred_a9Hi {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                           (Data.UnitsOfMeasure.Syntax.Unpack
                              (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                 "m")) (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_a9Hi {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                      (Data.UnitsOfMeasure.Syntax.Unpack
                                         (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                            "m")) (CNonCanonical)
  inerts = {Unsolved goals = 0}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] irred_a9Hi {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                        (Data.UnitsOfMeasure.Syntax.Unpack
                                           (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                              "m")) (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_a9Hi {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                          (Data.UnitsOfMeasure.Syntax.Unpack
                             (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                "m")) (CNonCanonical)
canEvNC:irred
  Data.UnitsOfMeasure.Canonical.IsCanonical
    (Data.UnitsOfMeasure.Syntax.Unpack
       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"))
can_pred
  IrredPred =  Data.UnitsOfMeasure.Canonical.IsCanonical
                 (Data.UnitsOfMeasure.Syntax.Unpack
                    (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"))
flatten {
  FM_FlattenAll Data.UnitsOfMeasure.Canonical.IsCanonical
                  (Data.UnitsOfMeasure.Syntax.Unpack
                     (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"))
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical
              (Data.UnitsOfMeasure.Syntax.Unpack
                 (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"))
  Match failed
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack
              (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m")
  Match failed
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "m"
    Coercion: UnitDefs.R:CanonicalBaseUnit"m"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["m"]
  Data.Theory.UoM.Base "m"
  UnitDefs.R:CanonicalBaseUnit"m"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "m" ~ Data.Theory.UoM.Base "m"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
New coercion hole: aaJy
Emitting new coercion hole
  {aaJy} :: (Data.Theory.UoM.Base "m" :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit)
extendFlatCache
  Data.Theory.UoM.Base ["m"]
  [WD]
  s0_aaJx[fuv:0]
flatten/flat-cache miss
  Data.Theory.UoM.Base ["m"]
  s_aaJx[fuv:0]
  [WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                           "m" :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack s0_aaJx[fuv:0]
  Match failed
New coercion hole: aaJA
Emitting new coercion hole
  {aaJA} :: (Data.UnitsOfMeasure.Syntax.Unpack
               s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                   GHC.Types.Symbol)
            GHC.Prim.~#
            (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                 GHC.Types.Symbol)
extendFlatCache
  Data.UnitsOfMeasure.Syntax.Unpack [s0_aaJx[fuv:0]]
  [WD]
  s0_aaJz[fuv:0]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Syntax.Unpack [s0_aaJx[fuv:0]]
  s_aaJz[fuv:0]
  [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                           s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
                        GHC.Prim.~#
                        (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                             GHC.Types.Symbol)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical s0_aaJz[fuv:0]
  Match failed
New coercion hole: aaJC
Emitting new coercion hole
  {aaJC} :: (Data.UnitsOfMeasure.Canonical.IsCanonical
               s0_aaJz[fuv:0] :: Constraint)
            GHC.Prim.~#
            (s1_aaJB[fuv:0] :: Constraint)
extendFlatCache
  Data.UnitsOfMeasure.Canonical.IsCanonical [s0_aaJz[fuv:0]]
  [WD]
  s0_aaJB[fuv:0]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Canonical.IsCanonical [s0_aaJz[fuv:0]]
  s_aaJB[fuv:0]
  [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                           s0_aaJz[fuv:0] :: Constraint)
                        GHC.Prim.~#
                        (s1_aaJB[fuv:0] :: Constraint)
flatten } s0_aaJB[fuv:0]
Emitting new wanted
  irred_aaJD :: s0_aaJB[fuv:0]
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9Hj
  [W] irred_a9Hi
    = irred_aaJD `cast` (Sub
                           (Sym
                              U(hole:{aaJC}, Data.UnitsOfMeasure.Canonical.IsCanonical
                                               s0_aaJz[fuv:0], s0_aaJB[fuv:0])_N
                            ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                 (Trans
                                      (Sym {aaJA})
                                      (Data.UnitsOfMeasure.Syntax.Unpack
                                         (Sym (Trans
                                                   (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                   {aaJy})))_N))_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_aaJD {0}:: s0_aaJB[fuv:0] (CIrredEvCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] irred_aaJD {0}:: s0_aaJB[fuv:0] (CIrredEvCan)
doTopReact [WD] irred_aaJD {0}:: s0_aaJB[fuv:0] (CIrredEvCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] irred_aaJD {0}:: s0_aaJB[fuv:0] (CIrredEvCan)
addInertCan }
Step 49[l:3,d:0] Kept as inert:
    [WD] irred_aaJD {0}:: s0_aaJB[fuv:0]
End solver pipeline (kept as inert) }
  final_item = [WD] irred_aaJD {0}:: s0_aaJB[fuv:0] (CIrredEvCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                                       "m" :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Irreds = [WD] irred_aaJD {0}:: s0_aaJB[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                           s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                        GHC.Prim.~#
                                                        (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                             GHC.Types.Symbol) (CFunEqCan)
                                  [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           s0_aaJz[fuv:0] :: Constraint)
                                                        GHC.Prim.~#
                                                        (s1_aaJB[fuv:0] :: Constraint) (CFunEqCan)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                                         "m" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many { "m"
flatten } "m"
extendFlatCache
  Data.Theory.UoM.Base ["m"]
  [WD]
  s0_aaJx[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                                         "m" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                                         "m" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                           "m" :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
improveTopFunEqs
  Data.Theory.UoM.Base ["m"] s_aaJx[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                                                                   "m" :: Data.Theory.UoM.Unit)
                                                                GHC.Prim.~#
                                                                (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 50[l:3,d:1] Kept as inert:
    [WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                             "m" :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                                        "m" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                       s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                                    GHC.Prim.~#
                                    (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                                                                "m" :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Irreds = [WD] irred_aaJD {0}:: s0_aaJB[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           s0_aaJz[fuv:0] :: Constraint)
                                                        GHC.Prim.~#
                                                        (s1_aaJB[fuv:0] :: Constraint) (CFunEqCan)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                         s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
flatten_many { s0_aaJx[fuv:0]
Unfilled tyvar s_aaJx[fuv:0]
flatten } s0_aaJx[fuv:0]
extendFlatCache
  Data.UnitsOfMeasure.Syntax.Unpack [s0_aaJx[fuv:0]]
  [WD]
  s0_aaJz[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                         s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                         s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
doTopReact
  [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                           s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
                        GHC.Prim.~#
                        (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                             GHC.Types.Symbol) (CFunEqCan)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack s0_aaJx[fuv:0]
  Match failed
improveTopFunEqs
  Data.UnitsOfMeasure.Syntax.Unpack [s0_aaJx[fuv:0]] s_aaJz[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                                   s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                       GHC.Types.Symbol)
                                                                GHC.Prim.~#
                                                                (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                     GHC.Types.Symbol) (CFunEqCan)
addInertCan }
Step 51[l:3,d:0] Kept as inert:
    [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                             s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                 GHC.Types.Symbol)
                          GHC.Prim.~#
                          (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                       s0_aaJz[fuv:0] :: Constraint)
                                    GHC.Prim.~#
                                    (s1_aaJB[fuv:0] :: Constraint) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                                                                "m" :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                                s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Irreds = [WD] irred_aaJD {0}:: s0_aaJB[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                         s0_aaJz[fuv:0] :: Constraint)
                                      GHC.Prim.~#
                                      (s1_aaJB[fuv:0] :: Constraint) (CFunEqCan)
flatten_many { s0_aaJz[fuv:0]
Unfilled tyvar s_aaJz[fuv:0]
flatten } s0_aaJz[fuv:0]
extendFlatCache
  Data.UnitsOfMeasure.Canonical.IsCanonical [s0_aaJz[fuv:0]]
  [WD]
  s0_aaJB[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                         s0_aaJz[fuv:0] :: Constraint)
                                      GHC.Prim.~#
                                      (s1_aaJB[fuv:0] :: Constraint) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                         s0_aaJz[fuv:0] :: Constraint)
                                      GHC.Prim.~#
                                      (s1_aaJB[fuv:0] :: Constraint) (CFunEqCan)
doTopReact
  [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                           s0_aaJz[fuv:0] :: Constraint)
                        GHC.Prim.~#
                        (s1_aaJB[fuv:0] :: Constraint) (CFunEqCan)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical s0_aaJz[fuv:0]
  Match failed
improveTopFunEqs
  Data.UnitsOfMeasure.Canonical.IsCanonical [s0_aaJz[fuv:0]] s_aaJB[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                                   s0_aaJz[fuv:0] :: Constraint)
                                                                GHC.Prim.~#
                                                                (s1_aaJB[fuv:0] :: Constraint) (CFunEqCan)
addInertCan }
Step 52[l:3,d:0] Kept as inert:
    [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                             s0_aaJz[fuv:0] :: Constraint)
                          GHC.Prim.~#
                          (s1_aaJB[fuv:0] :: Constraint)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                        s0_aaJz[fuv:0] :: Constraint)
                                     GHC.Prim.~#
                                     (s1_aaJB[fuv:0] :: Constraint) (CFunEqCan)
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {[WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                                      "m" :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan),
             [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                      s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                        GHC.Types.Symbol) (CFunEqCan),
             [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                      s0_aaJz[fuv:0] :: Constraint)
                                   GHC.Prim.~#
                                   (s1_aaJB[fuv:0] :: Constraint) (CFunEqCan)}
  insols = {}
  others = {[WD] irred_aaJD {0}:: s0_aaJB[fuv:0] (CIrredEvCan)}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{aaJy} {1}:: (Data.Theory.UoM.Base
                                     "m" :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s0_aaJx[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            [WD] hole{aaJA} {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                     s0_aaJx[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol)
                                  GHC.Prim.~#
                                  (s1_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                       GHC.Types.Symbol) (CFunEqCan)
            [WD] hole{aaJC} {0}:: (Data.UnitsOfMeasure.Canonical.IsCanonical
                                     s0_aaJz[fuv:0] :: Constraint)
                                  GHC.Prim.~#
                                  (s1_aaJB[fuv:0] :: Constraint) (CFunEqCan)
   Tv eqs =}
Filling coercion hole
  aaJC := <Data.UnitsOfMeasure.Canonical.IsCanonical
             s0_aaJz[fuv:0]>_N
unflattenFmv
  s_aaJB[fuv:0] := Data.UnitsOfMeasure.Canonical.IsCanonical
                     s0_aaJz[fuv:0]
writeMetaTyVar
  s_aaJB[fuv:0] :: Constraint := Data.UnitsOfMeasure.Canonical.IsCanonical
                                   s0_aaJz[fuv:0]
Filling coercion hole
  aaJA := <Data.UnitsOfMeasure.Syntax.Unpack s0_aaJx[fuv:0]>_N
unflattenFmv
  s_aaJz[fuv:0] := Data.UnitsOfMeasure.Syntax.Unpack s0_aaJx[fuv:0]
writeMetaTyVar
  s_aaJz[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                     GHC.Types.Symbol := Data.UnitsOfMeasure.Syntax.Unpack
                                           s0_aaJx[fuv:0]
Filling coercion hole aaJy := <Data.Theory.UoM.Base "m">_N
unflattenFmv s_aaJx[fuv:0] := Data.Theory.UoM.Base "m"
writeMetaTyVar
  s_aaJx[fuv:0] :: Data.Theory.UoM.Unit := Data.Theory.UoM.Base "m"
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
zonkSimples done: {}
zonkSimples done:
  {[WD] irred_aaJD {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                           (Data.UnitsOfMeasure.Syntax.Unpack
                              (Data.Theory.UoM.Base "m")) (CNonCanonical)}
tcPluginSolve start thoralf-uom-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_aaJD {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                     (Data.UnitsOfMeasure.Syntax.Unpack
                                        (Data.Theory.UoM.Base "m")) (CNonCanonical)]
thoralf-solve gsConvCts Just [ ] [] []
thoralf-solve wsConvCts Just [ ] [] []
thoralf-solve decls []
thoralf-solve decls filtered []
thoralf-solve givens []
thoralf-solve givens filtered []
thoralf-solve wanteds
  [[WD] irred_aaJD {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                           (Data.UnitsOfMeasure.Syntax.Unpack
                              (Data.Theory.UoM.Base "m")) (CNonCanonical)]
thoralf-solve wanteds filtered
  [[WD] irred_aaJD {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                           (Data.UnitsOfMeasure.Syntax.Unpack
                              (Data.Theory.UoM.Base "m")) (CNonCanonical)]
thoralf-solve simplified given sexprs []
thoralf-solve simplified wanteds []
tcPluginSolve ok thoralf-uom-plugin
  solved = []
  new    = []
tcPluginSolve start uom-eq-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_aaJD {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                     (Data.UnitsOfMeasure.Syntax.Unpack
                                        (Data.Theory.UoM.Base "m")) (CNonCanonical)]
tcPluginSolve ok uom-eq-plugin
  solved = []
  new    = []
tcPluginSolve start uom-unpack-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_aaJD {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                     (Data.UnitsOfMeasure.Syntax.Unpack
                                        (Data.Theory.UoM.Base "m")) (CNonCanonical)]
addTcEvBind
  a9Hj
  [G] cobox_aaJE
    = CO U(plugin:units, Data.UnitsOfMeasure.Syntax.Unpack
                           (Data.Theory.UoM.Base "m"), '["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '[])_N
tcPluginSolve ok uom-unpack-plugin
  solved = []
  new    = [[G] cobox_aaJE {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                    (Data.Theory.UoM.Base
                                       "m") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                 GHC.Types.Symbol)
                                 GHC.Prim.~#
                                 (('["m"]
                                   'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CNonCanonical)]
solveSimple going round again:
  0
  True
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_aaJE {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                      (Data.Theory.UoM.Base
                                         "m") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                   GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (('["m"]
                                     'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol) (CNonCanonical)
  inerts = {Unsolved goals = 0}
  rest of worklist = WL {Non-eqs = [WD] irred_aaJD {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           (Data.UnitsOfMeasure.Syntax.Unpack
                                                              (Data.Theory.UoM.Base
                                                                 "m")) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [G] cobox_aaJE {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        (Data.Theory.UoM.Base
                                           "m") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                     GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (('["m"]
                                       'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                GHC.Types.Symbol) (CNonCanonical)
canonicalize (non-canonical)
  [G] cobox_aaJE {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                          (Data.Theory.UoM.Base "m") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["m"]
                         'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol) (CNonCanonical)
canEvNC:eq
  Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "m")
  '["m"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
can_eq_nc
  False
  [G] cobox_aaJE {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                          (Data.Theory.UoM.Base "m") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["m"]
                         'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
  nominal equality
  Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "m")
  Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "m")
  '["m"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
  '["m"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
flatten {
  FM_FlattenAll Data.UnitsOfMeasure.Syntax.Unpack
                  (Data.Theory.UoM.Base "m")
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack
              (Data.Theory.UoM.Base "m")
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
addTcEvBind
  a9Hj
  [G] cobox_aaJG = CO <Data.Theory.UoM.Base "m">_N
extendFlatCache
  Data.Theory.UoM.Base ["m"]
  [G]
  fsk0_aaJF[fsk]
flatten/flat-cache miss
  Data.Theory.UoM.Base ["m"]
  fsk_aaJF[fsk]
  [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                          "m" :: Data.Theory.UoM.Unit)
                       GHC.Prim.~#
                       (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaJF[fsk]
  Match failed
addTcEvBind
  a9Hj
  [G] cobox_aaJI
    = CO <Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaJF[fsk]>_N
extendFlatCache
  Data.UnitsOfMeasure.Syntax.Unpack [fsk0_aaJF[fsk]]
  [G]
  fsk0_aaJH[fsk]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Syntax.Unpack [fsk0_aaJF[fsk]]
  fsk_aaJH[fsk]
  [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                          fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                       GHC.Prim.~#
                       (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol)
flatten } fsk0_aaJH[fsk]
flatten { FM_FlattenAll '["m"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
flatten } '["m"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (('["m"]
                                       'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                GHC.Types.Symbol) (CTyEqCan)
Can't solve tyvar equality
  LHS: fsk_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                          GHC.Types.Symbol
  RHS: '["m"]
       'Data.UnitsOfMeasure.Syntax.:/ '[] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol
addInertEq {
  Adding new inert equality: [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                       GHC.Types.Symbol)
                                                  GHC.Prim.~#
                                                  (('["m"]
                                                    'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                             GHC.Types.Symbol) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 53[l:3,d:0] Kept as inert:
    [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                         GHC.Prim.~#
                         (('["m"]
                           'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                    GHC.Types.Symbol)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                      "m" :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Equalities: [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Unsolved goals = 0}
  rest of worklist = WL {Funeqs = [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                          fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CFunEqCan)
                         Non-eqs = [WD] irred_aaJD {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           (Data.UnitsOfMeasure.Syntax.Unpack
                                                              (Data.Theory.UoM.Base
                                                                 "m")) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                        "m" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many { "m"
flatten } "m"
extendFlatCache
  Data.Theory.UoM.Base ["m"]
  [G]
  fsk0_aaJF[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                        "m" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                        "m" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                          "m" :: Data.Theory.UoM.Unit)
                       GHC.Prim.~#
                       (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                                                  "m" :: Data.Theory.UoM.Unit)
                                                               GHC.Prim.~#
                                                               (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 54[l:3,d:0] Kept as inert:
    [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                            "m" :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                       "m" :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                      fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                        GHC.Types.Symbol) (CFunEqCan)
  inerts = {Equalities: [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                                               "m" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Unsolved goals = 0}
  rest of worklist = WL {Non-eqs = [WD] irred_aaJD {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                                           (Data.UnitsOfMeasure.Syntax.Unpack
                                                              (Data.Theory.UoM.Base
                                                                 "m")) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
flatten_many { fsk0_aaJF[fsk]
Unfilled tyvar fsk_aaJF[fsk]
flatten } fsk0_aaJF[fsk]
extendFlatCache
  Data.UnitsOfMeasure.Syntax.Unpack [fsk0_aaJF[fsk]]
  [G]
  fsk0_aaJH[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                        fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
doTopReact
  [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                          fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                       GHC.Prim.~#
                       (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol) (CFunEqCan)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaJF[fsk]
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                                  fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                      GHC.Types.Symbol)
                                                               GHC.Prim.~#
                                                               (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol) (CFunEqCan)
addInertCan }
Step 55[l:3,d:0] Kept as inert:
    [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                            fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                GHC.Types.Symbol)
                         GHC.Prim.~#
                         (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                       fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                                    GHC.Prim.~#
                                    (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_aaJD {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                      (Data.UnitsOfMeasure.Syntax.Unpack
                                         (Data.Theory.UoM.Base "m")) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                                               "m" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] irred_aaJD {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                                        (Data.UnitsOfMeasure.Syntax.Unpack
                                           (Data.Theory.UoM.Base "m")) (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_aaJD {0}:: Data.UnitsOfMeasure.Canonical.IsCanonical
                          (Data.UnitsOfMeasure.Syntax.Unpack
                             (Data.Theory.UoM.Base "m")) (CNonCanonical)
canEvNC:irred
  Data.UnitsOfMeasure.Canonical.IsCanonical
    (Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "m"))
can_pred
  IrredPred =  Data.UnitsOfMeasure.Canonical.IsCanonical
                 (Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "m"))
flatten {
  FM_FlattenAll Data.UnitsOfMeasure.Canonical.IsCanonical
                  (Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "m"))
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical
              (Data.UnitsOfMeasure.Syntax.Unpack (Data.Theory.UoM.Base "m"))
  Match failed
matchFamTcM
  Matching: Data.UnitsOfMeasure.Syntax.Unpack
              (Data.Theory.UoM.Base "m")
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["m"]
  fsk0_aaJF[fsk]
Unfilled tyvar fsk_aaJF[fsk]
flatten/flat-cache hit
  Data.UnitsOfMeasure.Syntax.Unpack [fsk0_aaJF[fsk]]
  fsk0_aaJH[fsk]
Unfilled tyvar fsk_aaJH[fsk]
Following inert tyvar
  FM_FlattenAll fsk_aaJH[fsk] = '["m"]
                                'Data.UnitsOfMeasure.Syntax.:/ '[]
  [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["m"]
                         'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.IsCanonical
              ('["m"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
  Match succeeded:
    Rewrites to: (Data.UnitsOfMeasure.Canonical.AllIsCanonical '["m"],
                  Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
    Coercion: Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                <'["m"]>_N <'[]>_N
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.IsCanonical
  ['["m"] 'Data.UnitsOfMeasure.Syntax.:/ '[]]
  (Data.UnitsOfMeasure.Canonical.AllIsCanonical '["m"],
   Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
  Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
    <'["m"]>_N <'[]>_N :: Data.UnitsOfMeasure.Canonical.IsCanonical
                            ('["m"]
                             'Data.UnitsOfMeasure.Syntax.:/ '[]) ~ (Data.UnitsOfMeasure.Canonical.AllIsCanonical
                                                                      '["m"],
                                                                    Data.UnitsOfMeasure.Canonical.AllIsCanonical
                                                                      '[])
  True
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.AllIsCanonical '["m"]
  Match succeeded:
    Rewrites to: ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                     "m" :: Data.Theory.UoM.Unit)
                  ~
                  (Data.Theory.UoM.Base "m" :: Data.Theory.UoM.Unit),
                  Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
    Coercion: Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                <"m">_N <'[]>_N
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.AllIsCanonical
  ['["m"]]
  ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
      "m" :: Data.Theory.UoM.Unit)
   ~
   (Data.Theory.UoM.Base "m" :: Data.Theory.UoM.Unit),
   Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
  Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
    <"m">_N <'[]>_N :: Data.UnitsOfMeasure.Canonical.AllIsCanonical
                         '["m"] ~ ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                      "m" :: Data.Theory.UoM.Unit)
                                   ~
                                   (Data.Theory.UoM.Base "m" :: Data.Theory.UoM.Unit),
                                   Data.UnitsOfMeasure.Canonical.AllIsCanonical '[])
  False
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "m"
    Coercion: UnitDefs.R:CanonicalBaseUnit"m"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["m"]
  Data.Theory.UoM.Base "m"
  UnitDefs.R:CanonicalBaseUnit"m"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "m" ~ Data.Theory.UoM.Base "m"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["m"]
  fsk0_aaJF[fsk]
Unfilled tyvar fsk_aaJF[fsk]
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["m"]
  fsk0_aaJF[fsk]
Unfilled tyvar fsk_aaJF[fsk]
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.AllIsCanonical '[]
  Match succeeded:
    Rewrites to: () :: Constraint
    Coercion: Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.AllIsCanonical
  ['[]]
  () :: Constraint
  Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0] :: Data.UnitsOfMeasure.Canonical.AllIsCanonical
                                                           '[] ~ () :: Constraint
  False
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.AllIsCanonical '[]
  Match succeeded:
    Rewrites to: () :: Constraint
    Coercion: Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.AllIsCanonical
  ['[]]
  () :: Constraint
  Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0] :: Data.UnitsOfMeasure.Canonical.AllIsCanonical
                                                           '[] ~ () :: Constraint
  False
extendFlatCache
  Data.UnitsOfMeasure.Canonical.IsCanonical ['["m"]
                                             'Data.UnitsOfMeasure.Syntax.:/ '[]]
  [WD]
  (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
    ~
    (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
    () :: Constraint),
   () :: Constraint)
flatten }
  (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
    ~
    (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
    () :: Constraint),
   () :: Constraint)
Emitting new wanted
  $d(%,%)_aaJJ :: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                    ~
                    (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                    () :: Constraint),
                   () :: Constraint)
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9Hj
  [W] irred_aaJD
    = $d(%,%)_aaJJ `cast` (Sub
                             (Sym
                                (Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                                   <'["m"]>_N <'[]>_N
                                 ; Sym
                                     (GHC.Classes.(%,%)
                                        (Sym (Trans
                                                  (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                                                       <"m">_N <'[]>_N)
                                                  (Sym (GHC.Classes.(%,%)
                                                          ((~)
                                                             <Data.Theory.UoM.Unit>_N
                                                             (Sym (Trans
                                                                       (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                                       cobox))
                                                             (Sym cobox))_N
                                                          (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)))
                                        (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)
                              ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                   (Trans
                                        (Trans (Sym cobox) (Sym cobox))
                                        (Data.UnitsOfMeasure.Syntax.Unpack (Sym cobox))_N))_N))
flatten_many {
  ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
   ~
   (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
   () :: Constraint)
  () :: Constraint
Unfilled tyvar fsk_aaJF[fsk]
Unfilled tyvar fsk_aaJF[fsk]
flatten }
  ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
   ~
   (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
   () :: Constraint)
  () :: Constraint
canClass
  [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint),
                           () :: Constraint)
  (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
    ~
    (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
    () :: Constraint),
   () :: Constraint)
  ContinueWith [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                         ~
                                         (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                         () :: Constraint),
                                        () :: Constraint)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                          ~
                                          (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                          () :: Constraint),
                                         () :: Constraint) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                          ~
                                          (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                          () :: Constraint),
                                         () :: Constraint) (CDictCan(psc))
doTopReact
  [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint),
                           () :: Constraint) (CDictCan(psc))
matchClassInst
  pred = (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
           ~
           (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
           () :: Constraint),
          () :: Constraint) {
} matchClassInst result
  GenInst [((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
            ~
            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
            () :: Constraint),
           () :: Constraint]
          [safe]
doTopReact/found instance for
  [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint),
                           () :: Constraint)
updSolvedSetTcs:
  [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint),
                           () :: Constraint)
Emitting new wanted
  $d(%,%)_aaJK :: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                   ~
                   (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                   () :: Constraint)
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
Emitting new wanted
  $d(%%)_aaJL :: () :: Constraint
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9Hj
  [W] $d(%,%)_aaJJ
    = GHC.Classes.C:(%,%) @[((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                             ~
                             (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                             () :: Constraint),
                            () :: Constraint]
                          [$d(%,%)_aaJK, $d(%%)_aaJL]
Emitting fresh work
  [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint) (CNonCanonical)
  [WD] $d(%%)_aaJL {1}:: () :: Constraint (CNonCanonical)
end stage top-level reactions }
Step 56[l:3,d:0] Top react: Dict/Top (solved wanted):
    [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                              ~
                              (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                              () :: Constraint),
                             () :: Constraint)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                       ~
                                       (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                       () :: Constraint) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                                               "m" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaJL {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                         ~
                                         (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                         () :: Constraint) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint) (CNonCanonical)
canEvNC:cls
  GHC.Classes.(%,%) [(fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                     ~
                     (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                     () :: Constraint]
flatten_many {
  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  ~
  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  () :: Constraint
Unfilled tyvar fsk_aaJF[fsk]
Unfilled tyvar fsk_aaJF[fsk]
flatten }
  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  ~
  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  () :: Constraint
canClass
  [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint)
  ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
   ~
   (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
   () :: Constraint)
  ContinueWith [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                        ~
                                        (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                        () :: Constraint)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                         ~
                                         (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                         () :: Constraint) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                         ~
                                         (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                         () :: Constraint) (CDictCan(psc))
doTopReact
  [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint) (CDictCan(psc))
matchClassInst
  pred = ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
          ~
          (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
          () :: Constraint) {
} matchClassInst result
  GenInst [(fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
           ~
           (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
           () :: Constraint]
          [safe]
doTopReact/found instance for
  [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint)
updSolvedSetTcs:
  [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                           ~
                           (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                           () :: Constraint)
Emitting new wanted
  $d~_aaJM :: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
              ~
              (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
Emitting new wanted
  $d(%%)_aaJN :: () :: Constraint
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9Hj
  [W] $d(%,%)_aaJK
    = GHC.Classes.C:(%,%) @[(fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                            ~
                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                            () :: Constraint]
                          [$d~_aaJM, $d(%%)_aaJN]
Emitting fresh work
  [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
  [WD] $d(%%)_aaJN {2}:: () :: Constraint (CNonCanonical)
end stage top-level reactions }
Step 57[l:3,d:1] Top react: Dict/Top (solved wanted):
    [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                             ~
                             (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                             () :: Constraint)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                  ~
                                  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                                               "m" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaJN {2}:: () :: Constraint (CNonCanonical)
                                   [WD] $d(%%)_aaJL {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                    ~
                                    (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~ [Data.Theory.UoM.Unit, fsk0_aaJF[fsk], fsk0_aaJF[fsk]]
flatten_many {
  Data.Theory.UoM.Unit
  fsk0_aaJF[fsk]
  fsk0_aaJF[fsk]
Unfilled tyvar fsk_aaJF[fsk]
Unfilled tyvar fsk_aaJF[fsk]
flatten }
  Data.Theory.UoM.Unit
  fsk0_aaJF[fsk]
  fsk0_aaJF[fsk]
canClass
  [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  ~
  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                   ~
                                   (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                    ~
                                    (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                    ~
                                    (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
         ~
         (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) {
matchClass success
  dict (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
       ~
       (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  witness Data.Type.Equality.$f~kab forall k (a :: k) (b :: k).
                                    (a :: k) ~~ (b :: k) =>
                                    (a :: k) ~ (b :: k)
} matchClassInst result
  GenInst [(fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
           ~~
           (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                      ~
                      (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
Emitting new wanted
  $d~~_aaJO :: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
               ~~
               (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  arising from the superclasses of an instance declaration
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9Hj
  [W] $d~_aaJM
    = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, fsk0_aaJF[fsk],
                                  fsk0_aaJF[fsk]]
                                [$d~~_aaJO]
Emitting fresh work
  [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 58[l:3,d:2] Top react: Dict/Top (solved wanted):
    [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                        ~
                        (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                   ~~
                                   (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                                               "m" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
                        [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                            ~
                                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaJN {2}:: () :: Constraint (CNonCanonical)
                                   [WD] $d(%%)_aaJL {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~~ [Data.Theory.UoM.Unit, Data.Theory.UoM.Unit, fsk0_aaJF[fsk],
      fsk0_aaJF[fsk]]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  fsk0_aaJF[fsk]
  fsk0_aaJF[fsk]
Unfilled tyvar fsk_aaJF[fsk]
Unfilled tyvar fsk_aaJF[fsk]
flatten }
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  fsk0_aaJF[fsk]
  fsk0_aaJF[fsk]
canClass
  [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  ~~
  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                    ~~
                                    (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
         ~~
         (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) {
} matchClassInst result
  GenInst [(fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
           GHC.Prim.~#
           (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                       ~~
                       (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
New coercion hole: aaJP
Emitting new coercion hole
  {aaJP} :: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
addTcEvBind
  a9Hj
  [W] $d~~_aaJO
    = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                      fsk0_aaJF[fsk], fsk0_aaJF[fsk]]
                    [CO <fsk0_aaJF[fsk]>_N]
Emitting fresh work
  [WD] hole{aaJP} {4}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 59[l:3,d:3] Top react: Dict/Top (solved wanted):
    [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                         ~~
                         (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJP} {4}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                                               "m" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
                        [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                            ~
                                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaJN {2}:: () :: Constraint (CNonCanonical)
                                   [WD] $d(%%)_aaJL {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJP} {4}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{aaJP} {4}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:eq
  fsk0_aaJF[fsk]
  fsk0_aaJF[fsk]
Filling coercion hole aaJP := <fsk0_aaJF[fsk]>_N
end stage canonicalization }
Step 60[l:3,d:4] Solved by reflexivity:
    [WD] hole{aaJP} {4}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d(%%)_aaJN {2}:: () :: Constraint (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                                               "m" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
                        [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                            ~
                                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Non-eqs = [WD] $d(%%)_aaJL {1}:: () :: Constraint (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d(%%)_aaJN {2}:: () :: Constraint (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d(%%)_aaJN {2}:: () :: Constraint (CNonCanonical)
canEvNC:cls GHC.Classes.(%%) []
flatten_many {
flatten }
canClass
  [WD] $d(%%)_aaJN {2}:: () :: Constraint
  () :: Constraint
  ContinueWith [WD] $d(%%)_aaJN {2}:: () :: Constraint
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d(%%)_aaJN {2}:: () :: Constraint (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d(%%)_aaJN {2}:: () :: Constraint (CDictCan)
doTopReact [WD] $d(%%)_aaJN {2}:: () :: Constraint (CDictCan)
matchClassInst pred = () :: Constraint {
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for
  [WD] $d(%%)_aaJN {2}:: () :: Constraint
updSolvedSetTcs: [WD] $d(%%)_aaJN {2}:: () :: Constraint
addTcEvBind
  a9Hj
  [W] $d(%%)_aaJN = GHC.Classes.C:(%%) @[] []
end stage top-level reactions }
Step 61[l:3,d:2] Top react: Dict/Top (solved wanted):
    [WD] $d(%%)_aaJN {2}:: () :: Constraint
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d(%%)_aaJL {1}:: () :: Constraint (CNonCanonical)
  inerts = {Equalities: [G] cobox_aaJE {0}:: (fsk0_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_aaJG {0}:: (Data.Theory.UoM.Base
                                                               "m" :: Data.Theory.UoM.Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [G] cobox_aaJI {0}:: (Data.UnitsOfMeasure.Syntax.Unpack
                                                               fsk0_aaJF[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_aaJH[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $d(%,%)_aaJK {1}:: ((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint)
                        [WD] $d(%,%)_aaJJ {0}:: (((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                  ~
                                                  (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                  () :: Constraint),
                                                 () :: Constraint)
                        [WD] $d~_aaJM {2}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                            ~
                                            (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJO {3}:: (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                        [WD] $d(%%)_aaJN {2}:: () :: Constraint
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $d(%%)_aaJL {1}:: () :: Constraint (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d(%%)_aaJL {1}:: () :: Constraint (CNonCanonical)
canEvNC:cls GHC.Classes.(%%) []
flatten_many {
flatten }
canClass
  [WD] $d(%%)_aaJL {1}:: () :: Constraint
  () :: Constraint
  ContinueWith [WD] $d(%%)_aaJL {1}:: () :: Constraint
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d(%%)_aaJL {1}:: () :: Constraint (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d(%%)_aaJL {1}:: () :: Constraint (CDictCan)
doTopReact [WD] $d(%%)_aaJL {1}:: () :: Constraint (CDictCan)
addTcEvBind
  a9Hj
  [W] $d(%%)_aaJL = $d(%%)_aaJN
end stage top-level reactions }
Step 62[l:3,d:1] Top react: Dict/Top (cached):
    [WD] $d(%%)_aaJL {1}:: () :: Constraint
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  insols = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs =
   Tv eqs =}
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
zonkSimples done: {}
solveSimpleWanteds end }
  iterations = 2
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {[W] irred_a9Hl = irred_a9Hi,
                      [W] irred_a9Hi
                        = irred_aaJD `cast` (Sub
                                               (Sym
                                                  U(hole:{aaJC}, Data.UnitsOfMeasure.Canonical.IsCanonical
                                                                   s0_aaJz[fuv:0], s0_aaJB[fuv:0])_N
                                                ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                     (Trans
                                                          (Sym {aaJA})
                                                          (Data.UnitsOfMeasure.Syntax.Unpack
                                                             (Sym (Trans
                                                                       (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                                       {aaJy})))_N))_N)),
                      [G] cobox_aaJE
                        = CO U(plugin:units, Data.UnitsOfMeasure.Syntax.Unpack
                                               (Data.Theory.UoM.Base "m"), '["m"]
                                                                           'Data.UnitsOfMeasure.Syntax.:/ '[])_N,
                      [G] cobox_aaJG = CO <Data.Theory.UoM.Base "m">_N,
                      [G] cobox_aaJI
                        = CO <Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaJF[fsk]>_N,
                      [W] irred_aaJD
                        = $d(%,%)_aaJJ `cast` (Sub
                                                 (Sym
                                                    (Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                                                       <'["m"]>_N <'[]>_N
                                                     ; Sym
                                                         (GHC.Classes.(%,%)
                                                            (Sym (Trans
                                                                      (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                                                                           <"m">_N <'[]>_N)
                                                                      (Sym (GHC.Classes.(%,%)
                                                                              ((~)
                                                                                 <Data.Theory.UoM.Unit>_N
                                                                                 (Sym (Trans
                                                                                           (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                                                           cobox))
                                                                                 (Sym cobox))_N
                                                                              (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)))
                                                            (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)
                                                  ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                       (Trans
                                                            (Trans (Sym cobox) (Sym cobox))
                                                            (Data.UnitsOfMeasure.Syntax.Unpack
                                                               (Sym cobox))_N))_N)),
                      [W] $d(%,%)_aaJJ
                        = GHC.Classes.C:(%,%) @[((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                 ~
                                                 (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                 () :: Constraint),
                                                () :: Constraint]
                                              [$d(%,%)_aaJK, $d(%%)_aaJL],
                      [W] $d(%,%)_aaJK
                        = GHC.Classes.C:(%,%) @[(fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                ~
                                                (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                () :: Constraint]
                                              [$d~_aaJM, $d(%%)_aaJN],
                      [W] $d~_aaJM
                        = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, fsk0_aaJF[fsk],
                                                      fsk0_aaJF[fsk]]
                                                    [$d~~_aaJO],
                      [W] $d~~_aaJO
                        = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                          fsk0_aaJF[fsk], fsk0_aaJF[fsk]]
                                        [CO <fsk0_aaJF[fsk]>_N],
                      [W] $d(%%)_aaJN = GHC.Classes.C:(%%) @[] [],
                      [W] $d(%%)_aaJL = $d(%%)_aaJN}
getNoGivenEqs
  False
  {Unsolved goals = 0}
  {}
floatEqualities
  Skols = []
  Simples = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus 2
  []
  ([a9Hl :-> [W] irred_a9Hl = irred_a9Hi,
    a9Hi :-> [W] irred_a9Hi
               = irred_aaJD `cast` (Sub
                                      (Sym
                                         U(hole:{aaJC}, Data.UnitsOfMeasure.Canonical.IsCanonical
                                                          s0_aaJz[fuv:0], s0_aaJB[fuv:0])_N
                                       ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                            (Trans
                                                 (Sym {aaJA})
                                                 (Data.UnitsOfMeasure.Syntax.Unpack
                                                    (Sym (Trans
                                                              (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                              {aaJy})))_N))_N)),
    aaJE :-> [G] cobox_aaJE
               = CO U(plugin:units, Data.UnitsOfMeasure.Syntax.Unpack
                                      (Data.Theory.UoM.Base "m"), '["m"]
                                                                  'Data.UnitsOfMeasure.Syntax.:/ '[])_N,
    aaJG :-> [G] cobox_aaJG = CO <Data.Theory.UoM.Base "m">_N,
    aaJI :-> [G] cobox_aaJI
               = CO <Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaJF[fsk]>_N,
    aaJD :-> [W] irred_aaJD
               = $d(%,%)_aaJJ `cast` (Sub
                                        (Sym
                                           (Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                                              <'["m"]>_N <'[]>_N
                                            ; Sym
                                                (GHC.Classes.(%,%)
                                                   (Sym (Trans
                                                             (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                                                                  <"m">_N <'[]>_N)
                                                             (Sym (GHC.Classes.(%,%)
                                                                     ((~)
                                                                        <Data.Theory.UoM.Unit>_N
                                                                        (Sym (Trans
                                                                                  (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                                                  cobox))
                                                                        (Sym cobox))_N
                                                                     (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)))
                                                   (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)
                                         ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                              (Trans
                                                   (Trans (Sym cobox) (Sym cobox))
                                                   (Data.UnitsOfMeasure.Syntax.Unpack
                                                      (Sym cobox))_N))_N)),
    aaJJ :-> [W] $d(%,%)_aaJJ
               = GHC.Classes.C:(%,%) @[((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                        ~
                                        (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                        () :: Constraint),
                                       () :: Constraint]
                                     [$d(%,%)_aaJK, $d(%%)_aaJL],
    aaJK :-> [W] $d(%,%)_aaJK
               = GHC.Classes.C:(%,%) @[(fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                       ~
                                       (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                       () :: Constraint]
                                     [$d~_aaJM, $d(%%)_aaJN],
    aaJM :-> [W] $d~_aaJM
               = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, fsk0_aaJF[fsk],
                                             fsk0_aaJF[fsk]]
                                           [$d~~_aaJO],
    aaJO :-> [W] $d~~_aaJO
               = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                 fsk0_aaJF[fsk], fsk0_aaJF[fsk]]
                               [CO <fsk0_aaJF[fsk]>_N],
    aaJN :-> [W] $d(%%)_aaJN = GHC.Classes.C:(%%) @[] [],
    aaJL :-> [W] $d(%%)_aaJL = $d(%%)_aaJN],
   [])
  []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {[W] irred_a9Hl = irred_a9Hi,
                         [W] irred_a9Hi
                           = irred_aaJD `cast` (Sub
                                                  (Sym
                                                     U(hole:{aaJC}, Data.UnitsOfMeasure.Canonical.IsCanonical
                                                                      s0_aaJz[fuv:0], s0_aaJB[fuv:0])_N
                                                   ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                        (Trans
                                                             (Sym {aaJA})
                                                             (Data.UnitsOfMeasure.Syntax.Unpack
                                                                (Sym (Trans
                                                                          (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                                          {aaJy})))_N))_N)),
                         [G] cobox_aaJE
                           = CO U(plugin:units, Data.UnitsOfMeasure.Syntax.Unpack
                                                  (Data.Theory.UoM.Base "m"), '["m"]
                                                                              'Data.UnitsOfMeasure.Syntax.:/ '[])_N,
                         [G] cobox_aaJG = CO <Data.Theory.UoM.Base "m">_N,
                         [G] cobox_aaJI
                           = CO <Data.UnitsOfMeasure.Syntax.Unpack fsk0_aaJF[fsk]>_N,
                         [W] irred_aaJD
                           = $d(%,%)_aaJJ `cast` (Sub
                                                    (Sym
                                                       (Data.UnitsOfMeasure.Canonical.D:R:IsCanonical[0]
                                                          <'["m"]>_N <'[]>_N
                                                        ; Sym
                                                            (GHC.Classes.(%,%)
                                                               (Sym (Trans
                                                                         (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[1]
                                                                              <"m">_N <'[]>_N)
                                                                         (Sym (GHC.Classes.(%,%)
                                                                                 ((~)
                                                                                    <Data.Theory.UoM.Unit>_N
                                                                                    (Sym (Trans
                                                                                              (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                                                              cobox))
                                                                                    (Sym cobox))_N
                                                                                 (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)))
                                                               (Sym (Data.UnitsOfMeasure.Canonical.D:R:AllIsCanonical[0])))_N)
                                                     ; (Data.UnitsOfMeasure.Canonical.IsCanonical
                                                          (Trans
                                                               (Trans (Sym cobox) (Sym cobox))
                                                               (Data.UnitsOfMeasure.Syntax.Unpack
                                                                  (Sym cobox))_N))_N)),
                         [W] $d(%,%)_aaJJ
                           = GHC.Classes.C:(%,%) @[((fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                    ~
                                                    (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                    () :: Constraint),
                                                   () :: Constraint]
                                                 [$d(%,%)_aaJK, $d(%%)_aaJL],
                         [W] $d(%,%)_aaJK
                           = GHC.Classes.C:(%,%) @[(fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit)
                                                   ~
                                                   (fsk0_aaJF[fsk] :: Data.Theory.UoM.Unit),
                                                   () :: Constraint]
                                                 [$d~_aaJM, $d(%%)_aaJN],
                         [W] $d~_aaJM
                           = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, fsk0_aaJF[fsk],
                                                         fsk0_aaJF[fsk]]
                                                       [$d~~_aaJO],
                         [W] $d~~_aaJO
                           = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                             fsk0_aaJF[fsk], fsk0_aaJF[fsk]]
                                           [CO <fsk0_aaJF[fsk]>_N],
                         [W] $d(%%)_aaJN = GHC.Classes.C:(%%) @[] [],
                         [W] $d(%%)_aaJL = $d(%%)_aaJN}
  implication tvcs = []
solveImplication {
  Implic {
    TcLevel = 3
    Skolems =
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_impl =
            Implic {
              TcLevel = 4
              Skolems = (proxy_a9Ho[sk:4] :: GHC.Types.Symbol -> *)
              No-eqs = False
              Status = Unsolved
              Given =
              Wanted =
                WC {wc_simple =
                      [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                               "m" (CNonCanonical)
                      [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                          ~
                                          ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                 "m") :: Data.Theory.UoM.Unit) (CNonCanonical)
                      [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                             "m" :: Data.Theory.UoM.Unit)
                                          ~
                                          (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                             "m" :: Data.Theory.UoM.Unit) (CNonCanonical)}
              Binds = EvBindsVar<a9Hw>
              Needed = []
              the type signature for:
                Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                                 -> *).
                                                                proxy "m"
                                                                -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                     Rational
                                                                     (Data.Theory.UoM.Base "m"
                                                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                           "m") }}
    Binds = EvBindsVar<a9Hx>
    Needed = []
    the instance declaration }
  Inerts {Unsolved goals = 0}
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 4
          Skolems = (proxy_a9Ho[sk:4] :: GHC.Types.Symbol -> *)
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                           "m" (CNonCanonical)
                  [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                      ~
                                      ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
                                        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                             "m") :: Data.Theory.UoM.Unit) (CNonCanonical)
                  [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                         "m" :: Data.Theory.UoM.Unit)
                                      ~
                                      (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                         "m" :: Data.Theory.UoM.Unit) (CNonCanonical)}
          Binds = EvBindsVar<a9Hw>
          Needed = []
          the type signature for:
            Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                             -> *).
                                                            proxy "m"
                                                            -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                                 Rational
                                                                 (Data.Theory.UoM.Base "m"
                                                                  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                       "m") }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 4
    Skolems = (proxy_a9Ho[sk:4] :: GHC.Types.Symbol -> *)
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                     "m" (CNonCanonical)
            [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                ~
                                ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
                                  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                       "m") :: Data.Theory.UoM.Unit) (CNonCanonical)
            [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                   "m" :: Data.Theory.UoM.Unit)
                                ~
                                (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                   "m" :: Data.Theory.UoM.Unit) (CNonCanonical)}
    Binds = EvBindsVar<a9Hw>
    Needed = []
    the type signature for:
      Data.UnitsOfMeasure.Canonical.conversionBase :: forall (proxy :: GHC.Types.Symbol
                                                                       -> *).
                                                      proxy "m"
                                                      -> Data.UnitsOfMeasure.Unsafe.Quantity.Quantity
                                                           Rational
                                                           (Data.Theory.UoM.Base "m"
                                                            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                                                 "m") }
  Inerts {Unsolved goals = 0}
solveWanteds {
  WC {wc_simple =
        [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                 "m" (CNonCanonical)
        [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                            ~
                            ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
                              Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                   "m") :: Data.Theory.UoM.Unit) (CNonCanonical)
        [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                               "m" :: Data.Theory.UoM.Unit)
                            ~
                            (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                               "m" :: Data.Theory.UoM.Unit) (CNonCanonical)}
solveSimpleWanteds {
  {[WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                            "m" (CNonCanonical),
   [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                       ~
                       ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
                         Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                              "m") :: Data.Theory.UoM.Unit) (CNonCanonical),
   [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                          "m" :: Data.Theory.UoM.Unit)
                       ~
                       (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "m" :: Data.Theory.UoM.Unit) (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                  ~
                                  ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
                                    Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                         "m") :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Unsolved goals = 0}
  rest of worklist = WL {Eqs = [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                                      "m" :: Data.Theory.UoM.Unit)
                                                   ~
                                                   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                      "m" :: Data.Theory.UoM.Unit) (CNonCanonical)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "m" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                    ~
                                    ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
                                      Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                           "m") :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                      ~
                      ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
                        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                             "m") :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~ [Data.Theory.UoM.Unit, Data.Theory.UoM.One,
     Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
     Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                          "m"]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.One
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
  Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                       "m"
matchFamTcM
  Matching: Data.Theory.UoM.One
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.One
  Match failed
New coercion hole: aaJR
Emitting new coercion hole
  {aaJR} :: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
extendFlatCache
  Data.Theory.UoM.One []
  [WD]
  s0_aaJQ[fuv:0]
flatten/flat-cache miss
  Data.Theory.UoM.One []
  s_aaJQ[fuv:0]
  [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
            Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                 "m"
  Match failed
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "m"
    Coercion: UnitDefs.R:CanonicalBaseUnit"m"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["m"]
  Data.Theory.UoM.Base "m"
  UnitDefs.R:CanonicalBaseUnit"m"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "m" ~ Data.Theory.UoM.Base "m"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
New coercion hole: aaJT
Emitting new coercion hole
  {aaJT} :: (Data.Theory.UoM.Base "m" :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
extendFlatCache
  Data.Theory.UoM.Base ["m"]
  [WD]
  s0_aaJS[fuv:0]
flatten/flat-cache miss
  Data.Theory.UoM.Base ["m"]
  s_aaJS[fuv:0]
  [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                           "m" :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "m"
    Coercion: UnitDefs.R:CanonicalBaseUnit"m"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["m"]
  Data.Theory.UoM.Base "m"
  UnitDefs.R:CanonicalBaseUnit"m"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "m" ~ Data.Theory.UoM.Base "m"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["m"]
  s0_aaJS[fuv:0]
Unfilled tyvar s_aaJS[fuv:0]
matchFamTcM
  Matching: s0_aaJS[fuv:0] Data.Theory.UoM./: s0_aaJS[fuv:0]
  Match failed
New coercion hole: aaJV
Emitting new coercion hole
  {aaJV} :: ((s0_aaJS[fuv:0]
              Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
extendFlatCache
  Data.Theory.UoM./: [s0_aaJS[fuv:0], s0_aaJS[fuv:0]]
  [WD]
  s0_aaJU[fuv:0]
flatten/flat-cache miss
  Data.Theory.UoM./: [s0_aaJS[fuv:0], s0_aaJS[fuv:0]]
  s_aaJU[fuv:0]
  [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                          Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
flatten }
  Data.Theory.UoM.Unit
  s0_aaJQ[fuv:0]
  s0_aaJU[fuv:0]
Emitting new wanted
  $d~_aaJW :: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
              ~
              (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
  arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9Hw
  [W] $d~_a9Hu
    = $d~_aaJW `cast` ((~)
                         <Data.Theory.UoM.Unit>_N
                         (Sym {aaJR})
                         (Trans
                              (Sym {aaJV})
                              (Sym (Trans (UnitDefs.R:CanonicalBaseUnit"m"[0]) {aaJT})
                               Data.Theory.UoM./: Sym (Trans
                                                           (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                           {aaJT}))_N))_R
canClass
  [WD] $d~_a9Hu {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                      ~
                      ((Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
                        Data.Theory.UoM./: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                             "m") :: Data.Theory.UoM.Unit)
  (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
  ~
  (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                   ~
                                   (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~
                                    (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~
                                    (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
         ~
         (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) {
matchClass success
  dict (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
       ~
       (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
  witness Data.Type.Equality.$f~kab forall k (a :: k) (b :: k).
                                    (a :: k) ~~ (b :: k) =>
                                    (a :: k) ~ (b :: k)
} matchClassInst result
  GenInst [(s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
           ~~
           (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
Emitting new wanted
  $d~~_aaJX :: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
               ~~
               (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
  arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9Hw
  [W] $d~_aaJW
    = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJQ[fuv:0],
                                  s0_aaJU[fuv:0]]
                                [$d~~_aaJX]
Emitting fresh work
  [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 63[l:4,d:0] Top react: Dict/Top (solved wanted):
    [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                        ~
                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                   ~~
                                   (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Solved dicts [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Eqs = [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                                      "m" :: Data.Theory.UoM.Unit)
                                                   ~
                                                   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                      "m" :: Data.Theory.UoM.Unit) (CNonCanonical)
                         Funeqs = [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                                           "m" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "m" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~~ [Data.Theory.UoM.Unit, Data.Theory.UoM.Unit, s0_aaJQ[fuv:0],
      s0_aaJU[fuv:0]]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  s0_aaJQ[fuv:0]
  s0_aaJU[fuv:0]
Unfilled tyvar s_aaJQ[fuv:0]
Unfilled tyvar s_aaJU[fuv:0]
flatten }
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  s0_aaJQ[fuv:0]
  s0_aaJU[fuv:0]
canClass
  [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
  (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
  ~~
  (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~~
                                    (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
         ~~
         (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) {
} matchClassInst result
  GenInst [(s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
           GHC.Prim.~#
           (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
New coercion hole: aaJY
Emitting new coercion hole
  {aaJY} :: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
addTcEvBind
  a9Hw
  [W] $d~~_aaJX
    = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                      s0_aaJQ[fuv:0], s0_aaJU[fuv:0]]
                    [CO U(hole:{aaJY}, s0_aaJQ[fuv:0], s0_aaJU[fuv:0])_N]
Emitting fresh work
  [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 64[l:4,d:1] Top react: Dict/Top (solved wanted):
    [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                         ~~
                         (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Solved dicts [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Eqs = [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                                      "m" :: Data.Theory.UoM.Unit)
                                                   ~
                                                   (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                                      "m" :: Data.Theory.UoM.Unit) (CNonCanonical)
                         Funeqs = [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                                           "m" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "m" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:eq
  s0_aaJQ[fuv:0]
  s0_aaJU[fuv:0]
can_eq_nc
  False
  [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
  nominal equality
  s0_aaJQ[fuv:0]
  s0_aaJQ[fuv:0]
  s0_aaJU[fuv:0]
  s0_aaJU[fuv:0]
flatten { FM_FlattenAll s0_aaJQ[fuv:0]
Unfilled tyvar s_aaJQ[fuv:0]
flatten } s0_aaJQ[fuv:0]
flatten { FM_FlattenAll s0_aaJU[fuv:0]
Unfilled tyvar s_aaJU[fuv:0]
flatten } s0_aaJU[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_aaJQ[fuv:0] :: Data.Theory.UoM.Unit
      TcLevel of s_aaJQ[fuv:0] is 0
  RHS: s0_aaJU[fuv:0] :: Data.Theory.UoM.Unit
addInertEq {
  Adding new inert equality: [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                                   GHC.Prim.~#
                                                   (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 65[l:4,d:2] Kept as inert:
    [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                     "m" :: Data.Theory.UoM.Unit)
                                  ~
                                  (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                     "m" :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                                           "m" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "m" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                                       "m" :: Data.Theory.UoM.Unit)
                                    ~
                                    (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                       "m" :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                         "m" :: Data.Theory.UoM.Unit)
                      ~
                      (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                         "m" :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~ [Data.Theory.UoM.Unit, Data.Theory.UoM.Base "m",
     Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Base "m"
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["m"]
  s0_aaJS[fuv:0]
Unfilled tyvar s_aaJS[fuv:0]
matchFamTcM
  Matching: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit "m"
  Match succeeded:
    Rewrites to: Data.Theory.UoM.Base "m"
    Coercion: UnitDefs.R:CanonicalBaseUnit"m"[0]
Eager T.F. reduction success
  Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
  ["m"]
  Data.Theory.UoM.Base "m"
  UnitDefs.R:CanonicalBaseUnit"m"[0] :: Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                                          "m" ~ Data.Theory.UoM.Base "m"
  False
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
flatten/flat-cache hit
  Data.Theory.UoM.Base ["m"]
  s0_aaJS[fuv:0]
Unfilled tyvar s_aaJS[fuv:0]
flatten }
  Data.Theory.UoM.Unit
  s0_aaJS[fuv:0]
  s0_aaJS[fuv:0]
Emitting new wanted
  $d~_aaJZ :: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
              ~
              (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9Hw
  [W] $d~_a9Hv
    = $d~_aaJZ `cast` ((~)
                         <Data.Theory.UoM.Unit>_N
                         (Sym {aaJT})
                         (Sym (Trans (UnitDefs.R:CanonicalBaseUnit"m"[0]) {aaJT})))_R
canClass
  [WD] $d~_a9Hv {0}:: (Data.Theory.UoM.Base
                         "m" :: Data.Theory.UoM.Unit)
                      ~
                      (Data.UnitsOfMeasure.Canonical.CanonicalBaseUnit
                         "m" :: Data.Theory.UoM.Unit)
  (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  ~
  (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                   ~
                                   (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~
                                    (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~
                                    (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
         ~
         (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) {
matchClass success
  dict (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
       ~
       (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  witness Data.Type.Equality.$f~kab forall k (a :: k) (b :: k).
                                    (a :: k) ~~ (b :: k) =>
                                    (a :: k) ~ (b :: k)
} matchClassInst result
  GenInst [(s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
           ~~
           (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                      ~
                      (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
Emitting new wanted
  $d~~_aaK0 :: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
               ~~
               (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  arising from a use of ‘Data.UnitsOfMeasure.Canonical.$dmconversionBase’
  at test-suite-force/UnitDefs.hs:20:4-15
addTcEvBind
  a9Hw
  [W] $d~_aaJZ
    = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJS[fuv:0],
                                  s0_aaJS[fuv:0]]
                                [$d~~_aaK0]
Emitting fresh work
  [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 66[l:4,d:0] Top react: Dict/Top (solved wanted):
    [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                        ~
                        (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                   ~~
                                   (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                                           "m" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "m" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:cls
  ~~ [Data.Theory.UoM.Unit, Data.Theory.UoM.Unit, s0_aaJS[fuv:0],
      s0_aaJS[fuv:0]]
flatten_many {
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  s0_aaJS[fuv:0]
  s0_aaJS[fuv:0]
Unfilled tyvar s_aaJS[fuv:0]
Unfilled tyvar s_aaJS[fuv:0]
flatten }
  Data.Theory.UoM.Unit
  Data.Theory.UoM.Unit
  s0_aaJS[fuv:0]
  s0_aaJS[fuv:0]
canClass
  [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  ~~
  (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  ContinueWith [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                    ~~
                                    (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                     ~~
                                     (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
doTopReact
  [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CDictCan(psc))
matchClassInst
  pred = (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
         ~~
         (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) {
} matchClassInst result
  GenInst [(s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
           GHC.Prim.~#
           (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)]
          [safe]
doTopReact/found instance for
  [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
updSolvedSetTcs:
  [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                       ~~
                       (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
New coercion hole: aaK1
Emitting new coercion hole
  {aaK1} :: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
            GHC.Prim.~#
            (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
addTcEvBind
  a9Hw
  [W] $d~~_aaK0
    = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                      s0_aaJS[fuv:0], s0_aaJS[fuv:0]]
                    [CO <s0_aaJS[fuv:0]>_N]
Emitting fresh work
  [WD] hole{aaK1} {2}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
end stage top-level reactions }
Step 67[l:4,d:1] Top react: Dict/Top (solved wanted):
    [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                         ~~
                         (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaK1} {2}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                                           "m" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "m" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaK1} {2}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{aaK1} {2}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)
canEvNC:eq
  s0_aaJS[fuv:0]
  s0_aaJS[fuv:0]
Filling coercion hole aaK1 := <s0_aaJS[fuv:0]>_N
end stage canonicalization }
Step 68[l:4,d:2] Solved by reflexivity:
    [WD] hole{aaK1} {2}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                                           "m" :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                  [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "m" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many {
flatten }
extendFlatCache
  Data.Theory.UoM.One []
  [WD]
  s0_aaJQ[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: Data.Theory.UoM.One
  Match failed
improveTopFunEqs
  Data.Theory.UoM.One [] s_aaJQ[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                                GHC.Prim.~#
                                                                (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 69[l:4,d:0] Kept as inert:
    [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                       "m" :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Funeqs = [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                                          Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                        GHC.Prim.~#
                                                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                         Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "m" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                         "m" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many { "m"
flatten } "m"
extendFlatCache
  Data.Theory.UoM.Base ["m"]
  [WD]
  s0_aaJS[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                         "m" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                         "m" :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                           "m" :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: Data.Theory.UoM.Base "m"
  Match failed
improveTopFunEqs
  Data.Theory.UoM.Base ["m"] s_aaJS[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                                                   "m" :: Data.Theory.UoM.Unit)
                                                                GHC.Prim.~#
                                                                (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 70[l:4,d:1] Kept as inert:
    [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                             "m" :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                        "m" :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                      Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                    GHC.Prim.~#
                                    (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                                                "m" :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {Non-eqs = [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                                            "m" (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                        Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
flatten_many {
  s0_aaJS[fuv:0]
  s0_aaJS[fuv:0]
Unfilled tyvar s_aaJS[fuv:0]
Unfilled tyvar s_aaJS[fuv:0]
flatten }
  s0_aaJS[fuv:0]
  s0_aaJS[fuv:0]
extendFlatCache
  Data.Theory.UoM./: [s0_aaJS[fuv:0], s0_aaJS[fuv:0]]
  [WD]
  s0_aaJU[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                        Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                        Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                      GHC.Prim.~#
                                      (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
doTopReact
  [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                          Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_aaJS[fuv:0] Data.Theory.UoM./: s0_aaJS[fuv:0]
  Match failed
improveTopFunEqs
  Data.Theory.UoM./: [s0_aaJS[fuv:0], s0_aaJS[fuv:0]] s_aaJU[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                                                  Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                                GHC.Prim.~#
                                                                (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
addInertCan }
Step 71[l:4,d:0] Kept as inert:
    [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                            Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                       Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                     GHC.Prim.~#
                                     (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                       "m" (CNonCanonical)
  inerts = {Equalities: [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                              GHC.Prim.~#
                                              (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                                                "m" :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
                                       [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                                               Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                                             GHC.Prim.~#
                                                             (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            Unsolved goals = 1}
           Solved dicts [WD] $d~_aaJW {0}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~_aaJZ {0}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                            ~
                                            (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaJX {1}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit)
                        [WD] $d~~_aaK0 {1}:: (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
                                             ~~
                                             (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit)
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                         "m" (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "m" (CNonCanonical)
canEvNC:cls
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit ["m"]
flatten_many { "m"
flatten } "m"
canClass
  [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "m"
  Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
  ContinueWith [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                        "m"
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                         "m" (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                                         "m" (CDictCan(psc))
doTopReact
  [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "m" (CDictCan(psc))
matchClassInst
  pred = Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m" {
matchClass success
  dict Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit "m"
  witness UnitDefs.$fHasCanonicalBaseUnit"m" Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                               "m"
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for
  [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "m"
updSolvedSetTcs:
  [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                           "m"
addTcEvBind
  a9Hw
  [W] $dHasCanonicalBaseUnit_a9Hs
    = UnitDefs.$fHasCanonicalBaseUnit"m" @[] []
end stage top-level reactions }
Step 72[l:4,d:0] Top react: Dict/Top (solved wanted):
    [WD] $dHasCanonicalBaseUnit_a9Hs {0}:: Data.UnitsOfMeasure.Canonical.HasCanonicalBaseUnit
                                             "m"
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {[WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)}
  fun eqs = {[WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan),
             [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                      "m" :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan),
             [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                     Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)}
  insols = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{aaJR} {0}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            [WD] hole{aaJT} {1}:: (Data.Theory.UoM.Base
                                     "m" :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s0_aaJS[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
            [WD] hole{aaJV} {0}:: ((s0_aaJS[fuv:0]
                                    Data.Theory.UoM./: s0_aaJS[fuv:0]) :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CFunEqCan)
   Tv eqs = [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                                  GHC.Prim.~#
                                  (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)}
Filling coercion hole
  aaJV := <s0_aaJS[fuv:0] Data.Theory.UoM./: s0_aaJS[fuv:0]>_N
unflattenFmv
  s_aaJU[fuv:0] := s0_aaJS[fuv:0] Data.Theory.UoM./: s0_aaJS[fuv:0]
writeMetaTyVar
  s_aaJU[fuv:0] :: Data.Theory.UoM.Unit := s0_aaJS[fuv:0]
                                           Data.Theory.UoM./: s0_aaJS[fuv:0]
Filling coercion hole aaJT := <Data.Theory.UoM.Base "m">_N
unflattenFmv s_aaJS[fuv:0] := Data.Theory.UoM.Base "m"
writeMetaTyVar
  s_aaJS[fuv:0] :: Data.Theory.UoM.Unit := Data.Theory.UoM.Base "m"
Filling coercion hole aaJR := <Data.Theory.UoM.One>_N
unflattenFmv s_aaJQ[fuv:0] := Data.Theory.UoM.One
writeMetaTyVar
  s_aaJQ[fuv:0] :: Data.Theory.UoM.Unit := Data.Theory.UoM.One
Unflattening 1 {}
unflatten_eq 2
  [WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                        GHC.Prim.~#
                        (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)
Unflattening 2
  {[WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CTyEqCan)}
Unflattening 3 {}
Unflattening done
  {[WD] hole{aaJY} {2}:: (s0_aaJQ[fuv:0] :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         (s1_aaJU[fuv:0] :: Data.Theory.UoM.Unit) (CNonCanonical)}
zonkSimples done:
  {[WD] hole{aaJY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         ((Data.Theory.UoM.Base "m"
                           Data.Theory.UoM./: Data.Theory.UoM.Base
                                                "m") :: Data.Theory.UoM.Unit) (CNonCanonical)}
zonkSimples done:
  {[WD] hole{aaJY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         ((Data.Theory.UoM.Base "m"
                           Data.Theory.UoM./: Data.Theory.UoM.Base
                                                "m") :: Data.Theory.UoM.Unit) (CNonCanonical)}
tcPluginSolve start thoralf-uom-plugin
  given   = []
  derived = []
  wanted  = [[WD] hole{aaJY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   ((Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.Theory.UoM.Base
                                                          "m") :: Data.Theory.UoM.Unit) (CNonCanonical)]
thoralf-solve gsConvCts Just [ ] [] []
thoralf-solve wsConvCts
  Just [ (= ((as const (Array String Int)) 0) ((_ map (- (Int Int) Int)) (store base "m" n1) (store base "m" n1))) ] [[WD] hole{aaJY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                                                                                                                            GHC.Prim.~#
                                                                                                                                            ((Data.Theory.UoM.Base
                                                                                                                                                "m"
                                                                                                                                              Data.Theory.UoM./: Data.Theory.UoM.Base
                                                                                                                                                                   "m") :: Data.Theory.UoM.Unit) (CNonCanonical)] []
thoralf-solve decls []
thoralf-solve decls filtered []
thoralf-solve givens []
thoralf-solve givens filtered []
thoralf-solve wanteds
  [[WD] hole{aaJY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         ((Data.Theory.UoM.Base "m"
                           Data.Theory.UoM./: Data.Theory.UoM.Base
                                                "m") :: Data.Theory.UoM.Unit) (CNonCanonical)]
thoralf-solve wanteds filtered
  [[WD] hole{aaJY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                         GHC.Prim.~#
                         ((Data.Theory.UoM.Base "m"
                           Data.Theory.UoM./: Data.Theory.UoM.Base
                                                "m") :: Data.Theory.UoM.Unit) (CNonCanonical)]
thoralf-solve simplified given sexprs []
thoralf-solve simplified wanteds
  [(CO U(plugin:thoralf, Data.Theory.UoM.One, Data.Theory.UoM.Base
                                                "m"
                                              Data.Theory.UoM./: Data.Theory.UoM.Base "m")_N,
    [WD] hole{aaJY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                          GHC.Prim.~#
                          ((Data.Theory.UoM.Base "m"
                            Data.Theory.UoM./: Data.Theory.UoM.Base
                                                 "m") :: Data.Theory.UoM.Unit) (CNonCanonical))]
tcPluginSolve ok thoralf-uom-plugin
  solved = [(CO U(plugin:thoralf, Data.Theory.UoM.One, Data.Theory.UoM.Base
                                                         "m"
                                                       Data.Theory.UoM./: Data.Theory.UoM.Base
                                                                            "m")_N,
             [WD] hole{aaJY} {2}:: (Data.Theory.UoM.One :: Data.Theory.UoM.Unit)
                                   GHC.Prim.~#
                                   ((Data.Theory.UoM.Base "m"
                                     Data.Theory.UoM./: Data.Theory.UoM.Base
                                                          "m") :: Data.Theory.UoM.Unit) (CNonCanonical))]
  new    = []
tcPluginSolve start uom-eq-plugin
  given   = []
  derived = []
  wanted  = []
tcPluginSolve ok uom-eq-plugin
  solved = []
  new    = []
tcPluginSolve start uom-unpack-plugin
  given   = []
  derived = []
  wanted  = []
tcPluginSolve ok uom-unpack-plugin
  solved = []
  new    = []
Filling coercion hole
  aaJY := U(plugin:thoralf, Data.Theory.UoM.One, Data.Theory.UoM.Base
                                                   "m"
                                                 Data.Theory.UoM./: Data.Theory.UoM.Base "m")_N
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {[W] $d~_a9Hu
                        = $d~_aaJW `cast` ((~)
                                             <Data.Theory.UoM.Unit>_N
                                             (Sym {aaJR})
                                             (Trans
                                                  (Sym {aaJV})
                                                  (Sym (Trans
                                                            (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                            {aaJT})
                                                   Data.Theory.UoM./: Sym (Trans
                                                                               (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                                               {aaJT}))_N))_R,
                      [W] $d~_aaJW
                        = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJQ[fuv:0],
                                                      s0_aaJU[fuv:0]]
                                                    [$d~~_aaJX],
                      [W] $d~~_aaJX
                        = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                          s0_aaJQ[fuv:0], s0_aaJU[fuv:0]]
                                        [CO U(hole:{aaJY}, s0_aaJQ[fuv:0], s0_aaJU[fuv:0])_N],
                      [W] $d~_a9Hv
                        = $d~_aaJZ `cast` ((~)
                                             <Data.Theory.UoM.Unit>_N
                                             (Sym {aaJT})
                                             (Sym (Trans
                                                       (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                       {aaJT})))_R,
                      [W] $d~_aaJZ
                        = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJS[fuv:0],
                                                      s0_aaJS[fuv:0]]
                                                    [$d~~_aaK0],
                      [W] $d~~_aaK0
                        = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                          s0_aaJS[fuv:0], s0_aaJS[fuv:0]]
                                        [CO <s0_aaJS[fuv:0]>_N],
                      [W] $dHasCanonicalBaseUnit_a9Hs
                        = UnitDefs.$fHasCanonicalBaseUnit"m" @[] []}
getNoGivenEqs
  False
  {Unsolved goals = 0}
  {}
floatEqualities
  Skols = [proxy_a9Ho[sk:4]]
  Simples = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus 2
  []
  ([a9Hu :-> [W] $d~_a9Hu
               = $d~_aaJW `cast` ((~)
                                    <Data.Theory.UoM.Unit>_N
                                    (Sym {aaJR})
                                    (Trans
                                         (Sym {aaJV})
                                         (Sym (Trans (UnitDefs.R:CanonicalBaseUnit"m"[0]) {aaJT})
                                          Data.Theory.UoM./: Sym (Trans
                                                                      (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                                      {aaJT}))_N))_R,
    aaJW :-> [W] $d~_aaJW
               = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJQ[fuv:0],
                                             s0_aaJU[fuv:0]]
                                           [$d~~_aaJX],
    aaJX :-> [W] $d~~_aaJX
               = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                 s0_aaJQ[fuv:0], s0_aaJU[fuv:0]]
                               [CO U(hole:{aaJY}, s0_aaJQ[fuv:0], s0_aaJU[fuv:0])_N],
    a9Hv :-> [W] $d~_a9Hv
               = $d~_aaJZ `cast` ((~)
                                    <Data.Theory.UoM.Unit>_N
                                    (Sym {aaJT})
                                    (Sym (Trans (UnitDefs.R:CanonicalBaseUnit"m"[0]) {aaJT})))_R,
    aaJZ :-> [W] $d~_aaJZ
               = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJS[fuv:0],
                                             s0_aaJS[fuv:0]]
                                           [$d~~_aaK0],
    aaK0 :-> [W] $d~~_aaK0
               = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                 s0_aaJS[fuv:0], s0_aaJS[fuv:0]]
                               [CO <s0_aaJS[fuv:0]>_N],
    a9Hs :-> [W] $dHasCanonicalBaseUnit_a9Hs
               = UnitDefs.$fHasCanonicalBaseUnit"m" @[] []],
   [])
  []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {[W] $d~_a9Hu
                           = $d~_aaJW `cast` ((~)
                                                <Data.Theory.UoM.Unit>_N
                                                (Sym {aaJR})
                                                (Trans
                                                     (Sym {aaJV})
                                                     (Sym (Trans
                                                               (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                               {aaJT})
                                                      Data.Theory.UoM./: Sym (Trans
                                                                                  (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                                                  {aaJT}))_N))_R,
                         [W] $d~_aaJW
                           = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJQ[fuv:0],
                                                         s0_aaJU[fuv:0]]
                                                       [$d~~_aaJX],
                         [W] $d~~_aaJX
                           = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                             s0_aaJQ[fuv:0], s0_aaJU[fuv:0]]
                                           [CO U(hole:{aaJY}, s0_aaJQ[fuv:0], s0_aaJU[fuv:0])_N],
                         [W] $d~_a9Hv
                           = $d~_aaJZ `cast` ((~)
                                                <Data.Theory.UoM.Unit>_N
                                                (Sym {aaJT})
                                                (Sym (Trans
                                                          (UnitDefs.R:CanonicalBaseUnit"m"[0])
                                                          {aaJT})))_R,
                         [W] $d~_aaJZ
                           = Data.Type.Equality.$f~kab @[Data.Theory.UoM.Unit, s0_aaJS[fuv:0],
                                                         s0_aaJS[fuv:0]]
                                                       [$d~~_aaK0],
                         [W] $d~~_aaK0
                           = GHC.Types.Eq# @[Data.Theory.UoM.Unit, Data.Theory.UoM.Unit,
                                             s0_aaJS[fuv:0], s0_aaJS[fuv:0]]
                                           [CO <s0_aaJS[fuv:0]>_N],
                         [W] $dHasCanonicalBaseUnit_a9Hs
                           = UnitDefs.$fHasCanonicalBaseUnit"m" @[] []}
  implication tvcs = []
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Nothing}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
getNoGivenEqs
  False
  {Unsolved goals = 0}
  {}
floatEqualities
  Skols = []
  Simples = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus 2
  []
  ([], [])
  []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {}
  implication tvcs = []
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Nothing, Nothing}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
getNoGivenEqs
  False
  {Unsolved goals = 0}
  {}
floatEqualities
  Skols = []
  Simples = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus 2
  []
  ([], [])
  []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {}
  implication tvcs = []
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Nothing, Nothing, Nothing}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
Constraint solver steps = 72
End simplifyTop }
reportUnsolved {
newTcEvBinds unique = aaK2
reportUnsolved }
reportUnsolved (unsafe overlapping) {
reportUnsolved (unsafe overlapping) }
mkTypeableBinds []
Tc9
Tc10
Tc11
tcPluginStop thoralf-uom-plugin
tcPluginStop uom-eq-plugin
tcPluginStop uom-unpack-plugin
[2 of 2] Compiling Main             ( test-suite-force/Tests.hs, /Users/pdejoux/dev/src/blockscope/plugins-for-blobs/dist-newstyle/build/x86_64-osx/ghc-8.2.2/thoralf-plugin-uom-0.1.0.0/t/force/build/force/force-tmp/Main.o )
newTcEvBinds unique = aaOi
tcPluginInit thoralf-uom-plugin
tcPluginInit uom-eq-plugin
tcPluginInit uom-unpack-plugin
checkForConflicts
  []
  type GHC.Generics.Rep (Data.Graph.SCC vertex)
checkForConflicts
  []
  type GHC.Generics.Rep1 Data.Graph.SCC
checkForConflicts
  []
  type GHC.Generics.Rep pretty-1.1.3.3:Text.PrettyPrint.HughesPJ.Doc
checkForConflicts
  []
  type GHC.Generics.Rep
         ghc-boot-th-8.2.2:GHC.ForeignSrcLang.Type.ForeignSrcLang
checkForConflicts
  []
  type GHC.Generics.Rep
         ghc-boot-th-8.2.2:GHC.LanguageExtensions.Type.Extension
checkForConflicts
  []
  type GHC.Generics.Rep (Text.Parse.Units.UnitExp pre u)
checkForConflicts
  []
  type GHC.Generics.Rep (Text.Parse.Units.SymbolTable pre u)
checkForConflicts
  []
  type GHC.Exts.Item text-1.2.5.0:Data.Text.Internal.Lazy.Text
checkForConflicts
  []
  type GHC.Exts.Item text-1.2.5.0:Data.Text.Internal.Text
checkForConflicts
  []
  type GHC.Generics.Rep (Data.Graph.SCC vertex)
checkForConflicts
  []
  type GHC.Generics.Rep1 Data.Graph.SCC
checkForConflicts
  []
  type GHC.Generics.Rep (Data.Graph.SCC vertex)
checkForConflicts
  []
  type GHC.Generics.Rep1 Data.Graph.SCC
checkForConflicts
  []
  type GHC.Generics.Rep (tagged-0.8.6.1:Data.Tagged.Tagged s b)
checkForConflicts
  []
  type GHC.Generics.Rep1 (tagged-0.8.6.1:Data.Tagged.Tagged s)
checkForConflicts
  []
  type GHC.Generics.Rep Test.Tasty.Patterns.Types.Expr
checkForConflicts
  []
  type GHC.Generics.Rep tasty-1.4.2.1:Test.Tasty.Core.Outcome
checkForConflicts
  []
  type GHC.Generics.Rep pretty-1.1.3.3:Text.PrettyPrint.HughesPJ.Doc
checkForConflicts
  []
  type GHC.Generics.Rep Test.Tasty.Patterns.Types.Expr
checkForConflicts
  []
  type GHC.Generics.Rep tasty-1.4.2.1:Test.Tasty.Core.Outcome
checkForConflicts
  []
  type GHC.Generics.Rep
         ghc-boot-th-8.2.2:GHC.ForeignSrcLang.Type.ForeignSrcLang
checkForConflicts
  []
  type GHC.Generics.Rep Test.Tasty.Patterns.Types.Expr
checkForConflicts
  []
  type GHC.Generics.Rep tasty-1.4.2.1:Test.Tasty.Core.Outcome
checkForConflicts
  []
  type GHC.Generics.Rep
         ghc-boot-th-8.2.2:GHC.LanguageExtensions.Type.Extension
checkForConflicts
  []
  type GHC.Generics.Rep Test.Tasty.Patterns.Types.Expr
checkForConflicts
  []
  type GHC.Generics.Rep tasty-1.4.2.1:Test.Tasty.Core.Outcome
checkForConflicts
  []
  type GHC.Generics.Rep clock-0.8.2:System.Clock.Clock
checkForConflicts
  []
  type GHC.Generics.Rep clock-0.8.2:System.Clock.TimeSpec
checkForConflicts
  []
  type GHC.Generics.Rep pretty-1.1.3.3:Text.PrettyPrint.HughesPJ.Doc
checkForConflicts
  []
  type GHC.Generics.Rep
         ghc-boot-th-8.2.2:GHC.ForeignSrcLang.Type.ForeignSrcLang
checkForConflicts
  []
  type GHC.Generics.Rep
         ghc-boot-th-8.2.2:GHC.LanguageExtensions.Type.Extension
checkForConflicts
  []
  type GHC.Generics.Rep (Text.Parse.Units.UnitExp pre u)
checkForConflicts
  []
  type GHC.Generics.Rep (Text.Parse.Units.SymbolTable pre u)
checkForConflicts
  []
  type GHC.Exts.Item text-1.2.5.0:Data.Text.Internal.Lazy.Text
checkForConflicts
  []
  type GHC.Exts.Item text-1.2.5.0:Data.Text.Internal.Text
checkForConflicts
  []
  type GHC.Generics.Rep clock-0.8.2:System.Clock.Clock
checkForConflicts
  []
  type GHC.Generics.Rep clock-0.8.2:System.Clock.TimeSpec
checkForConflicts
  []
  type GHC.Generics.Rep clock-0.8.2:System.Clock.Clock
checkForConflicts
  []
  type GHC.Generics.Rep clock-0.8.2:System.Clock.TimeSpec
checkForConflicts
  []
  type GHC.Generics.Rep (tagged-0.8.6.1:Data.Tagged.Tagged s b)
checkForConflicts
  []
  type GHC.Generics.Rep1 (tagged-0.8.6.1:Data.Tagged.Tagged s)
checkForConflicts
  []
  type GHC.Generics.Rep Test.Tasty.Patterns.Types.Expr
checkForConflicts
  []
  type GHC.Generics.Rep tasty-1.4.2.1:Test.Tasty.Core.Outcome
checkForConflicts
  []
  type GHC.Exts.Item text-1.2.5.0:Data.Text.Internal.Lazy.Text
checkForConflicts
  []
  type GHC.Exts.Item text-1.2.5.0:Data.Text.Internal.Text
checkForConflicts
  []
  type GHC.Exts.Item text-1.2.5.0:Data.Text.Internal.Lazy.Text
checkForConflicts
  []
  type GHC.Exts.Item text-1.2.5.0:Data.Text.Internal.Text
checkForConflicts
  []
  type GHC.Exts.Item text-1.2.5.0:Data.Text.Internal.Lazy.Text
checkForConflicts
  []
  type GHC.Exts.Item text-1.2.5.0:Data.Text.Internal.Text
checkForConflicts
  []
  type GHC.Generics.Rep (tagged-0.8.6.1:Data.Tagged.Tagged s b)
checkForConflicts
  []
  type GHC.Generics.Rep1 (tagged-0.8.6.1:Data.Tagged.Tagged s)
checkForConflicts
  []
  type GHC.Generics.Rep Test.Tasty.Patterns.Types.Expr
checkForConflicts
  []
  type GHC.Generics.Rep tasty-1.4.2.1:Test.Tasty.Core.Outcome
checkForConflicts
  []
  type GHC.Generics.Rep (tagged-0.8.6.1:Data.Tagged.Tagged s b)
checkForConflicts
  []
  type GHC.Generics.Rep1 (tagged-0.8.6.1:Data.Tagged.Tagged s)
checkForConflicts
  []
  type GHC.Generics.Rep Test.Tasty.Patterns.Types.Expr
checkForConflicts
  []
  type GHC.Generics.Rep tasty-1.4.2.1:Test.Tasty.Core.Outcome
tcPolyExpr Check{Language.Haskell.TH.Lib.TypeQ}
tcPolyExprNC Check{Language.Haskell.TH.Lib.TypeQ}
tcSkolemise
tcInferId
  Language.Haskell.TH.Quote.quoteType :: Language.Haskell.TH.Quote.QuasiQuoter
                                         -> String
                                         -> Language.Haskell.TH.Syntax.Q
                                              Language.Haskell.TH.Syntax.Type
tcPolyExprNC Check{Language.Haskell.TH.Quote.QuasiQuoter}
tcSkolemise
tcInferId u :: Language.Haskell.TH.Quote.QuasiQuoter
tcCheckId
  u
  Language.Haskell.TH.Quote.QuasiQuoter
  Check{Language.Haskell.TH.Quote.QuasiQuoter}
tcWrapResult
  Actual:   Language.Haskell.TH.Quote.QuasiQuoter
  Expected: Check{Language.Haskell.TH.Quote.QuasiQuoter}
tc_sub_type_ds
  ty_actual   = Language.Haskell.TH.Quote.QuasiQuoter
  ty_expected = Language.Haskell.TH.Quote.QuasiQuoter
deeply_instantiate final subst
  origin: arising from a use of ‘u’
  type: Language.Haskell.TH.Quote.QuasiQuoter
  new type: Language.Haskell.TH.Quote.QuasiQuoter
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Language.Haskell.TH.Quote.QuasiQuoter
  ~
  Language.Haskell.TH.Quote.QuasiQuoter
  arising from a type equality Language.Haskell.TH.Quote.QuasiQuoter
                               ~
                               Language.Haskell.TH.Quote.QuasiQuoter
u_tys yields no coercion
tcPolyExprNC Check{String}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{String}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = String
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ String
  arising from a type equality [Char] ~ String
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ String
u_tys yields no coercion
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = Language.Haskell.TH.Syntax.Q
                  Language.Haskell.TH.Syntax.Type
  ty_expected = Language.Haskell.TH.Lib.TypeQ
deeply_instantiate final subst
  origin: arising from a use of ‘Language.Haskell.TH.Quote.quoteType’
  type: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
  new type: Language.Haskell.TH.Syntax.Q
              Language.Haskell.TH.Syntax.Type
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
  ~
  Language.Haskell.TH.Lib.TypeQ
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 Language.Haskell.TH.Syntax.Type
                               ~
                               Language.Haskell.TH.Lib.TypeQ
u_tys
  tclvl 1
  Language.Haskell.TH.Syntax.Type ~ Language.Haskell.TH.Syntax.Type
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 Language.Haskell.TH.Syntax.Type
                               ~
                               Language.Haskell.TH.Lib.TypeQ
u_tys yields no coercion
u_tys yields no coercion
simplifyTop { wanted =  WC {}
newTcEvBinds unique = abXf
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyTop }
reportUnsolved {
newTcEvBinds unique = abXg
reportUnsolved }
reportUnsolved (unsafe overlapping) {
reportUnsolved (unsafe overlapping) }
About to run Language.Haskell.TH.Quote.quoteType u " N "
About to run (desugared)
  Language.Haskell.TH.Quote.quoteType
    u (GHC.CString.unpackCString# " N "#)
Got TH result: Data.UnitsOfMeasure.Syntax.MkUnit "N"
Got HsSyn result: MkUnit "N"
tcPolyExpr Check{Language.Haskell.TH.Lib.TypeQ}
tcPolyExprNC Check{Language.Haskell.TH.Lib.TypeQ}
tcSkolemise
tcInferId
  Language.Haskell.TH.Quote.quoteType :: Language.Haskell.TH.Quote.QuasiQuoter
                                         -> String
                                         -> Language.Haskell.TH.Syntax.Q
                                              Language.Haskell.TH.Syntax.Type
tcPolyExprNC Check{Language.Haskell.TH.Quote.QuasiQuoter}
tcSkolemise
tcInferId u :: Language.Haskell.TH.Quote.QuasiQuoter
tcCheckId
  u
  Language.Haskell.TH.Quote.QuasiQuoter
  Check{Language.Haskell.TH.Quote.QuasiQuoter}
tcWrapResult
  Actual:   Language.Haskell.TH.Quote.QuasiQuoter
  Expected: Check{Language.Haskell.TH.Quote.QuasiQuoter}
tc_sub_type_ds
  ty_actual   = Language.Haskell.TH.Quote.QuasiQuoter
  ty_expected = Language.Haskell.TH.Quote.QuasiQuoter
deeply_instantiate final subst
  origin: arising from a use of ‘u’
  type: Language.Haskell.TH.Quote.QuasiQuoter
  new type: Language.Haskell.TH.Quote.QuasiQuoter
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Language.Haskell.TH.Quote.QuasiQuoter
  ~
  Language.Haskell.TH.Quote.QuasiQuoter
  arising from a type equality Language.Haskell.TH.Quote.QuasiQuoter
                               ~
                               Language.Haskell.TH.Quote.QuasiQuoter
u_tys yields no coercion
tcPolyExprNC Check{String}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{String}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = String
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ String
  arising from a type equality [Char] ~ String
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ String
u_tys yields no coercion
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = Language.Haskell.TH.Syntax.Q
                  Language.Haskell.TH.Syntax.Type
  ty_expected = Language.Haskell.TH.Lib.TypeQ
deeply_instantiate final subst
  origin: arising from a use of ‘Language.Haskell.TH.Quote.quoteType’
  type: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
  new type: Language.Haskell.TH.Syntax.Q
              Language.Haskell.TH.Syntax.Type
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
  ~
  Language.Haskell.TH.Lib.TypeQ
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 Language.Haskell.TH.Syntax.Type
                               ~
                               Language.Haskell.TH.Lib.TypeQ
u_tys
  tclvl 1
  Language.Haskell.TH.Syntax.Type ~ Language.Haskell.TH.Syntax.Type
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 Language.Haskell.TH.Syntax.Type
                               ~
                               Language.Haskell.TH.Lib.TypeQ
u_tys yields no coercion
u_tys yields no coercion
simplifyTop { wanted =  WC {}
newTcEvBinds unique = abXr
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyTop }
reportUnsolved {
newTcEvBinds unique = abXs
reportUnsolved }
reportUnsolved (unsafe overlapping) {
reportUnsolved (unsafe overlapping) }
About to run Language.Haskell.TH.Quote.quoteType u " m/s^2 "
About to run (desugared)
  Language.Haskell.TH.Quote.quoteType
    u (GHC.CString.unpackCString# " m/s^2 "#)
Got TH result:
  Data.Theory.UoM./: (Data.UnitsOfMeasure.Syntax.MkUnit "m")
                   (Data.Theory.UoM.^: (Data.UnitsOfMeasure.Syntax.MkUnit "s") 2)
Got HsSyn result: (/:) (MkUnit "m") ((^:) (MkUnit "s") 2)
tcPolyExpr Check{Language.Haskell.TH.Lib.ExpQ}
tcPolyExprNC Check{Language.Haskell.TH.Lib.ExpQ}
tcSkolemise
tcInferId
  Language.Haskell.TH.Quote.quoteExp :: Language.Haskell.TH.Quote.QuasiQuoter
                                        -> String
                                        -> Language.Haskell.TH.Syntax.Q
                                             Language.Haskell.TH.Syntax.Exp
tcPolyExprNC Check{Language.Haskell.TH.Quote.QuasiQuoter}
tcSkolemise
tcInferId u :: Language.Haskell.TH.Quote.QuasiQuoter
tcCheckId
  u
  Language.Haskell.TH.Quote.QuasiQuoter
  Check{Language.Haskell.TH.Quote.QuasiQuoter}
tcWrapResult
  Actual:   Language.Haskell.TH.Quote.QuasiQuoter
  Expected: Check{Language.Haskell.TH.Quote.QuasiQuoter}
tc_sub_type_ds
  ty_actual   = Language.Haskell.TH.Quote.QuasiQuoter
  ty_expected = Language.Haskell.TH.Quote.QuasiQuoter
deeply_instantiate final subst
  origin: arising from a use of ‘u’
  type: Language.Haskell.TH.Quote.QuasiQuoter
  new type: Language.Haskell.TH.Quote.QuasiQuoter
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Language.Haskell.TH.Quote.QuasiQuoter
  ~
  Language.Haskell.TH.Quote.QuasiQuoter
  arising from a type equality Language.Haskell.TH.Quote.QuasiQuoter
                               ~
                               Language.Haskell.TH.Quote.QuasiQuoter
u_tys yields no coercion
tcPolyExprNC Check{String}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{String}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = String
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ String
  arising from a type equality [Char] ~ String
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ String
u_tys yields no coercion
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = Language.Haskell.TH.Syntax.Q
                  Language.Haskell.TH.Syntax.Exp
  ty_expected = Language.Haskell.TH.Lib.ExpQ
deeply_instantiate final subst
  origin: arising from a use of ‘Language.Haskell.TH.Quote.quoteExp’
  type: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
  new type: Language.Haskell.TH.Syntax.Q
              Language.Haskell.TH.Syntax.Exp
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
  ~
  Language.Haskell.TH.Lib.ExpQ
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 Language.Haskell.TH.Syntax.Exp
                               ~
                               Language.Haskell.TH.Lib.ExpQ
u_tys
  tclvl 1
  Language.Haskell.TH.Syntax.Exp ~ Language.Haskell.TH.Syntax.Exp
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 Language.Haskell.TH.Syntax.Exp
                               ~
                               Language.Haskell.TH.Lib.ExpQ
u_tys yields no coercion
u_tys yields no coercion
simplifyTop { wanted =  WC {}
newTcEvBinds unique = abYN
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyTop }
reportUnsolved {
newTcEvBinds unique = abYO
reportUnsolved }
reportUnsolved (unsafe overlapping) {
reportUnsolved (unsafe overlapping) }
About to run Language.Haskell.TH.Quote.quoteExp u " 65 kg "
About to run (desugared)
  Language.Haskell.TH.Quote.quoteExp
    u (GHC.CString.unpackCString# " 65 kg "#)
Got TH result:
  (Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity :: a_0 ->
                                                   Data.UnitsOfMeasure.Unsafe.Quantity.Quantity a_0
                                                                                                (Data.UnitsOfMeasure.Syntax.MkUnit "kg")) 65
Got HsSyn result:
  (Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
     a_abYY -> Quantity a_abYY (MkUnit "kg"))
    65
tcPolyExpr Check{Language.Haskell.TH.Lib.ExpQ}
tcPolyExprNC Check{Language.Haskell.TH.Lib.ExpQ}
tcSkolemise
tcInferId
  Language.Haskell.TH.Quote.quoteExp :: Language.Haskell.TH.Quote.QuasiQuoter
                                        -> String
                                        -> Language.Haskell.TH.Syntax.Q
                                             Language.Haskell.TH.Syntax.Exp
tcPolyExprNC Check{Language.Haskell.TH.Quote.QuasiQuoter}
tcSkolemise
tcInferId u :: Language.Haskell.TH.Quote.QuasiQuoter
tcCheckId
  u
  Language.Haskell.TH.Quote.QuasiQuoter
  Check{Language.Haskell.TH.Quote.QuasiQuoter}
tcWrapResult
  Actual:   Language.Haskell.TH.Quote.QuasiQuoter
  Expected: Check{Language.Haskell.TH.Quote.QuasiQuoter}
tc_sub_type_ds
  ty_actual   = Language.Haskell.TH.Quote.QuasiQuoter
  ty_expected = Language.Haskell.TH.Quote.QuasiQuoter
deeply_instantiate final subst
  origin: arising from a use of ‘u’
  type: Language.Haskell.TH.Quote.QuasiQuoter
  new type: Language.Haskell.TH.Quote.QuasiQuoter
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Language.Haskell.TH.Quote.QuasiQuoter
  ~
  Language.Haskell.TH.Quote.QuasiQuoter
  arising from a type equality Language.Haskell.TH.Quote.QuasiQuoter
                               ~
                               Language.Haskell.TH.Quote.QuasiQuoter
u_tys yields no coercion
tcPolyExprNC Check{String}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{String}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = String
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ String
  arising from a type equality [Char] ~ String
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ String
u_tys yields no coercion
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = Language.Haskell.TH.Syntax.Q
                  Language.Haskell.TH.Syntax.Exp
  ty_expected = Language.Haskell.TH.Lib.ExpQ
deeply_instantiate final subst
  origin: arising from a use of ‘Language.Haskell.TH.Quote.quoteExp’
  type: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
  new type: Language.Haskell.TH.Syntax.Q
              Language.Haskell.TH.Syntax.Exp
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
  ~
  Language.Haskell.TH.Lib.ExpQ
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 Language.Haskell.TH.Syntax.Exp
                               ~
                               Language.Haskell.TH.Lib.ExpQ
u_tys
  tclvl 1
  Language.Haskell.TH.Syntax.Exp ~ Language.Haskell.TH.Syntax.Exp
  arising from a type equality Language.Haskell.TH.Syntax.Q
                                 Language.Haskell.TH.Syntax.Exp
                               ~
                               Language.Haskell.TH.Lib.ExpQ
u_tys yields no coercion
u_tys yields no coercion
simplifyTop { wanted =  WC {}
newTcEvBinds unique = abZ0
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyTop }
reportUnsolved {
newTcEvBinds unique = abZ1
reportUnsolved }
reportUnsolved (unsafe overlapping) {
reportUnsolved (unsafe overlapping) }
About to run Language.Haskell.TH.Quote.quoteExp u " 9.808 m/(s*s) "
About to run (desugared)
  Language.Haskell.TH.Quote.quoteExp
    u (GHC.CString.unpackCString# " 9.808 m/(s*s) "#)
Got TH result:
  (Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity :: a_0 ->
                                                   Data.UnitsOfMeasure.Unsafe.Quantity.Quantity a_0
                                                                                                (Data.Theory.UoM./: (Data.UnitsOfMeasure.Syntax.MkUnit "m")
                                                                                                                    (Data.Theory.UoM.*: (Data.UnitsOfMeasure.Syntax.MkUnit "s")
                                                                                                                                        (Data.UnitsOfMeasure.Syntax.MkUnit "s")))) (1226 / 125)
Got HsSyn result:
  (Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
     a_abZ3
     -> Quantity a_abZ3 ((/:) (MkUnit "m") ((*:) (MkUnit "s") (MkUnit "s"))))
    9.808
Tc2 (src)
Tc3
txExtendKindEnvList []
txExtendKindEnvList []
tcDeriving False
tcDeriving 1 []
rnd
Adding instances:
Tc3b
Tc3c
tcSemigroupWarnings
Tc4
Tc4a
Tc5
txExtendKindEnvList []
decideKindGeneralisationPlan
  TestTree
  should gen? True
env2 []
lk1 TestTree
tcTyVar2a
  TestTree
  *
u_tys
  tclvl 1
  * ~ TYPE t0_ac2T[tau:1]
  arising from a type equality * ~ TYPE t0_ac2T[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_ac2T[tau:1]
  arising from a type equality * ~ TYPE t0_ac2T[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_ac2T[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_ac2T[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t0_ac2T[tau:1]
  <*>_N
tcImplicitTKBndrs
  []
  []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = ac3e
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = ac3f
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
checkValidType TestTree :: *
Ambiguity check for TestTree
tcSubType_NC
  the type signature for ‘tests’
  TestTree
  TestTree
tc_sub_tc_type (general case)
  ty_actual   = TestTree
  ty_expected = TestTree
tcSkolemise
tc_sub_type_ds
  ty_actual   = TestTree
  ty_expected = TestTree
deeply_instantiate final subst
  origin: arising from a type equality TestTree ~ TestTree
  type: TestTree
  new type: TestTree
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  TestTree ~ TestTree
  arising from a type equality TestTree ~ TestTree
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  TestTree
  wanted =  WC {}
newTcEvBinds unique = ac3g
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = ac3h
reportUnsolved(ambig) }
Done ambiguity check for TestTree
checkValidType done TestTree :: *
decideKindGeneralisationPlan
  IO ()
  should gen? True
env2 []
lk1 IO
tcTyVar2a
  IO
  * -> *
tc_infer_args (vis)
  [anon] *
  ()
tc_hs_type tuple []
finish_tuple
  *
  []
  *
u_tys
  tclvl 1
  * ~ *
  arising from a type equality * ~ *
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a type equality * ~ *
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  *
  <*>_N
u_tys
  tclvl 1
  * ~ TYPE t0_ac3i[tau:1]
  arising from a type equality * ~ TYPE t0_ac3i[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_ac3i[tau:1]
  arising from a type equality * ~ TYPE t0_ac3i[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_ac3i[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_ac3i[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t0_ac3i[tau:1]
  <*>_N
tcImplicitTKBndrs
  []
  []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = achL
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = achM
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
checkValidType IO () :: *
Ambiguity check for IO ()
tcSubType_NC
  the type signature for ‘main’
  IO ()
  IO ()
tc_sub_tc_type (general case)
  ty_actual   = IO ()
  ty_expected = IO ()
tcSkolemise
tc_sub_type_ds
  ty_actual   = IO ()
  ty_expected = IO ()
deeply_instantiate final subst
  origin: arising from a type equality IO () ~ IO ()
  type: IO ()
  new type: IO ()
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  IO () ~ IO ()
  arising from a type equality IO () ~ IO ()
u_tys
  tclvl 1
  () ~ ()
  arising from a type equality IO () ~ IO ()
u_tys yields no coercion
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  IO ()
  wanted =  WC {}
newTcEvBinds unique = achN
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = achO
reportUnsolved(ambig) }
Done ambiguity check for IO ()
checkValidType done IO () :: *
decideKindGeneralisationPlan
  Quantity Double (MkUnit "N")
  should gen? True
env2 []
lk1 Quantity
tcTyVar2a
  Quantity
  * -> Unit -> *
tc_infer_args (vis)
  [anon] *
  Double
lk1 Double
tcTyVar2a
  Double
  *
u_tys
  tclvl 1
  * ~ *
  arising from a type equality * ~ *
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a type equality * ~ *
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  *
  <*>_N
tc_infer_args (vis)
  [anon] Unit
  (MkUnit "N")
lk1 MkUnit
tcTyVar2b
  MkUnit :: GHC.Types.Symbol -> Unit
  GHC.Types.Symbol -> Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "N"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Unit ~ Unit
  arising from a type equality Unit ~ Unit
u_tys yields no coercion
checkExpectedKind
  Unit
  Unit
  <Unit>_N
u_tys
  tclvl 1
  * ~ TYPE t0_achP[tau:1]
  arising from a type equality * ~ TYPE t0_achP[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_achP[tau:1]
  arising from a type equality * ~ TYPE t0_achP[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_achP[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_achP[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t0_achP[tau:1]
  <*>_N
tcImplicitTKBndrs
  []
  []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = achQ
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = achR
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
checkValidType Quantity Double (MkUnit "N") :: *
Ambiguity check for Quantity Double (MkUnit "N")
tcSubType_NC
  the type signature for ‘forceOnGround’
  Quantity Double (MkUnit "N")
  Quantity Double (MkUnit "N")
tc_sub_tc_type (general case)
  ty_actual   = Quantity Double (MkUnit "N")
  ty_expected = Quantity Double (MkUnit "N")
tcSkolemise
tc_sub_type_ds
  ty_actual   = Quantity Double (MkUnit "N")
  ty_expected = Quantity Double (MkUnit "N")
deeply_instantiate final subst
  origin: arising from a type equality Quantity Double (MkUnit "N")
                                       ~
                                       Quantity Double (MkUnit "N")
  type: Quantity Double (MkUnit "N")
  new type: Quantity Double (MkUnit "N")
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Quantity Double (MkUnit "N") ~ Quantity Double (MkUnit "N")
  arising from a type equality Quantity Double (MkUnit "N")
                               ~
                               Quantity Double (MkUnit "N")
u_tys
  tclvl 1
  Double ~ Double
  arising from a type equality Quantity Double (MkUnit "N")
                               ~
                               Quantity Double (MkUnit "N")
u_tys yields no coercion
u_tys
  tclvl 1
  MkUnit "N" ~ MkUnit "N"
  arising from a type equality Quantity Double (MkUnit "N")
                               ~
                               Quantity Double (MkUnit "N")
u_tys yields no coercion
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  Quantity Double (MkUnit "N")
  wanted =  WC {}
newTcEvBinds unique = achS
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = achT
reportUnsolved(ambig) }
Done ambiguity check for Quantity Double (MkUnit "N")
checkValidType done Quantity Double (MkUnit "N") :: *
decideKindGeneralisationPlan
  Quantity Double ((/:) (MkUnit "m") ((^:) (MkUnit "s") 2))
  should gen? True
env2 []
lk1 Quantity
tcTyVar2a
  Quantity
  * -> Unit -> *
tc_infer_args (vis)
  [anon] *
  Double
lk1 Double
tcTyVar2a
  Double
  *
u_tys
  tclvl 1
  * ~ *
  arising from a type equality * ~ *
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a type equality * ~ *
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  *
  <*>_N
tc_infer_args (vis)
  [anon] Unit
  ((/:) (MkUnit "m") ((^:) (MkUnit "s") 2))
lk1 /:
tcTyVar2b
  /: :: Unit -> Unit -> Unit
  Unit -> Unit -> Unit
tc_infer_args (vis)
  [anon] Unit
  (MkUnit "m")
lk1 MkUnit
tcTyVar2b
  MkUnit :: GHC.Types.Symbol -> Unit
  GHC.Types.Symbol -> Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "m"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Unit ~ Unit
  arising from a type equality Unit ~ Unit
u_tys yields no coercion
checkExpectedKind
  Unit
  Unit
  <Unit>_N
tc_infer_args (vis)
  [anon] Unit
  ((^:) (MkUnit "s") 2)
lk1 ^:
tcTyVar2b
  ^: :: Unit -> GHC.Types.Nat -> Unit
  Unit -> GHC.Types.Nat -> Unit
tc_infer_args (vis)
  [anon] Unit
  (MkUnit "s")
lk1 MkUnit
tcTyVar2b
  MkUnit :: GHC.Types.Symbol -> Unit
  GHC.Types.Symbol -> Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "s"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Unit ~ Unit
  arising from a type equality Unit ~ Unit
u_tys yields no coercion
checkExpectedKind
  Unit
  Unit
  <Unit>_N
tc_infer_args (vis)
  [anon] GHC.Types.Nat
  2
u_tys
  tclvl 1
  GHC.Types.Nat ~ GHC.Types.Nat
  arising from a type equality GHC.Types.Nat ~ GHC.Types.Nat
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Nat
  GHC.Types.Nat
  <GHC.Types.Nat>_N
u_tys
  tclvl 1
  Unit ~ Unit
  arising from a type equality Unit ~ Unit
u_tys yields no coercion
checkExpectedKind
  Unit
  Unit
  <Unit>_N
u_tys
  tclvl 1
  Unit ~ Unit
  arising from a type equality Unit ~ Unit
u_tys yields no coercion
checkExpectedKind
  Unit
  Unit
  <Unit>_N
u_tys
  tclvl 1
  * ~ TYPE t0_achU[tau:1]
  arising from a type equality * ~ TYPE t0_achU[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_achU[tau:1]
  arising from a type equality * ~ TYPE t0_achU[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_achU[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_achU[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t0_achU[tau:1]
  <*>_N
tcImplicitTKBndrs
  []
  []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = achV
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = achW
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
checkValidType
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2)) :: *
Ambiguity check for
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
tcSubType_NC
  the type signature for ‘gravityOnEarth’
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
tc_sub_tc_type (general case)
  ty_actual   = Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  ty_expected = Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
tcSkolemise
tc_sub_type_ds
  ty_actual   = Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  ty_expected = Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
deeply_instantiate final subst
  origin: arising from a type equality Quantity
                                         Double (MkUnit "m" /: (MkUnit "s" ^: 2))
                                       ~
                                       Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  type: Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  new type: Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  ~
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  arising from a type equality Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2))
                               ~
                               Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
u_tys
  tclvl 1
  Double ~ Double
  arising from a type equality Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2))
                               ~
                               Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
u_tys yields no coercion
u_tys
  tclvl 1
  MkUnit "m" /: (MkUnit "s" ^: 2) ~ MkUnit "m" /: (MkUnit "s" ^: 2)
  arising from a type equality Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2))
                               ~
                               Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
u_tys yields no coercion
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  wanted =  WC {}
newTcEvBinds unique = achX
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = achY
reportUnsolved(ambig) }
Done ambiguity check for
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
checkValidType done
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2)) :: *
decideKindGeneralisationPlan
  Quantity Double (Base "kg")
  should gen? True
env2 []
lk1 Quantity
tcTyVar2a
  Quantity
  * -> Unit -> *
tc_infer_args (vis)
  [anon] *
  Double
lk1 Double
tcTyVar2a
  Double
  *
u_tys
  tclvl 1
  * ~ *
  arising from a type equality * ~ *
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a type equality * ~ *
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  *
  <*>_N
tc_infer_args (vis)
  [anon] Unit
  (Base "kg")
lk1 Base
tcTyVar2b
  Base :: GHC.Types.Symbol -> Unit
  GHC.Types.Symbol -> Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "kg"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Unit ~ Unit
  arising from a type equality Unit ~ Unit
u_tys yields no coercion
checkExpectedKind
  Unit
  Unit
  <Unit>_N
u_tys
  tclvl 1
  * ~ TYPE t0_achZ[tau:1]
  arising from a type equality * ~ TYPE t0_achZ[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_achZ[tau:1]
  arising from a type equality * ~ TYPE t0_achZ[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_achZ[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_achZ[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t0_achZ[tau:1]
  <*>_N
tcImplicitTKBndrs
  []
  []
solveEqualities { wanted =  WC {}
newTcEvBinds unique = aci0
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = aci1
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
checkValidType Quantity Double (Base "kg") :: *
Ambiguity check for Quantity Double (Base "kg")
tcSubType_NC
  the type signature for ‘myMass’
  Quantity Double (Base "kg")
  Quantity Double (Base "kg")
tc_sub_tc_type (general case)
  ty_actual   = Quantity Double (Base "kg")
  ty_expected = Quantity Double (Base "kg")
tcSkolemise
tc_sub_type_ds
  ty_actual   = Quantity Double (Base "kg")
  ty_expected = Quantity Double (Base "kg")
deeply_instantiate final subst
  origin: arising from a type equality Quantity Double (Base "kg")
                                       ~
                                       Quantity Double (Base "kg")
  type: Quantity Double (Base "kg")
  new type: Quantity Double (Base "kg")
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Quantity Double (Base "kg") ~ Quantity Double (Base "kg")
  arising from a type equality Quantity Double (Base "kg")
                               ~
                               Quantity Double (Base "kg")
u_tys
  tclvl 1
  Double ~ Double
  arising from a type equality Quantity Double (Base "kg")
                               ~
                               Quantity Double (Base "kg")
u_tys yields no coercion
u_tys
  tclvl 1
  Base "kg" ~ Base "kg"
  arising from a type equality Quantity Double (Base "kg")
                               ~
                               Quantity Double (Base "kg")
u_tys yields no coercion
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  Quantity Double (Base "kg")
  wanted =  WC {}
newTcEvBinds unique = aci2
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = aci3
reportUnsolved(ambig) }
Done ambiguity check for Quantity Double (Base "kg")
checkValidType done Quantity Double (Base "kg") :: *
env2
  [(tests, Identifier[tests::TestTree, TopLevelLet [] True]),
   (main, Identifier[main::IO (), TopLevelLet [] True]),
   (forceOnGround,
    Identifier[forceOnGround::Quantity
                                Double (MkUnit "N"), TopLevelLet [] True]),
   (gravityOnEarth,
    Identifier[gravityOnEarth::Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2)), TopLevelLet [] True]),
   (myMass,
    Identifier[myMass::Quantity
                         Double (Base "kg"), TopLevelLet [] True])]
------------------------------------------------
Bindings for { [gravityOnEarth]
Generalisation plan
  CheckGen gravityOnEarth :: Quantity
                               Double (MkUnit "m" /: (MkUnit "s" ^: 2))
tcPolyCheck
  gravityOnEarth
  test-suite-force/Tests.hs:35:1-46
tcExtendIdBndrs [gravityOnEarth_aci4[<NotTopLevel>]]
env2 []
tcMatchesFun
  gravityOnEarth_aci4
  Check{Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))}
tcSkolemise
tcBody Check{Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))}
newOpenInferExpType aci5 False 1
decideKindGeneralisationPlan
  a_abZ3
  -> Quantity a_abZ3 ((/:) (MkUnit "m") ((*:) (MkUnit "s") (MkUnit "s")))
  should gen? True
env2 [(a_abZ3, Type variable ‘a_abZ3’ = a_abZ3[sk:1])]
lk1 a_abZ3
u_tys
  tclvl 1
  k0_aci7[tau:1] ~ TYPE t0_aci8[tau:1]
  arising from a type equality k0_aci7[tau:1] ~ TYPE t0_aci8[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from
    k0_aci7[tau:1] ~ TYPE t0_aci8[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    k0_aci7[tau:1] ~ TYPE t0_aci8[tau:1]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar k_aci7[tau:1] :: * := TYPE t0_aci8[tau:1]
u_tys yields no coercion
checkExpectedKind
  k0_aci7[tau:1]
  TYPE t0_aci8[tau:1]
  <TYPE t0_aci8[tau:1]>_N
lk1 Quantity
tcTyVar2a
  Quantity
  * -> Unit -> *
tc_infer_args (vis)
  [anon] *
  a_abZ3
lk1 a_abZ3
u_tys
  tclvl 1
  k0_aci7[tau:1] ~ *
  arising from a type equality k0_aci7[tau:1] ~ *
found filled tyvar k_aci7[tau:1] :-> TYPE t0_aci8[tau:1]
u_tys
  tclvl 1
  t0_aci8[tau:1] ~ 'GHC.Types.LiftedRep
  arising from a type equality k0_aci7[tau:1] ~ *
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_aci8[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_aci8[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  k0_aci7[tau:1]
  *
  <*>_N
tc_infer_args (vis)
  [anon] Unit
  ((/:) (MkUnit "m") ((*:) (MkUnit "s") (MkUnit "s")))
lk1 /:
tcTyVar2b
  /: :: Unit -> Unit -> Unit
  Unit -> Unit -> Unit
tc_infer_args (vis)
  [anon] Unit
  (MkUnit "m")
lk1 MkUnit
tcTyVar2b
  MkUnit :: GHC.Types.Symbol -> Unit
  GHC.Types.Symbol -> Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "m"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Unit ~ Unit
  arising from a type equality Unit ~ Unit
u_tys yields no coercion
checkExpectedKind
  Unit
  Unit
  <Unit>_N
tc_infer_args (vis)
  [anon] Unit
  ((*:) (MkUnit "s") (MkUnit "s"))
lk1 *:
tcTyVar2b
  *: :: Unit -> Unit -> Unit
  Unit -> Unit -> Unit
tc_infer_args (vis)
  [anon] Unit
  (MkUnit "s")
lk1 MkUnit
tcTyVar2b
  MkUnit :: GHC.Types.Symbol -> Unit
  GHC.Types.Symbol -> Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "s"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Unit ~ Unit
  arising from a type equality Unit ~ Unit
u_tys yields no coercion
checkExpectedKind
  Unit
  Unit
  <Unit>_N
tc_infer_args (vis)
  [anon] Unit
  (MkUnit "s")
lk1 MkUnit
tcTyVar2b
  MkUnit :: GHC.Types.Symbol -> Unit
  GHC.Types.Symbol -> Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "s"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Unit ~ Unit
  arising from a type equality Unit ~ Unit
u_tys yields no coercion
checkExpectedKind
  Unit
  Unit
  <Unit>_N
u_tys
  tclvl 1
  Unit ~ Unit
  arising from a type equality Unit ~ Unit
u_tys yields no coercion
checkExpectedKind
  Unit
  Unit
  <Unit>_N
u_tys
  tclvl 1
  Unit ~ Unit
  arising from a type equality Unit ~ Unit
u_tys yields no coercion
checkExpectedKind
  Unit
  Unit
  <Unit>_N
u_tys
  tclvl 1
  * ~ TYPE t0_aci9[tau:1]
  arising from a type equality * ~ TYPE t0_aci9[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_aci9[tau:1]
  arising from a type equality * ~ TYPE t0_aci9[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_aci9[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_aci9[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t0_aci9[tau:1]
  <*>_N
u_tys
  tclvl 1
  * ~ TYPE t0_aci6[tau:1]
  arising from a type equality * ~ TYPE t0_aci6[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_aci6[tau:1]
  arising from a type equality * ~ TYPE t0_aci6[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_aci6[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_aci6[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t0_aci6[tau:1]
  <*>_N
tcImplicitTKBndrs
  [a_abZ3]
  [a_abZ3[sk:1]]
solveEqualities { wanted =  WC {}
newTcEvBinds unique = acia
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = acib
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
checkValidType
  forall a.
  a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s")) :: *
check_type
  forall a.
  a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  True
Ambiguity check for
  forall a.
  a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
tcSubType_NC
  an expression type signature
  forall a.
  a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  forall a.
  a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
tc_sub_tc_type (general case)
  ty_actual   = forall a.
                a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  ty_expected = forall a.
                a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
tcSkolemise
tc_sub_type_ds
  ty_actual   = forall a.
                a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  ty_expected = a_acid[sk:2]
                -> Quantity a_acid[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
Instantiating
  all tyvars? True
  origin arising from a type equality forall a.
                                      a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
                                      ~
                                      forall a.
                                      a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  type forall a.
       a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  theta []
  leave_bndrs []
  with [a_acie[tau:2]]
  theta: []
tc_sub_type_ds
  ty_actual   = a0_acie[tau:2]
                -> Quantity
                     a0_acie[tau:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  ty_expected = a_acid[sk:2]
                -> Quantity a_acid[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
tc_sub_type_ds
  ty_actual   = Quantity
                  a0_acie[tau:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  ty_expected = Quantity
                  a_acid[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
deeply_instantiate final subst
  origin: arising from a type equality forall a.
                                       a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
                                       ~
                                       forall a.
                                       a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  type: Quantity
          a0_acie[tau:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  new type: Quantity
              a0_acie[tau:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  subst: [TCvSubst
            In scope: InScope {a_acie}
            Type env: []
            Co env: []]
u_tys
  tclvl 2
  Quantity a0_acie[tau:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  ~
  Quantity a_acid[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  arising from a type equality a0_acie[tau:2]
                               -> Quantity
                                    a0_acie[tau:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
                               ~
                               a_acid[sk:2]
                               -> Quantity a_acid[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
u_tys
  tclvl 2
  a0_acie[tau:2] ~ a_acid[sk:2]
  arising from a type equality a0_acie[tau:2]
                               -> Quantity
                                    a0_acie[tau:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
                               ~
                               a_acid[sk:2]
                               -> Quantity a_acid[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
u_tys
  tclvl 2
  * ~ *
  arising from a kind equality arising from
    a0_acie[tau:2] ~ a_acid[sk:2]
u_tys
  tclvl 2
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    a0_acie[tau:2] ~ a_acid[sk:2]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_acie[tau:2] :: * := a_acid[sk:2]
u_tys yields no coercion
u_tys
  tclvl 2
  MkUnit "m" /: (MkUnit "s" *: MkUnit "s")
  ~
  MkUnit "m" /: (MkUnit "s" *: MkUnit "s")
  arising from a type equality a0_acie[tau:2]
                               -> Quantity
                                    a0_acie[tau:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
                               ~
                               a_acid[sk:2]
                               -> Quantity a_acid[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
u_tys yields no coercion
u_tys yields no coercion
tc_sub_tc_type (general case)
  ty_actual   = a_acid[sk:2]
  ty_expected = a0_acie[tau:2]
tcSkolemise
tc_sub_type_ds
  ty_actual   = a_acid[sk:2]
  ty_expected = a0_acie[tau:2]
u_tys
  tclvl 2
  a_acid[sk:2] ~ a0_acie[tau:2]
  arising from a type equality a0_acie[tau:2]
                               -> Quantity
                                    a0_acie[tau:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
                               ~
                               a_acid[sk:2]
                               -> Quantity a_acid[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  forall a.
          a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  wanted =  WC {}
newTcEvBinds unique = acif
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = acig
reportUnsolved(ambig) }
Done ambiguity check for
  forall a.
  a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
checkValidType done
  forall a.
  a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s")) :: *
env2 [(a_abZ3, Type variable ‘a_abZ3’ = a_acih[sk:2])]
tcPolyExprNC
  Check{a_acih[sk:2]
        -> Quantity
             a_acih[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))}
tcSkolemise
tcInferId
  Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity :: forall a (u :: Unit).
                                                    a -> Quantity a u
tcCheckId
  Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity
  forall a (u :: Unit). a -> Quantity a u
  Check{a_acih[sk:2]
        -> Quantity
             a_acih[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))}
tcWrapResult
  Actual:   forall a (u :: Unit). a -> Quantity a u
  Expected: Check{a_acih[sk:2]
                  -> Quantity
                       a_acih[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))}
tc_sub_type_ds
  ty_actual   = forall a (u :: Unit). a -> Quantity a u
  ty_expected = a_acih[sk:2]
                -> Quantity a_acih[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
Instantiating
  all tyvars? True
  origin arising from a use of ‘Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity’
  type forall a (u :: Unit). a -> Quantity a u
  theta []
  leave_bndrs []
  with [a_acii[tau:2], u_acij[tau:2]]
  theta: []
tc_sub_type_ds
  ty_actual   = a0_acii[tau:2]
                -> Quantity a0_acii[tau:2] u0_acij[tau:2]
  ty_expected = a_acih[sk:2]
                -> Quantity a_acih[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
tc_sub_type_ds
  ty_actual   = Quantity a0_acii[tau:2] u0_acij[tau:2]
  ty_expected = Quantity
                  a_acih[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
deeply_instantiate final subst
  origin: arising from a use of ‘Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity’
  type: Quantity a0_acii[tau:2] u0_acij[tau:2]
  new type: Quantity a0_acii[tau:2] u0_acij[tau:2]
  subst: [TCvSubst
            In scope: InScope {a_acii u_acij}
            Type env: []
            Co env: []]
u_tys
  tclvl 2
  Quantity a0_acii[tau:2] u0_acij[tau:2]
  ~
  Quantity a_acih[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  arising from a type equality a0_acii[tau:2]
                               -> Quantity a0_acii[tau:2] u0_acij[tau:2]
                               ~
                               a_acih[sk:2]
                               -> Quantity a_acih[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
u_tys
  tclvl 2
  a0_acii[tau:2] ~ a_acih[sk:2]
  arising from a type equality a0_acii[tau:2]
                               -> Quantity a0_acii[tau:2] u0_acij[tau:2]
                               ~
                               a_acih[sk:2]
                               -> Quantity a_acih[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
u_tys
  tclvl 2
  * ~ *
  arising from a kind equality arising from
    a0_acii[tau:2] ~ a_acih[sk:2]
u_tys
  tclvl 2
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    a0_acii[tau:2] ~ a_acih[sk:2]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_acii[tau:2] :: * := a_acih[sk:2]
u_tys yields no coercion
u_tys
  tclvl 2
  u0_acij[tau:2] ~ MkUnit "m" /: (MkUnit "s" *: MkUnit "s")
  arising from a type equality a0_acii[tau:2]
                               -> Quantity a0_acii[tau:2] u0_acij[tau:2]
                               ~
                               a_acih[sk:2]
                               -> Quantity a_acih[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
New coercion hole: acik
utype_defer
  U(hole:{acik}, u0_acij[tau:2], MkUnit "m"
                                 /: (MkUnit "s" *: MkUnit "s"))_N
  u0_acij[tau:2]
  MkUnit "m" /: (MkUnit "s" *: MkUnit "s")
  arising from a type equality a0_acii[tau:2]
                               -> Quantity a0_acii[tau:2] u0_acij[tau:2]
                               ~
                               a_acih[sk:2]
                               -> Quantity a_acih[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  In the expression:
      Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
        a_abZ3
        -> Quantity a_abZ3 ((/:) (MkUnit "m") ((*:) (MkUnit "s") (MkUnit "s")))
  In the expression:
    ((Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
        a_abZ3
        -> Quantity a_abZ3 ((/:) (MkUnit "m") ((*:) (MkUnit "s") (MkUnit "s"))))
       9.808)
  In an equation for ‘gravityOnEarth’:
      gravityOnEarth
        = ((Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
              a_abZ3
              -> Quantity a_abZ3 ((/:) (MkUnit "m") ((*:) (MkUnit "s") (MkUnit "s"))))
             9.808)
u_tys yields coercion:
  U(hole:{acik}, u0_acij[tau:2], MkUnit "m"
                                 /: (MkUnit "s" *: MkUnit "s"))_N
u_tys yields coercion: (Quantity <a>_N {acik})_N
tc_sub_tc_type (general case)
  ty_actual   = a_acih[sk:2]
  ty_expected = a0_acii[tau:2]
tcSkolemise
tc_sub_type_ds
  ty_actual   = a_acih[sk:2]
  ty_expected = a0_acii[tau:2]
u_tys
  tclvl 2
  a_acih[sk:2] ~ a0_acii[tau:2]
  arising from a type equality a0_acii[tau:2]
                               -> Quantity a0_acii[tau:2] u0_acij[tau:2]
                               ~
                               a_acih[sk:2]
                               -> Quantity a_acih[sk:2] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
u_tys yields no coercion
newTcEvBinds unique = acil
tcWrapResult
  Actual:   forall a.
            a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  Expected: Infer{aci5,1 False}
u_tys
  tclvl 1
  * ~ TYPE t0_acim[tau:1]
  arising from a type equality * ~ TYPE t0_acim[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_acim[tau:1]
  arising from a type equality * ~ TYPE t0_acim[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_acim[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_acim[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
Filling ExpType
  aci5 := forall a.
          a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
Instantiating
  all tyvars? True
  origin arising from an expression type signature
  type forall a.
       a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  theta []
  leave_bndrs []
  with [a_acin[tau:1]]
  theta: []
tcPolyExprNC Check{a0_acin[tau:1]}
tcSkolemise
tcInferId fromRational :: forall a. Fractional a => Rational -> a
instCallConstraints [$dFractional_aciw]
Instantiating
  all tyvars? True
  origin arising from the literal ‘9.808’
  type forall a. Fractional a => Rational -> a
  theta [Fractional a_acio]
  leave_bndrs []
  with [a_aciv[tau:1]]
  theta: [Fractional a0_aciv[tau:1]]
tcSkolemise
tc_sub_tc_type (general case)
  ty_actual   = Rational
  ty_expected = Rational
tcSkolemise
tc_sub_type_ds
  ty_actual   = Rational
  ty_expected = Rational
deeply_instantiate final subst
  origin: arising from the literal ‘9.808’
  type: Rational
  new type: Rational
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Rational ~ Rational
  arising from a type equality Rational ~ Rational
u_tys yields no coercion
tcSubTypeDS_O
  arising from the literal ‘9.808’
  a type expected by the context
  a0_aciv[tau:1]
  Check{a0_acin[tau:1]}
tc_sub_type_ds
  ty_actual   = a0_aciv[tau:1]
  ty_expected = a0_acin[tau:1]
u_tys
  tclvl 1
  a0_aciv[tau:1] ~ a0_acin[tau:1]
  arising from a type equality a0_aciv[tau:1] ~ a0_acin[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from
    a0_aciv[tau:1] ~ a0_acin[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    a0_aciv[tau:1] ~ a0_acin[tau:1]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_aciv[tau:1] :: * := a0_acin[tau:1]
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = Quantity
                  a0_acin[tau:1] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  ty_expected = Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
deeply_instantiate final subst
  origin: arising from an expression type signature
  type: Quantity
          a0_acin[tau:1] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  new type: Quantity
              a0_acin[tau:1] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  subst: [TCvSubst
            In scope: InScope {a_acin}
            Type env: []
            Co env: []]
u_tys
  tclvl 1
  Quantity a0_acin[tau:1] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
  ~
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  arising from a type equality Quantity
                                 a0_acin[tau:1] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
                               ~
                               Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
u_tys
  tclvl 1
  a0_acin[tau:1] ~ Double
  arising from a type equality Quantity
                                 a0_acin[tau:1] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
                               ~
                               Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from a0_acin[tau:1] ~ Double
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from a0_acin[tau:1] ~ Double
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_acin[tau:1] :: * := Double
u_tys yields no coercion
u_tys
  tclvl 1
  MkUnit "m" /: (MkUnit "s" *: MkUnit "s")
  ~
  MkUnit "m" /: (MkUnit "s" ^: 2)
  arising from a type equality Quantity
                                 a0_acin[tau:1] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
                               ~
                               Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
New coercion hole: acix
utype_defer
  U(hole:{acix}, MkUnit "m" /: (MkUnit "s" *: MkUnit "s"), MkUnit "m"
                                                           /: (MkUnit "s" ^: 2))_N
  MkUnit "m" /: (MkUnit "s" *: MkUnit "s")
  MkUnit "m" /: (MkUnit "s" ^: 2)
  arising from a type equality Quantity
                                 a0_acin[tau:1] (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
                               ~
                               Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  In the expression:
    ((Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
        a_abZ3
        -> Quantity a_abZ3 ((/:) (MkUnit "m") ((*:) (MkUnit "s") (MkUnit "s"))))
       9.808)
  In an equation for ‘gravityOnEarth’:
      gravityOnEarth
        = ((Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
              a_abZ3
              -> Quantity a_abZ3 ((/:) (MkUnit "m") ((*:) (MkUnit "s") (MkUnit "s"))))
             9.808)
u_tys yields coercion:
  U(hole:{acix}, MkUnit "m" /: (MkUnit "s" *: MkUnit "s"), MkUnit "m"
                                                           /: (MkUnit "s" ^: 2))_N
u_tys yields coercion: (Quantity <Double>_N {acix})_N
tcSpecPrags gravityOnEarth []
} End of bindings for
  [gravityOnEarth]
  NonRecursive
  gravityOnEarth Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
tcExtendIdBndrs [gravityOnEarth[<TopLevel>]]
env2
  [(gravityOnEarth,
    Identifier[gravityOnEarth::Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2)), TopLevelLet])]
------------------------------------------------
Bindings for { [myMass]
Generalisation plan CheckGen myMass :: Quantity Double (Base "kg")
tcPolyCheck
  myMass
  test-suite-force/Tests.hs:32:1-37
tcExtendIdBndrs [myMass_aciy[<NotTopLevel>]]
env2 []
tcMatchesFun
  myMass_aciy
  Check{Quantity Double (Base "kg")}
tcSkolemise
tcBody Check{Quantity Double (Base "kg")}
newOpenInferExpType aciz False 1
decideKindGeneralisationPlan
  a_abYY -> Quantity a_abYY (MkUnit "kg")
  should gen? True
env2 [(a_abYY, Type variable ‘a_abYY’ = a_abYY[sk:1])]
lk1 a_abYY
u_tys
  tclvl 1
  k0_aciB[tau:1] ~ TYPE t0_aciC[tau:1]
  arising from a type equality k0_aciB[tau:1] ~ TYPE t0_aciC[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from
    k0_aciB[tau:1] ~ TYPE t0_aciC[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    k0_aciB[tau:1] ~ TYPE t0_aciC[tau:1]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar k_aciB[tau:1] :: * := TYPE t0_aciC[tau:1]
u_tys yields no coercion
checkExpectedKind
  k0_aciB[tau:1]
  TYPE t0_aciC[tau:1]
  <TYPE t0_aciC[tau:1]>_N
lk1 Quantity
tcTyVar2a
  Quantity
  * -> Unit -> *
tc_infer_args (vis)
  [anon] *
  a_abYY
lk1 a_abYY
u_tys
  tclvl 1
  k0_aciB[tau:1] ~ *
  arising from a type equality k0_aciB[tau:1] ~ *
found filled tyvar k_aciB[tau:1] :-> TYPE t0_aciC[tau:1]
u_tys
  tclvl 1
  t0_aciC[tau:1] ~ 'GHC.Types.LiftedRep
  arising from a type equality k0_aciB[tau:1] ~ *
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_aciC[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_aciC[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  k0_aciB[tau:1]
  *
  <*>_N
tc_infer_args (vis)
  [anon] Unit
  (MkUnit "kg")
lk1 MkUnit
tcTyVar2b
  MkUnit :: GHC.Types.Symbol -> Unit
  GHC.Types.Symbol -> Unit
tc_infer_args (vis)
  [anon] GHC.Types.Symbol
  "kg"
u_tys
  tclvl 1
  GHC.Types.Symbol ~ GHC.Types.Symbol
  arising from a type equality GHC.Types.Symbol ~ GHC.Types.Symbol
u_tys yields no coercion
checkExpectedKind
  GHC.Types.Symbol
  GHC.Types.Symbol
  <GHC.Types.Symbol>_N
u_tys
  tclvl 1
  Unit ~ Unit
  arising from a type equality Unit ~ Unit
u_tys yields no coercion
checkExpectedKind
  Unit
  Unit
  <Unit>_N
u_tys
  tclvl 1
  * ~ TYPE t0_aciD[tau:1]
  arising from a type equality * ~ TYPE t0_aciD[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_aciD[tau:1]
  arising from a type equality * ~ TYPE t0_aciD[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_aciD[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_aciD[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t0_aciD[tau:1]
  <*>_N
u_tys
  tclvl 1
  * ~ TYPE t0_aciA[tau:1]
  arising from a type equality * ~ TYPE t0_aciA[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_aciA[tau:1]
  arising from a type equality * ~ TYPE t0_aciA[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_aciA[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_aciA[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t0_aciA[tau:1]
  <*>_N
tcImplicitTKBndrs
  [a_abYY]
  [a_abYY[sk:1]]
solveEqualities { wanted =  WC {}
newTcEvBinds unique = aciE
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End solveEqualities }
reportAllUnsolved {
newTcEvBinds unique = aciF
reportAllUnsolved }
quantifyZonkedTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyZonkedTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
checkValidType forall a. a -> Quantity a (MkUnit "kg") :: *
check_type
  forall a. a -> Quantity a (MkUnit "kg")
  True
Ambiguity check for forall a. a -> Quantity a (MkUnit "kg")
tcSubType_NC
  an expression type signature
  forall a. a -> Quantity a (MkUnit "kg")
  forall a. a -> Quantity a (MkUnit "kg")
tc_sub_tc_type (general case)
  ty_actual   = forall a. a -> Quantity a (MkUnit "kg")
  ty_expected = forall a. a -> Quantity a (MkUnit "kg")
tcSkolemise
tc_sub_type_ds
  ty_actual   = forall a. a -> Quantity a (MkUnit "kg")
  ty_expected = a_aciH[sk:2] -> Quantity a_aciH[sk:2] (MkUnit "kg")
Instantiating
  all tyvars? True
  origin arising from a type equality forall a.
                                      a -> Quantity a (MkUnit "kg")
                                      ~
                                      forall a. a -> Quantity a (MkUnit "kg")
  type forall a. a -> Quantity a (MkUnit "kg")
  theta []
  leave_bndrs []
  with [a_aciI[tau:2]]
  theta: []
tc_sub_type_ds
  ty_actual   = a0_aciI[tau:2]
                -> Quantity a0_aciI[tau:2] (MkUnit "kg")
  ty_expected = a_aciH[sk:2] -> Quantity a_aciH[sk:2] (MkUnit "kg")
tc_sub_type_ds
  ty_actual   = Quantity a0_aciI[tau:2] (MkUnit "kg")
  ty_expected = Quantity a_aciH[sk:2] (MkUnit "kg")
deeply_instantiate final subst
  origin: arising from a type equality forall a.
                                       a -> Quantity a (MkUnit "kg")
                                       ~
                                       forall a. a -> Quantity a (MkUnit "kg")
  type: Quantity a0_aciI[tau:2] (MkUnit "kg")
  new type: Quantity a0_aciI[tau:2] (MkUnit "kg")
  subst: [TCvSubst
            In scope: InScope {a_aciI}
            Type env: []
            Co env: []]
u_tys
  tclvl 2
  Quantity a0_aciI[tau:2] (MkUnit "kg")
  ~
  Quantity a_aciH[sk:2] (MkUnit "kg")
  arising from a type equality a0_aciI[tau:2]
                               -> Quantity a0_aciI[tau:2] (MkUnit "kg")
                               ~
                               a_aciH[sk:2] -> Quantity a_aciH[sk:2] (MkUnit "kg")
u_tys
  tclvl 2
  a0_aciI[tau:2] ~ a_aciH[sk:2]
  arising from a type equality a0_aciI[tau:2]
                               -> Quantity a0_aciI[tau:2] (MkUnit "kg")
                               ~
                               a_aciH[sk:2] -> Quantity a_aciH[sk:2] (MkUnit "kg")
u_tys
  tclvl 2
  * ~ *
  arising from a kind equality arising from
    a0_aciI[tau:2] ~ a_aciH[sk:2]
u_tys
  tclvl 2
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    a0_aciI[tau:2] ~ a_aciH[sk:2]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_aciI[tau:2] :: * := a_aciH[sk:2]
u_tys yields no coercion
u_tys
  tclvl 2
  MkUnit "kg" ~ MkUnit "kg"
  arising from a type equality a0_aciI[tau:2]
                               -> Quantity a0_aciI[tau:2] (MkUnit "kg")
                               ~
                               a_aciH[sk:2] -> Quantity a_aciH[sk:2] (MkUnit "kg")
u_tys yields no coercion
u_tys yields no coercion
tc_sub_tc_type (general case)
  ty_actual   = a_aciH[sk:2]
  ty_expected = a0_aciI[tau:2]
tcSkolemise
tc_sub_type_ds
  ty_actual   = a_aciH[sk:2]
  ty_expected = a0_aciI[tau:2]
u_tys
  tclvl 2
  a_aciH[sk:2] ~ a0_aciI[tau:2]
  arising from a type equality a0_aciI[tau:2]
                               -> Quantity a0_aciI[tau:2] (MkUnit "kg")
                               ~
                               a_aciH[sk:2] -> Quantity a_aciH[sk:2] (MkUnit "kg")
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  forall a. a -> Quantity a (MkUnit "kg")
  wanted =  WC {}
newTcEvBinds unique = aciJ
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds middle
  simples1 = {}
  simples2 = {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = aciK
reportUnsolved(ambig) }
Done ambiguity check for forall a. a -> Quantity a (MkUnit "kg")
checkValidType done forall a. a -> Quantity a (MkUnit "kg") :: *
env2 [(a_abYY, Type variable ‘a_abYY’ = a_aciL[sk:2])]
tcPolyExprNC
  Check{a_aciL[sk:2] -> Quantity a_aciL[sk:2] (MkUnit "kg")}
tcSkolemise
tcInferId
  Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity :: forall a (u :: Unit).
                                                    a -> Quantity a u
tcCheckId
  Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity
  forall a (u :: Unit). a -> Quantity a u
  Check{a_aciL[sk:2] -> Quantity a_aciL[sk:2] (MkUnit "kg")}
tcWrapResult
  Actual:   forall a (u :: Unit). a -> Quantity a u
  Expected: Check{a_aciL[sk:2]
                  -> Quantity a_aciL[sk:2] (MkUnit "kg")}
tc_sub_type_ds
  ty_actual   = forall a (u :: Unit). a -> Quantity a u
  ty_expected = a_aciL[sk:2] -> Quantity a_aciL[sk:2] (MkUnit "kg")
Instantiating
  all tyvars? True
  origin arising from a use of ‘Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity’
  type forall a (u :: Unit). a -> Quantity a u
  theta []
  leave_bndrs []
  with [a_aciM[tau:2], u_aciN[tau:2]]
  theta: []
tc_sub_type_ds
  ty_actual   = a0_aciM[tau:2]
                -> Quantity a0_aciM[tau:2] u0_aciN[tau:2]
  ty_expected = a_aciL[sk:2] -> Quantity a_aciL[sk:2] (MkUnit "kg")
tc_sub_type_ds
  ty_actual   = Quantity a0_aciM[tau:2] u0_aciN[tau:2]
  ty_expected = Quantity a_aciL[sk:2] (MkUnit "kg")
deeply_instantiate final subst
  origin: arising from a use of ‘Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity’
  type: Quantity a0_aciM[tau:2] u0_aciN[tau:2]
  new type: Quantity a0_aciM[tau:2] u0_aciN[tau:2]
  subst: [TCvSubst
            In scope: InScope {a_aciM u_aciN}
            Type env: []
            Co env: []]
u_tys
  tclvl 2
  Quantity a0_aciM[tau:2] u0_aciN[tau:2]
  ~
  Quantity a_aciL[sk:2] (MkUnit "kg")
  arising from a type equality a0_aciM[tau:2]
                               -> Quantity a0_aciM[tau:2] u0_aciN[tau:2]
                               ~
                               a_aciL[sk:2] -> Quantity a_aciL[sk:2] (MkUnit "kg")
u_tys
  tclvl 2
  a0_aciM[tau:2] ~ a_aciL[sk:2]
  arising from a type equality a0_aciM[tau:2]
                               -> Quantity a0_aciM[tau:2] u0_aciN[tau:2]
                               ~
                               a_aciL[sk:2] -> Quantity a_aciL[sk:2] (MkUnit "kg")
u_tys
  tclvl 2
  * ~ *
  arising from a kind equality arising from
    a0_aciM[tau:2] ~ a_aciL[sk:2]
u_tys
  tclvl 2
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    a0_aciM[tau:2] ~ a_aciL[sk:2]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_aciM[tau:2] :: * := a_aciL[sk:2]
u_tys yields no coercion
u_tys
  tclvl 2
  u0_aciN[tau:2] ~ MkUnit "kg"
  arising from a type equality a0_aciM[tau:2]
                               -> Quantity a0_aciM[tau:2] u0_aciN[tau:2]
                               ~
                               a_aciL[sk:2] -> Quantity a_aciL[sk:2] (MkUnit "kg")
New coercion hole: aciO
utype_defer
  U(hole:{aciO}, u0_aciN[tau:2], MkUnit "kg")_N
  u0_aciN[tau:2]
  MkUnit "kg"
  arising from a type equality a0_aciM[tau:2]
                               -> Quantity a0_aciM[tau:2] u0_aciN[tau:2]
                               ~
                               a_aciL[sk:2] -> Quantity a_aciL[sk:2] (MkUnit "kg")
  In the expression:
      Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
        a_abYY -> Quantity a_abYY (MkUnit "kg")
  In the expression:
    ((Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
        a_abYY -> Quantity a_abYY (MkUnit "kg"))
       65)
  In an equation for ‘myMass’:
      myMass
        = ((Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
              a_abYY -> Quantity a_abYY (MkUnit "kg"))
             65)
u_tys yields coercion:
  U(hole:{aciO}, u0_aciN[tau:2], MkUnit "kg")_N
u_tys yields coercion: (Quantity <a>_N {aciO})_N
tc_sub_tc_type (general case)
  ty_actual   = a_aciL[sk:2]
  ty_expected = a0_aciM[tau:2]
tcSkolemise
tc_sub_type_ds
  ty_actual   = a_aciL[sk:2]
  ty_expected = a0_aciM[tau:2]
u_tys
  tclvl 2
  a_aciL[sk:2] ~ a0_aciM[tau:2]
  arising from a type equality a0_aciM[tau:2]
                               -> Quantity a0_aciM[tau:2] u0_aciN[tau:2]
                               ~
                               a_aciL[sk:2] -> Quantity a_aciL[sk:2] (MkUnit "kg")
u_tys yields no coercion
newTcEvBinds unique = aciP
tcWrapResult
  Actual:   forall a. a -> Quantity a (MkUnit "kg")
  Expected: Infer{aciz,1 False}
u_tys
  tclvl 1
  * ~ TYPE t0_aciQ[tau:1]
  arising from a type equality * ~ TYPE t0_aciQ[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_aciQ[tau:1]
  arising from a type equality * ~ TYPE t0_aciQ[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_aciQ[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_aciQ[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
Filling ExpType aciz := forall a. a -> Quantity a (MkUnit "kg")
Instantiating
  all tyvars? True
  origin arising from an expression type signature
  type forall a. a -> Quantity a (MkUnit "kg")
  theta []
  leave_bndrs []
  with [a_aciR[tau:1]]
  theta: []
tcPolyExprNC Check{a0_aciR[tau:1]}
tcSkolemise
tcInferId fromInteger :: forall a. Num a => Integer -> a
instCallConstraints [$dNum_ackl]
Instantiating
  all tyvars? True
  origin arising from the literal ‘65’
  type forall a. Num a => Integer -> a
  theta [Num a_acka]
  leave_bndrs []
  with [a_ackk[tau:1]]
  theta: [Num a0_ackk[tau:1]]
tcSkolemise
tc_sub_tc_type (general case)
  ty_actual   = Integer
  ty_expected = Integer
tcSkolemise
tc_sub_type_ds
  ty_actual   = Integer
  ty_expected = Integer
deeply_instantiate final subst
  origin: arising from the literal ‘65’
  type: Integer
  new type: Integer
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Integer ~ Integer
  arising from a type equality Integer ~ Integer
u_tys yields no coercion
tcSubTypeDS_O
  arising from the literal ‘65’
  a type expected by the context
  a0_ackk[tau:1]
  Check{a0_aciR[tau:1]}
tc_sub_type_ds
  ty_actual   = a0_ackk[tau:1]
  ty_expected = a0_aciR[tau:1]
u_tys
  tclvl 1
  a0_ackk[tau:1] ~ a0_aciR[tau:1]
  arising from a type equality a0_ackk[tau:1] ~ a0_aciR[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from
    a0_ackk[tau:1] ~ a0_aciR[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    a0_ackk[tau:1] ~ a0_aciR[tau:1]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_ackk[tau:1] :: * := a0_aciR[tau:1]
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = Quantity a0_aciR[tau:1] (MkUnit "kg")
  ty_expected = Quantity Double (Base "kg")
deeply_instantiate final subst
  origin: arising from an expression type signature
  type: Quantity a0_aciR[tau:1] (MkUnit "kg")
  new type: Quantity a0_aciR[tau:1] (MkUnit "kg")
  subst: [TCvSubst
            In scope: InScope {a_aciR}
            Type env: []
            Co env: []]
u_tys
  tclvl 1
  Quantity a0_aciR[tau:1] (MkUnit "kg") ~ Quantity Double (Base "kg")
  arising from a type equality Quantity a0_aciR[tau:1] (MkUnit "kg")
                               ~
                               Quantity Double (Base "kg")
u_tys
  tclvl 1
  a0_aciR[tau:1] ~ Double
  arising from a type equality Quantity a0_aciR[tau:1] (MkUnit "kg")
                               ~
                               Quantity Double (Base "kg")
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from a0_aciR[tau:1] ~ Double
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from a0_aciR[tau:1] ~ Double
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_aciR[tau:1] :: * := Double
u_tys yields no coercion
u_tys
  tclvl 1
  MkUnit "kg" ~ Base "kg"
  arising from a type equality Quantity a0_aciR[tau:1] (MkUnit "kg")
                               ~
                               Quantity Double (Base "kg")
New coercion hole: ackm
utype_defer
  U(hole:{ackm}, MkUnit "kg", Base "kg")_N
  MkUnit "kg"
  Base "kg"
  arising from a type equality Quantity a0_aciR[tau:1] (MkUnit "kg")
                               ~
                               Quantity Double (Base "kg")
  In the expression:
    ((Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
        a_abYY -> Quantity a_abYY (MkUnit "kg"))
       65)
  In an equation for ‘myMass’:
      myMass
        = ((Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
              a_abYY -> Quantity a_abYY (MkUnit "kg"))
             65)
u_tys yields coercion: U(hole:{ackm}, MkUnit "kg", Base "kg")_N
u_tys yields coercion: (Quantity <Double>_N {ackm})_N
tcSpecPrags myMass []
} End of bindings for
  [myMass]
  NonRecursive
  myMass Quantity Double (Base "kg")
tcExtendIdBndrs [myMass[<TopLevel>]]
env2
  [(myMass,
    Identifier[myMass::Quantity Double (Base "kg"), TopLevelLet])]
------------------------------------------------
Bindings for { [forceOnGround]
Generalisation plan
  CheckGen forceOnGround :: Quantity Double (MkUnit "N")
tcPolyCheck
  forceOnGround
  test-suite-force/Tests.hs:48:1-41
tcExtendIdBndrs [forceOnGround_ackn[<NotTopLevel>]]
env2 []
tcMatchesFun
  forceOnGround_ackn
  Check{Quantity Double (MkUnit "N")}
tcSkolemise
tcBody Check{Quantity Double (MkUnit "N")}
Non Application rule (*:)
tcInferId
  *: :: forall a (w :: Unit) (u :: Unit) (v :: Unit).
        (Num a, w Data.UnitsOfMeasure.Syntax.~~ (u *: v)) =>
        Quantity a u -> Quantity a v -> Quantity a w
instCallConstraints [$dNum_ackx, irred_acky]
Instantiating
  all tyvars? True
  origin arising from a use of ‘*:’
  type forall a (w :: Unit) (u :: Unit) (v :: Unit).
       (Num a, w Data.UnitsOfMeasure.Syntax.~~ (u *: v)) =>
       Quantity a u -> Quantity a v -> Quantity a w
  theta [Num a_acko,
         w_ackp Data.UnitsOfMeasure.Syntax.~~ (u_ackq *: v_ackr)]
  leave_bndrs []
  with [a_ackt[tau:1], w_acku[tau:1], u_ackv[tau:1], v_ackw[tau:1]]
  theta: [Num a0_ackt[tau:1],
          w0_acku[tau:1]
          Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1] *: v0_ackw[tau:1])]
tcPolyExprNC Check{Quantity a0_ackt[tau:1] u0_ackv[tau:1]}
tcSkolemise
tcInferId
  gravityOnEarth :: Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
tcCheckId
  gravityOnEarth
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  Check{Quantity a0_ackt[tau:1] u0_ackv[tau:1]}
tcWrapResult
  Actual:   Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  Expected: Check{Quantity a0_ackt[tau:1] u0_ackv[tau:1]}
tc_sub_type_ds
  ty_actual   = Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  ty_expected = Quantity a0_ackt[tau:1] u0_ackv[tau:1]
deeply_instantiate final subst
  origin: arising from a use of ‘gravityOnEarth’
  type: Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  new type: Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  ~
  Quantity a0_ackt[tau:1] u0_ackv[tau:1]
  arising from a type equality Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2))
                               ~
                               Quantity a0_ackt[tau:1] u0_ackv[tau:1]
u_tys
  tclvl 1
  Double ~ a0_ackt[tau:1]
  arising from a type equality Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2))
                               ~
                               Quantity a0_ackt[tau:1] u0_ackv[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from a0_ackt[tau:1] ~ Double
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from a0_ackt[tau:1] ~ Double
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_ackt[tau:1] :: * := Double
u_tys yields no coercion
u_tys
  tclvl 1
  MkUnit "m" /: (MkUnit "s" ^: 2) ~ u0_ackv[tau:1]
  arising from a type equality Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2))
                               ~
                               Quantity a0_ackt[tau:1] u0_ackv[tau:1]
New coercion hole: ackz
utype_defer
  U(hole:{ackz}, MkUnit "m" /: (MkUnit "s" ^: 2), u0_ackv[tau:1])_N
  MkUnit "m" /: (MkUnit "s" ^: 2)
  u0_ackv[tau:1]
  arising from a type equality Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2))
                               ~
                               Quantity a0_ackt[tau:1] u0_ackv[tau:1]
  In the first argument of ‘(*:)’, namely ‘gravityOnEarth’
  In the expression: gravityOnEarth *: myMass
  In an equation for ‘forceOnGround’:
      forceOnGround = gravityOnEarth *: myMass
u_tys yields coercion:
  U(hole:{ackz}, MkUnit "m" /: (MkUnit "s" ^: 2), u0_ackv[tau:1])_N
u_tys yields coercion: (Quantity <Double>_N {ackz})_N
tcPolyExprNC Check{Quantity a0_ackt[tau:1] v0_ackw[tau:1]}
tcSkolemise
tcInferId myMass :: Quantity Double (Base "kg")
tcCheckId
  myMass
  Quantity Double (Base "kg")
  Check{Quantity a0_ackt[tau:1] v0_ackw[tau:1]}
tcWrapResult
  Actual:   Quantity Double (Base "kg")
  Expected: Check{Quantity a0_ackt[tau:1] v0_ackw[tau:1]}
tc_sub_type_ds
  ty_actual   = Quantity Double (Base "kg")
  ty_expected = Quantity a0_ackt[tau:1] v0_ackw[tau:1]
deeply_instantiate final subst
  origin: arising from a use of ‘myMass’
  type: Quantity Double (Base "kg")
  new type: Quantity Double (Base "kg")
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Quantity Double (Base "kg")
  ~
  Quantity a0_ackt[tau:1] v0_ackw[tau:1]
  arising from a type equality Quantity Double (Base "kg")
                               ~
                               Quantity a0_ackt[tau:1] v0_ackw[tau:1]
u_tys
  tclvl 1
  Double ~ a0_ackt[tau:1]
  arising from a type equality Quantity Double (Base "kg")
                               ~
                               Quantity a0_ackt[tau:1] v0_ackw[tau:1]
found filled tyvar a_ackt[tau:1] :-> Double
u_tys yields no coercion
u_tys
  tclvl 1
  Base "kg" ~ v0_ackw[tau:1]
  arising from a type equality Quantity Double (Base "kg")
                               ~
                               Quantity a0_ackt[tau:1] v0_ackw[tau:1]
New coercion hole: ackA
utype_defer
  U(hole:{ackA}, Base "kg", v0_ackw[tau:1])_N
  Base "kg"
  v0_ackw[tau:1]
  arising from a type equality Quantity Double (Base "kg")
                               ~
                               Quantity a0_ackt[tau:1] v0_ackw[tau:1]
  In the second argument of ‘(*:)’, namely ‘myMass’
  In the expression: gravityOnEarth *: myMass
  In an equation for ‘forceOnGround’:
      forceOnGround = gravityOnEarth *: myMass
u_tys yields coercion: U(hole:{ackA}, Base "kg", v0_ackw[tau:1])_N
u_tys yields coercion: (Quantity <Double>_N {ackA})_N
tc_sub_type_ds
  ty_actual   = Quantity a0_ackt[tau:1] w0_acku[tau:1]
  ty_expected = Quantity Double (MkUnit "N")
deeply_instantiate final subst
  origin: arising from a use of ‘*:’
  type: Quantity a0_ackt[tau:1] w0_acku[tau:1]
  new type: Quantity a0_ackt[tau:1] w0_acku[tau:1]
  subst: [TCvSubst
            In scope: InScope {a_ackt w_acku}
            Type env: []
            Co env: []]
u_tys
  tclvl 1
  Quantity a0_ackt[tau:1] w0_acku[tau:1]
  ~
  Quantity Double (MkUnit "N")
  arising from a type equality Quantity a0_ackt[tau:1] w0_acku[tau:1]
                               ~
                               Quantity Double (MkUnit "N")
u_tys
  tclvl 1
  a0_ackt[tau:1] ~ Double
  arising from a type equality Quantity a0_ackt[tau:1] w0_acku[tau:1]
                               ~
                               Quantity Double (MkUnit "N")
found filled tyvar a_ackt[tau:1] :-> Double
u_tys yields no coercion
u_tys
  tclvl 1
  w0_acku[tau:1] ~ MkUnit "N"
  arising from a type equality Quantity a0_ackt[tau:1] w0_acku[tau:1]
                               ~
                               Quantity Double (MkUnit "N")
New coercion hole: ackB
utype_defer
  U(hole:{ackB}, w0_acku[tau:1], MkUnit "N")_N
  w0_acku[tau:1]
  MkUnit "N"
  arising from a type equality Quantity a0_ackt[tau:1] w0_acku[tau:1]
                               ~
                               Quantity Double (MkUnit "N")
  In the expression: gravityOnEarth *: myMass
  In an equation for ‘forceOnGround’:
      forceOnGround = gravityOnEarth *: myMass
u_tys yields coercion: U(hole:{ackB}, w0_acku[tau:1], MkUnit "N")_N
u_tys yields coercion: (Quantity <Double>_N {ackB})_N
tcSpecPrags forceOnGround []
} End of bindings for
  [forceOnGround]
  NonRecursive
  forceOnGround Quantity Double (MkUnit "N")
tcExtendIdBndrs [forceOnGround[<TopLevel>]]
env2
  [(forceOnGround,
    Identifier[forceOnGround::Quantity
                                Double (MkUnit "N"), TopLevelLet])]
------------------------------------------------
Bindings for { [tests]
Generalisation plan CheckGen tests :: TestTree
tcPolyCheck
  tests
  test-suite-force/Tests.hs:54:1-17
tcExtendIdBndrs [tests_ackC[<NotTopLevel>]]
env2 []
tcMatchesFun
  tests_ackC
  Check{TestTree}
tcSkolemise
tcBody Check{TestTree}
tcInferId testGroup :: TestName -> [TestTree] -> TestTree
tcPolyExprNC Check{TestName}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{TestName}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = TestName
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ TestName
  arising from a type equality [Char] ~ TestName
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ TestName
u_tys yields no coercion
u_tys yields no coercion
tcPolyExprNC Check{[TestTree]}
tcSkolemise
tcPolyExpr Check{TestTree}
tcPolyExprNC Check{TestTree}
tcSkolemise
tcInferId testGroup :: TestName -> [TestTree] -> TestTree
tcPolyExprNC Check{TestName}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{TestName}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = TestName
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ TestName
  arising from a type equality [Char] ~ TestName
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ TestName
u_tys yields no coercion
u_tys yields no coercion
tcPolyExprNC Check{[TestTree]}
tcSkolemise
tcPolyExpr Check{TestTree}
tcPolyExprNC Check{TestTree}
tcSkolemise
Application rule ($)
newOpenInferExpType ackF False 1
tcInferId testCase :: TestName -> Assertion -> TestTree
tcPolyExprNC Check{TestName}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{TestName}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = TestName
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ TestName
  arising from a type equality [Char] ~ TestName
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ TestName
u_tys yields no coercion
u_tys yields no coercion
u_tys
  tclvl 1
  * ~ TYPE t0_ackI[tau:1]
  arising from a type equality * ~ TYPE t0_ackI[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_ackI[tau:1]
  arising from a type equality * ~ TYPE t0_ackI[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_ackI[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_ackI[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
Filling ExpType ackF := Assertion -> TestTree
tcPolyExprNC Check{Assertion}
tcSkolemise
Non Application rule (@?=)
tcInferId
  @?= :: forall a.
         (Eq a, Show a, HasCallStack) =>
         a -> a -> Assertion
instCallConstraints [$dEq_acxx, $dShow_acxy, $dIP_acxE]
Instantiating
  all tyvars? True
  origin arising from a use of ‘@?=’
  type forall a. (Eq a, Show a, HasCallStack) => a -> a -> Assertion
  theta [Eq a_ackJ, Show a_ackJ, HasCallStack]
  leave_bndrs []
  with [a_acxw[tau:1]]
  theta: [Eq a0_acxw[tau:1], Show a0_acxw[tau:1], HasCallStack]
tcPolyExprNC Check{a0_acxw[tau:1]}
tcSkolemise
tcInferId
  showQuantity :: forall a (u :: Unit).
                  (Show a, KnownUnit (Unpack u)) =>
                  Quantity a u -> String
instCallConstraints [$dShow_acA6, $dKnownUnit_acA7]
Instantiating
  all tyvars? True
  origin arising from a use of ‘showQuantity’
  type forall a (u :: Unit).
       (Show a, KnownUnit (Unpack u)) =>
       Quantity a u -> String
  theta [Show a_acxF, KnownUnit (Unpack u_acxG)]
  leave_bndrs []
  with [a_acA4[tau:1], u_acA5[tau:1]]
  theta: [Show a0_acA4[tau:1], KnownUnit (Unpack u0_acA5[tau:1])]
tcPolyExprNC Check{Quantity a0_acA4[tau:1] u0_acA5[tau:1]}
tcSkolemise
tcInferId myMass :: Quantity Double (Base "kg")
tcCheckId
  myMass
  Quantity Double (Base "kg")
  Check{Quantity a0_acA4[tau:1] u0_acA5[tau:1]}
tcWrapResult
  Actual:   Quantity Double (Base "kg")
  Expected: Check{Quantity a0_acA4[tau:1] u0_acA5[tau:1]}
tc_sub_type_ds
  ty_actual   = Quantity Double (Base "kg")
  ty_expected = Quantity a0_acA4[tau:1] u0_acA5[tau:1]
deeply_instantiate final subst
  origin: arising from a use of ‘myMass’
  type: Quantity Double (Base "kg")
  new type: Quantity Double (Base "kg")
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Quantity Double (Base "kg")
  ~
  Quantity a0_acA4[tau:1] u0_acA5[tau:1]
  arising from a type equality Quantity Double (Base "kg")
                               ~
                               Quantity a0_acA4[tau:1] u0_acA5[tau:1]
u_tys
  tclvl 1
  Double ~ a0_acA4[tau:1]
  arising from a type equality Quantity Double (Base "kg")
                               ~
                               Quantity a0_acA4[tau:1] u0_acA5[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from a0_acA4[tau:1] ~ Double
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from a0_acA4[tau:1] ~ Double
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_acA4[tau:1] :: * := Double
u_tys yields no coercion
u_tys
  tclvl 1
  Base "kg" ~ u0_acA5[tau:1]
  arising from a type equality Quantity Double (Base "kg")
                               ~
                               Quantity a0_acA4[tau:1] u0_acA5[tau:1]
New coercion hole: acA8
utype_defer
  U(hole:{acA8}, Base "kg", u0_acA5[tau:1])_N
  Base "kg"
  u0_acA5[tau:1]
  arising from a type equality Quantity Double (Base "kg")
                               ~
                               Quantity a0_acA4[tau:1] u0_acA5[tau:1]
  In the first argument of ‘showQuantity’, namely ‘myMass’
  In the first argument of ‘(@?=)’, namely ‘showQuantity myMass’
  In the second argument of ‘($)’, namely
    ‘showQuantity myMass @?= "65.0 kg"’
u_tys yields coercion: U(hole:{acA8}, Base "kg", u0_acA5[tau:1])_N
u_tys yields coercion: (Quantity <Double>_N {acA8})_N
tc_sub_type_ds
  ty_actual   = String
  ty_expected = a0_acxw[tau:1]
deeply_instantiate final subst
  origin: arising from a use of ‘showQuantity’
  type: String
  new type: String
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  String ~ a0_acxw[tau:1]
  arising from a type equality String ~ a0_acxw[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from a0_acxw[tau:1] ~ String
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from a0_acxw[tau:1] ~ String
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_acxw[tau:1] :: * := String
u_tys yields no coercion
tcPolyExprNC Check{a0_acxw[tau:1]}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{a0_acxw[tau:1]}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = a0_acxw[tau:1]
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ a0_acxw[tau:1]
  arising from a type equality [Char] ~ a0_acxw[tau:1]
found filled tyvar a_acxw[tau:1] :-> String
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ a0_acxw[tau:1]
u_tys yields no coercion
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = Assertion
  ty_expected = Assertion
deeply_instantiate final subst
  origin: arising from a use of ‘@?=’
  type: Assertion
  new type: Assertion
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Assertion ~ Assertion
  arising from a type equality Assertion ~ Assertion
u_tys yields no coercion
u_tys
  tclvl 1
  * ~ *
  arising from a type equality * ~ *
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a type equality * ~ *
u_tys yields no coercion
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = TestTree
  ty_expected = TestTree
deeply_instantiate final subst
  origin: arising from a use of ‘testCase’
  type: TestTree
  new type: TestTree
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  TestTree ~ TestTree
  arising from a type equality TestTree ~ TestTree
u_tys yields no coercion
tcPolyExpr Check{TestTree}
tcPolyExprNC Check{TestTree}
tcSkolemise
Application rule ($)
newOpenInferExpType acA9 False 1
tcInferId testCase :: TestName -> Assertion -> TestTree
tcPolyExprNC Check{TestName}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{TestName}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = TestName
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ TestName
  arising from a type equality [Char] ~ TestName
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ TestName
u_tys yields no coercion
u_tys yields no coercion
u_tys
  tclvl 1
  * ~ TYPE t0_acAa[tau:1]
  arising from a type equality * ~ TYPE t0_acAa[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_acAa[tau:1]
  arising from a type equality * ~ TYPE t0_acAa[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_acAa[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_acAa[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
Filling ExpType acA9 := Assertion -> TestTree
tcPolyExprNC Check{Assertion}
tcSkolemise
Non Application rule (@?=)
tcInferId
  @?= :: forall a.
         (Eq a, Show a, HasCallStack) =>
         a -> a -> Assertion
instCallConstraints [$dEq_acAc, $dShow_acAd, $dIP_acAe]
Instantiating
  all tyvars? True
  origin arising from a use of ‘@?=’
  type forall a. (Eq a, Show a, HasCallStack) => a -> a -> Assertion
  theta [Eq a_ackJ, Show a_ackJ, HasCallStack]
  leave_bndrs []
  with [a_acAb[tau:1]]
  theta: [Eq a0_acAb[tau:1], Show a0_acAb[tau:1], HasCallStack]
tcPolyExprNC Check{a0_acAb[tau:1]}
tcSkolemise
tcInferId
  showQuantity :: forall a (u :: Unit).
                  (Show a, KnownUnit (Unpack u)) =>
                  Quantity a u -> String
instCallConstraints [$dShow_acAh, $dKnownUnit_acAi]
Instantiating
  all tyvars? True
  origin arising from a use of ‘showQuantity’
  type forall a (u :: Unit).
       (Show a, KnownUnit (Unpack u)) =>
       Quantity a u -> String
  theta [Show a_acxF, KnownUnit (Unpack u_acxG)]
  leave_bndrs []
  with [a_acAf[tau:1], u_acAg[tau:1]]
  theta: [Show a0_acAf[tau:1], KnownUnit (Unpack u0_acAg[tau:1])]
tcPolyExprNC Check{Quantity a0_acAf[tau:1] u0_acAg[tau:1]}
tcSkolemise
tcInferId
  gravityOnEarth :: Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
tcCheckId
  gravityOnEarth
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  Check{Quantity a0_acAf[tau:1] u0_acAg[tau:1]}
tcWrapResult
  Actual:   Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  Expected: Check{Quantity a0_acAf[tau:1] u0_acAg[tau:1]}
tc_sub_type_ds
  ty_actual   = Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  ty_expected = Quantity a0_acAf[tau:1] u0_acAg[tau:1]
deeply_instantiate final subst
  origin: arising from a use of ‘gravityOnEarth’
  type: Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  new type: Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Quantity Double (MkUnit "m" /: (MkUnit "s" ^: 2))
  ~
  Quantity a0_acAf[tau:1] u0_acAg[tau:1]
  arising from a type equality Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2))
                               ~
                               Quantity a0_acAf[tau:1] u0_acAg[tau:1]
u_tys
  tclvl 1
  Double ~ a0_acAf[tau:1]
  arising from a type equality Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2))
                               ~
                               Quantity a0_acAf[tau:1] u0_acAg[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from a0_acAf[tau:1] ~ Double
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from a0_acAf[tau:1] ~ Double
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_acAf[tau:1] :: * := Double
u_tys yields no coercion
u_tys
  tclvl 1
  MkUnit "m" /: (MkUnit "s" ^: 2) ~ u0_acAg[tau:1]
  arising from a type equality Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2))
                               ~
                               Quantity a0_acAf[tau:1] u0_acAg[tau:1]
New coercion hole: acAj
utype_defer
  U(hole:{acAj}, MkUnit "m" /: (MkUnit "s" ^: 2), u0_acAg[tau:1])_N
  MkUnit "m" /: (MkUnit "s" ^: 2)
  u0_acAg[tau:1]
  arising from a type equality Quantity
                                 Double (MkUnit "m" /: (MkUnit "s" ^: 2))
                               ~
                               Quantity a0_acAf[tau:1] u0_acAg[tau:1]
  In the first argument of ‘showQuantity’, namely ‘gravityOnEarth’
  In the first argument of ‘(@?=)’, namely
    ‘showQuantity gravityOnEarth’
  In the second argument of ‘($)’, namely
    ‘showQuantity gravityOnEarth @?= "9.808 m / s^2"’
u_tys yields coercion:
  U(hole:{acAj}, MkUnit "m" /: (MkUnit "s" ^: 2), u0_acAg[tau:1])_N
u_tys yields coercion: (Quantity <Double>_N {acAj})_N
tc_sub_type_ds
  ty_actual   = String
  ty_expected = a0_acAb[tau:1]
deeply_instantiate final subst
  origin: arising from a use of ‘showQuantity’
  type: String
  new type: String
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  String ~ a0_acAb[tau:1]
  arising from a type equality String ~ a0_acAb[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from a0_acAb[tau:1] ~ String
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from a0_acAb[tau:1] ~ String
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_acAb[tau:1] :: * := String
u_tys yields no coercion
tcPolyExprNC Check{a0_acAb[tau:1]}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{a0_acAb[tau:1]}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = a0_acAb[tau:1]
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ a0_acAb[tau:1]
  arising from a type equality [Char] ~ a0_acAb[tau:1]
found filled tyvar a_acAb[tau:1] :-> String
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ a0_acAb[tau:1]
u_tys yields no coercion
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = Assertion
  ty_expected = Assertion
deeply_instantiate final subst
  origin: arising from a use of ‘@?=’
  type: Assertion
  new type: Assertion
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Assertion ~ Assertion
  arising from a type equality Assertion ~ Assertion
u_tys yields no coercion
u_tys
  tclvl 1
  * ~ *
  arising from a type equality * ~ *
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a type equality * ~ *
u_tys yields no coercion
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = TestTree
  ty_expected = TestTree
deeply_instantiate final subst
  origin: arising from a use of ‘testCase’
  type: TestTree
  new type: TestTree
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  TestTree ~ TestTree
  arising from a type equality TestTree ~ TestTree
u_tys yields no coercion
tcPolyExpr Check{TestTree}
tcPolyExprNC Check{TestTree}
tcSkolemise
Application rule ($)
newOpenInferExpType acAk False 1
tcInferId testCase :: TestName -> Assertion -> TestTree
tcPolyExprNC Check{TestName}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{TestName}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = TestName
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ TestName
  arising from a type equality [Char] ~ TestName
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ TestName
u_tys yields no coercion
u_tys yields no coercion
u_tys
  tclvl 1
  * ~ TYPE t0_acAl[tau:1]
  arising from a type equality * ~ TYPE t0_acAl[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t0_acAl[tau:1]
  arising from a type equality * ~ TYPE t0_acAl[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t0_acAl[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_acAl[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
Filling ExpType acAk := Assertion -> TestTree
tcPolyExprNC Check{Assertion}
tcSkolemise
Non Application rule (@?=)
tcInferId
  @?= :: forall a.
         (Eq a, Show a, HasCallStack) =>
         a -> a -> Assertion
instCallConstraints [$dEq_acAn, $dShow_acAo, $dIP_acAp]
Instantiating
  all tyvars? True
  origin arising from a use of ‘@?=’
  type forall a. (Eq a, Show a, HasCallStack) => a -> a -> Assertion
  theta [Eq a_ackJ, Show a_ackJ, HasCallStack]
  leave_bndrs []
  with [a_acAm[tau:1]]
  theta: [Eq a0_acAm[tau:1], Show a0_acAm[tau:1], HasCallStack]
tcPolyExprNC Check{a0_acAm[tau:1]}
tcSkolemise
tcInferId
  showQuantity :: forall a (u :: Unit).
                  (Show a, KnownUnit (Unpack u)) =>
                  Quantity a u -> String
instCallConstraints [$dShow_acAs, $dKnownUnit_acAt]
Instantiating
  all tyvars? True
  origin arising from a use of ‘showQuantity’
  type forall a (u :: Unit).
       (Show a, KnownUnit (Unpack u)) =>
       Quantity a u -> String
  theta [Show a_acxF, KnownUnit (Unpack u_acxG)]
  leave_bndrs []
  with [a_acAq[tau:1], u_acAr[tau:1]]
  theta: [Show a0_acAq[tau:1], KnownUnit (Unpack u0_acAr[tau:1])]
tcPolyExprNC Check{Quantity a0_acAq[tau:1] u0_acAr[tau:1]}
tcSkolemise
tcInferId forceOnGround :: Quantity Double (MkUnit "N")
tcCheckId
  forceOnGround
  Quantity Double (MkUnit "N")
  Check{Quantity a0_acAq[tau:1] u0_acAr[tau:1]}
tcWrapResult
  Actual:   Quantity Double (MkUnit "N")
  Expected: Check{Quantity a0_acAq[tau:1] u0_acAr[tau:1]}
tc_sub_type_ds
  ty_actual   = Quantity Double (MkUnit "N")
  ty_expected = Quantity a0_acAq[tau:1] u0_acAr[tau:1]
deeply_instantiate final subst
  origin: arising from a use of ‘forceOnGround’
  type: Quantity Double (MkUnit "N")
  new type: Quantity Double (MkUnit "N")
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Quantity Double (MkUnit "N")
  ~
  Quantity a0_acAq[tau:1] u0_acAr[tau:1]
  arising from a type equality Quantity Double (MkUnit "N")
                               ~
                               Quantity a0_acAq[tau:1] u0_acAr[tau:1]
u_tys
  tclvl 1
  Double ~ a0_acAq[tau:1]
  arising from a type equality Quantity Double (MkUnit "N")
                               ~
                               Quantity a0_acAq[tau:1] u0_acAr[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from a0_acAq[tau:1] ~ Double
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from a0_acAq[tau:1] ~ Double
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_acAq[tau:1] :: * := Double
u_tys yields no coercion
u_tys
  tclvl 1
  MkUnit "N" ~ u0_acAr[tau:1]
  arising from a type equality Quantity Double (MkUnit "N")
                               ~
                               Quantity a0_acAq[tau:1] u0_acAr[tau:1]
New coercion hole: acAu
utype_defer
  U(hole:{acAu}, MkUnit "N", u0_acAr[tau:1])_N
  MkUnit "N"
  u0_acAr[tau:1]
  arising from a type equality Quantity Double (MkUnit "N")
                               ~
                               Quantity a0_acAq[tau:1] u0_acAr[tau:1]
  In the first argument of ‘showQuantity’, namely ‘forceOnGround’
  In the first argument of ‘(@?=)’, namely
    ‘showQuantity forceOnGround’
  In the second argument of ‘($)’, namely
    ‘showQuantity forceOnGround @?= "637.52 kg m / s^2"’
u_tys yields coercion: U(hole:{acAu}, MkUnit "N", u0_acAr[tau:1])_N
u_tys yields coercion: (Quantity <Double>_N {acAu})_N
tc_sub_type_ds
  ty_actual   = String
  ty_expected = a0_acAm[tau:1]
deeply_instantiate final subst
  origin: arising from a use of ‘showQuantity’
  type: String
  new type: String
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  String ~ a0_acAm[tau:1]
  arising from a type equality String ~ a0_acAm[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from a0_acAm[tau:1] ~ String
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from a0_acAm[tau:1] ~ String
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_acAm[tau:1] :: * := String
u_tys yields no coercion
tcPolyExprNC Check{a0_acAm[tau:1]}
tcSkolemise
tcWrapResult
  Actual:   [Char]
  Expected: Check{a0_acAm[tau:1]}
tc_sub_type_ds
  ty_actual   = [Char]
  ty_expected = a0_acAm[tau:1]
deeply_instantiate final subst
  origin: << This should not appear in error messages. If you see this
          in an error message, please report a bug mentioning ‘concrete literal’ at
          https://ghc.haskell.org/trac/ghc/wiki/ReportABug >>
  type: [Char]
  new type: [Char]
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  [Char] ~ a0_acAm[tau:1]
  arising from a type equality [Char] ~ a0_acAm[tau:1]
found filled tyvar a_acAm[tau:1] :-> String
u_tys
  tclvl 1
  Char ~ Char
  arising from a type equality [Char] ~ a0_acAm[tau:1]
u_tys yields no coercion
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = Assertion
  ty_expected = Assertion
deeply_instantiate final subst
  origin: arising from a use of ‘@?=’
  type: Assertion
  new type: Assertion
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Assertion ~ Assertion
  arising from a type equality Assertion ~ Assertion
u_tys yields no coercion
u_tys
  tclvl 1
  * ~ *
  arising from a type equality * ~ *
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a type equality * ~ *
u_tys yields no coercion
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = TestTree
  ty_expected = TestTree
deeply_instantiate final subst
  origin: arising from a use of ‘testCase’
  type: TestTree
  new type: TestTree
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  TestTree ~ TestTree
  arising from a type equality TestTree ~ TestTree
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = TestTree
  ty_expected = TestTree
deeply_instantiate final subst
  origin: arising from a use of ‘testGroup’
  type: TestTree
  new type: TestTree
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  TestTree ~ TestTree
  arising from a type equality TestTree ~ TestTree
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = TestTree
  ty_expected = TestTree
deeply_instantiate final subst
  origin: arising from a use of ‘testGroup’
  type: TestTree
  new type: TestTree
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  TestTree ~ TestTree
  arising from a type equality TestTree ~ TestTree
u_tys yields no coercion
tcSpecPrags tests []
} End of bindings for
  [tests]
  NonRecursive
  tests TestTree
tcExtendIdBndrs [tests[<TopLevel>]]
env2 [(tests, Identifier[tests::TestTree, TopLevelLet])]
------------------------------------------------
Bindings for { [main]
Generalisation plan CheckGen main :: IO ()
tcPolyCheck
  main
  test-suite-force/Tests.hs:51:1-13
tcExtendIdBndrs [main_acAv[<NotTopLevel>]]
env2 []
tcMatchesFun
  main_acAv
  Check{IO ()}
tcSkolemise
tcBody Check{IO ()}
tcInferId defaultMain :: TestTree -> IO ()
tcPolyExprNC Check{TestTree}
tcSkolemise
tcInferId tests :: TestTree
tcCheckId
  tests
  TestTree
  Check{TestTree}
tcWrapResult
  Actual:   TestTree
  Expected: Check{TestTree}
tc_sub_type_ds
  ty_actual   = TestTree
  ty_expected = TestTree
deeply_instantiate final subst
  origin: arising from a use of ‘tests’
  type: TestTree
  new type: TestTree
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  TestTree ~ TestTree
  arising from a type equality TestTree ~ TestTree
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = IO ()
  ty_expected = IO ()
deeply_instantiate final subst
  origin: arising from a use of ‘defaultMain’
  type: IO ()
  new type: IO ()
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  IO () ~ IO ()
  arising from a type equality IO () ~ IO ()
u_tys
  tclvl 1
  () ~ ()
  arising from a type equality IO () ~ IO ()
u_tys yields no coercion
u_tys yields no coercion
tcSpecPrags main []
} End of bindings for
  [main]
  NonRecursive
  main IO ()
tcExtendIdBndrs [main[<TopLevel>]]
env2 [(main, Identifier[main::IO (), TopLevelLet])]
complete_matches
  [(NonRecursive,
    {gravityOnEarth
       = ((Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
             a_abZ3
             -> Quantity a_abZ3 ((/:) (MkUnit "m") ((*:) (MkUnit "s") (MkUnit "s"))))
            9.808)}),
   (NonRecursive,
    {myMass
       = ((Data.UnitsOfMeasure.Unsafe.Quantity.MkQuantity ::
             a_abYY -> Quantity a_abYY (MkUnit "kg"))
            65)}),
   (NonRecursive, {forceOnGround = gravityOnEarth *: myMass}),
   (NonRecursive,
    {tests
       = testGroup
           "uom-plugin:units"
           [testGroup
              "showQuantity"
              [testCase "myMass" $ showQuantity myMass @?= "65.0 kg",
               testCase "gravityOnEarth"
                 $ showQuantity gravityOnEarth @?= "9.808 m / s^2",
               testCase "forceOnGround"
                 $ showQuantity forceOnGround @?= "637.52 kg m / s^2"]]}),
   (NonRecursive, {main = defaultMain tests})]
  [tests :: TestTree, main :: IO (),
   forceOnGround :: Quantity Double (MkUnit "N"),
   gravityOnEarth ::
     Quantity Double ((/:) (MkUnit "m") ((^:) (MkUnit "s") 2)),
   myMass :: Quantity Double (Base "kg")]
complete_matches []
txExtendKindEnvList []
env2 []
complete_matches
  []
  []
complete_matches []
Tc6
Tc7
End of tcVectDecls: LIE:
  WC {wc_simple =
        [WD] $dFractional_aciw {0}:: Fractional
                                       a0_aciv[tau:1] (CNonCanonical)
        [WD] hole{acix} {0}:: ((MkUnit "m"
                                /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                              GHC.Prim.~#
                              ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit) (CNonCanonical)
        [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
        [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                              GHC.Prim.~#
                              (Base "kg" :: Unit) (CNonCanonical)
        [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
        [WD] irred_acky {0}:: w0_acku[tau:1]
                              Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                             *: v0_ackw[tau:1]) (CNonCanonical)
        [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                              GHC.Prim.~#
                              (u0_ackv[tau:1] :: Unit) (CNonCanonical)
        [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                              GHC.Prim.~#
                              (v0_ackw[tau:1] :: Unit) (CNonCanonical)
        [WD] hole{ackB} {0}:: (w0_acku[tau:1] :: Unit)
                              GHC.Prim.~#
                              (MkUnit "N" :: Unit) (CNonCanonical)
        [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
        [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
        [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
        [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
        [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                      (Unpack u0_acA5[tau:1]) (CNonCanonical)
        [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                              GHC.Prim.~#
                              (u0_acA5[tau:1] :: Unit) (CNonCanonical)
        [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
        [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
        [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
        [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
        [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                      (Unpack u0_acAg[tau:1]) (CNonCanonical)
        [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                              GHC.Prim.~#
                              (u0_acAg[tau:1] :: Unit) (CNonCanonical)
        [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
        [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
        [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
        [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
        [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                      (Unpack u0_acAr[tau:1]) (CNonCanonical)
        [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                              GHC.Prim.~#
                              (u0_acAr[tau:1] :: Unit) (CNonCanonical)
      wc_impl =
        Implic {
          TcLevel = 2
          Skolems = a_acih[sk:2]
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] hole{acik} {0}:: (u0_acij[tau:2] :: Unit)
                                        GHC.Prim.~#
                                        ((MkUnit "m"
                                          /: (MkUnit "s" *: MkUnit "s")) :: Unit) (CNonCanonical)}
          Binds = EvBindsVar<acil>
          Needed = []
          an expression type signature:
            forall a.
            a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s")) }
        Implic {
          TcLevel = 2
          Skolems = a_aciL[sk:2]
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] hole{aciO} {0}:: (u0_aciN[tau:2] :: Unit)
                                        GHC.Prim.~#
                                        (MkUnit "kg" :: Unit) (CNonCanonical)}
          Binds = EvBindsVar<aciP>
          Needed = []
          an expression type signature:
            forall a. a -> Quantity a (MkUnit "kg") }}
Tc7a
checkMain found Main main
tcInferId main :: IO ()
tcCheckId
  main
  IO ()
  Check{IO t0_acAx[tau:1]}
tcWrapResult
  Actual:   IO ()
  Expected: Check{IO t0_acAx[tau:1]}
tc_sub_type_ds
  ty_actual   = IO ()
  ty_expected = IO t0_acAx[tau:1]
deeply_instantiate final subst
  origin: arising from a use of ‘main’
  type: IO ()
  new type: IO ()
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  IO () ~ IO t0_acAx[tau:1]
  arising from a type equality IO () ~ IO t0_acAx[tau:1]
u_tys
  tclvl 1
  () ~ t0_acAx[tau:1]
  arising from a type equality IO () ~ IO t0_acAx[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from t0_acAx[tau:1] ~ ()
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from t0_acAx[tau:1] ~ ()
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar t_acAx[tau:1] :: * := ()
u_tys yields no coercion
u_tys yields no coercion
simplifyTop {
  wanted =  WC {wc_simple =
                  [WD] $dFractional_aciw {0}:: Fractional
                                                 a0_aciv[tau:1] (CNonCanonical)
                  [WD] hole{acix} {0}:: ((MkUnit "m"
                                          /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                                        GHC.Prim.~#
                                        ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit) (CNonCanonical)
                  [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                  [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                                        GHC.Prim.~#
                                        (Base "kg" :: Unit) (CNonCanonical)
                  [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                  [WD] irred_acky {0}:: w0_acku[tau:1]
                                        Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                       *: v0_ackw[tau:1]) (CNonCanonical)
                  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                        GHC.Prim.~#
                                        (u0_ackv[tau:1] :: Unit) (CNonCanonical)
                  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                        GHC.Prim.~#
                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                  [WD] hole{ackB} {0}:: (w0_acku[tau:1] :: Unit)
                                        GHC.Prim.~#
                                        (MkUnit "N" :: Unit) (CNonCanonical)
                  [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                  [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                  [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                  [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                  [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                (Unpack u0_acA5[tau:1]) (CNonCanonical)
                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                        GHC.Prim.~#
                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                  [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                  [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                  [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                  [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                  [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                (Unpack u0_acAg[tau:1]) (CNonCanonical)
                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                        GHC.Prim.~#
                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                  [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                  [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                  [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                  [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                  [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                (Unpack u0_acAr[tau:1]) (CNonCanonical)
                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                        GHC.Prim.~#
                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                wc_impl =
                  Implic {
                    TcLevel = 2
                    Skolems = a_acih[sk:2]
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] hole{acik} {0}:: (u0_acij[tau:2] :: Unit)
                                                  GHC.Prim.~#
                                                  ((MkUnit "m"
                                                    /: (MkUnit "s"
                                                        *: MkUnit "s")) :: Unit) (CNonCanonical)}
                    Binds = EvBindsVar<acil>
                    Needed = []
                    an expression type signature:
                      forall a.
                      a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s")) }
                  Implic {
                    TcLevel = 2
                    Skolems = a_aciL[sk:2]
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] hole{aciO} {0}:: (u0_aciN[tau:2] :: Unit)
                                                  GHC.Prim.~#
                                                  (MkUnit "kg" :: Unit) (CNonCanonical)}
                    Binds = EvBindsVar<aciP>
                    Needed = []
                    an expression type signature:
                      forall a. a -> Quantity a (MkUnit "kg") }}
newTcEvBinds unique = acC4
solveWanteds {
  WC {wc_simple =
        [WD] $dFractional_aciw {0}:: Fractional
                                       a0_aciv[tau:1] (CNonCanonical)
        [WD] hole{acix} {0}:: ((MkUnit "m"
                                /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                              GHC.Prim.~#
                              ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit) (CNonCanonical)
        [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
        [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                              GHC.Prim.~#
                              (Base "kg" :: Unit) (CNonCanonical)
        [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
        [WD] irred_acky {0}:: w0_acku[tau:1]
                              Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                             *: v0_ackw[tau:1]) (CNonCanonical)
        [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                              GHC.Prim.~#
                              (u0_ackv[tau:1] :: Unit) (CNonCanonical)
        [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                              GHC.Prim.~#
                              (v0_ackw[tau:1] :: Unit) (CNonCanonical)
        [WD] hole{ackB} {0}:: (w0_acku[tau:1] :: Unit)
                              GHC.Prim.~#
                              (MkUnit "N" :: Unit) (CNonCanonical)
        [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
        [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
        [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
        [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
        [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                      (Unpack u0_acA5[tau:1]) (CNonCanonical)
        [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                              GHC.Prim.~#
                              (u0_acA5[tau:1] :: Unit) (CNonCanonical)
        [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
        [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
        [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
        [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
        [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                      (Unpack u0_acAg[tau:1]) (CNonCanonical)
        [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                              GHC.Prim.~#
                              (u0_acAg[tau:1] :: Unit) (CNonCanonical)
        [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
        [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
        [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
        [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
        [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                      (Unpack u0_acAr[tau:1]) (CNonCanonical)
        [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                              GHC.Prim.~#
                              (u0_acAr[tau:1] :: Unit) (CNonCanonical)
      wc_impl =
        Implic {
          TcLevel = 2
          Skolems = a_acih[sk:2]
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] hole{acik} {0}:: (u0_acij[tau:2] :: Unit)
                                        GHC.Prim.~#
                                        ((MkUnit "m"
                                          /: (MkUnit "s" *: MkUnit "s")) :: Unit) (CNonCanonical)}
          Binds = EvBindsVar<acil>
          Needed = []
          an expression type signature:
            forall a.
            a -> Quantity a (MkUnit "m" /: (MkUnit "s" *: MkUnit "s")) }
        Implic {
          TcLevel = 2
          Skolems = a_aciL[sk:2]
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] hole{aciO} {0}:: (u0_aciN[tau:2] :: Unit)
                                        GHC.Prim.~#
                                        (MkUnit "kg" :: Unit) (CNonCanonical)}
          Binds = EvBindsVar<aciP>
          Needed = []
          an expression type signature:
            forall a. a -> Quantity a (MkUnit "kg") }}
solveSimpleWanteds {
  {[WD] $dFractional_aciw {0}:: Fractional
                                  a0_aciv[tau:1] (CNonCanonical),
   [WD] hole{acix} {0}:: ((MkUnit "m"
                           /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                         GHC.Prim.~#
                         ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit) (CNonCanonical),
   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical),
   [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                         GHC.Prim.~#
                         (Base "kg" :: Unit) (CNonCanonical),
   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical),
   [WD] irred_acky {0}:: w0_acku[tau:1]
                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                        *: v0_ackw[tau:1]) (CNonCanonical),
   [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                         GHC.Prim.~#
                         (u0_ackv[tau:1] :: Unit) (CNonCanonical),
   [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                         GHC.Prim.~#
                         (v0_ackw[tau:1] :: Unit) (CNonCanonical),
   [WD] hole{ackB} {0}:: (w0_acku[tau:1] :: Unit)
                         GHC.Prim.~#
                         (MkUnit "N" :: Unit) (CNonCanonical),
   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical),
   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical),
   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical),
   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical),
   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                 (Unpack u0_acA5[tau:1]) (CNonCanonical),
   [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                         GHC.Prim.~#
                         (u0_acA5[tau:1] :: Unit) (CNonCanonical),
   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical),
   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical),
   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical),
   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical),
   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                 (Unpack u0_acAg[tau:1]) (CNonCanonical),
   [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                         GHC.Prim.~#
                         (u0_acAg[tau:1] :: Unit) (CNonCanonical),
   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical),
   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical),
   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical),
   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical),
   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                 (Unpack u0_acAr[tau:1]) (CNonCanonical),
   [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                         GHC.Prim.~#
                         (u0_acAr[tau:1] :: Unit) (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{ackB} {0}:: (w0_acku[tau:1] :: Unit)
                                    GHC.Prim.~#
                                    (MkUnit "N" :: Unit) (CNonCanonical)
  inerts = {Unsolved goals = 0}
  rest of worklist = WL {Funeqs = [WD] hole{acix} {0}:: ((MkUnit "m"
                                                          /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                                                        GHC.Prim.~#
                                                        ((MkUnit "m"
                                                          /: (MkUnit "s"
                                                              ^: 2)) :: Unit) (CNonCanonical)
                                  [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (Base "kg" :: Unit) (CNonCanonical)
                                  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_ackv[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{ackB} {0}:: (w0_acku[tau:1] :: Unit)
                                      GHC.Prim.~#
                                      (MkUnit "N" :: Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{ackB} {0}:: (w0_acku[tau:1] :: Unit)
                        GHC.Prim.~#
                        (MkUnit "N" :: Unit) (CNonCanonical)
canEvNC:eq
  w0_acku[tau:1]
  MkUnit "N"
can_eq_nc
  False
  [WD] hole{ackB} {0}:: (w0_acku[tau:1] :: Unit)
                        GHC.Prim.~#
                        (MkUnit "N" :: Unit)
  nominal equality
  w0_acku[tau:1]
  w0_acku[tau:1]
  MkUnit "N"
  MkUnit "N"
flatten { FM_FlattenAll w0_acku[tau:1]
Unfilled tyvar w_acku[tau:1]
flatten } w0_acku[tau:1]
flatten { FM_FlattenAll MkUnit "N"
matchFamTcM
  Matching: MkUnit "N"
  Match succeeded:
    Rewrites to: (MkUnit "kg" *: MkUnit "m") /: (MkUnit "s" ^: 2)
    Coercion: UnitDefs.D:R:MkUnit"N"[0]
Eager T.F. reduction success
  MkUnit
  ["N"]
  (MkUnit "kg" *: MkUnit "m") /: (MkUnit "s" ^: 2)
  UnitDefs.D:R:MkUnit"N"[0] :: MkUnit "N" ~ (MkUnit "kg"
                                             *: MkUnit "m")
                                            /: (MkUnit "s" ^: 2)
  False
matchFamTcM
  Matching: (MkUnit "kg" *: MkUnit "m") /: (MkUnit "s" ^: 2)
  Match failed
matchFamTcM
  Matching: MkUnit "kg" *: MkUnit "m"
  Match failed
matchFamTcM
  Matching: MkUnit "kg"
  Match succeeded:
    Rewrites to: Base "kg"
    Coercion: UnitDefs.D:R:MkUnit"kg"[0]
Eager T.F. reduction success
  MkUnit
  ["kg"]
  Base "kg"
  UnitDefs.D:R:MkUnit"kg"[0] :: MkUnit "kg" ~ Base "kg"
  False
matchFamTcM
  Matching: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
New coercion hole: acC6
Emitting new coercion hole
  {acC6} :: (Base "kg" :: Unit) GHC.Prim.~# (s0_acC5[fuv:0] :: Unit)
extendFlatCache
  Base ["kg"]
  [WD]
  s0_acC5[fuv:0]
flatten/flat-cache miss
  Base ["kg"]
  s_acC5[fuv:0]
  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (s0_acC5[fuv:0] :: Unit)
matchFamTcM
  Matching: MkUnit "m"
  Match succeeded:
    Rewrites to: Base "m"
    Coercion: UnitDefs.D:R:MkUnit"m"[0]
Eager T.F. reduction success
  MkUnit
  ["m"]
  Base "m"
  UnitDefs.D:R:MkUnit"m"[0] :: MkUnit "m" ~ Base "m"
  False
matchFamTcM
  Matching: Base "m"
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
New coercion hole: acC8
Emitting new coercion hole
  {acC8} :: (Base "m" :: Unit) GHC.Prim.~# (s0_acC7[fuv:0] :: Unit)
extendFlatCache
  Base ["m"]
  [WD]
  s0_acC7[fuv:0]
flatten/flat-cache miss
  Base ["m"]
  s_acC7[fuv:0]
  [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                        GHC.Prim.~#
                        (s0_acC7[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acC5[fuv:0] *: s1_acC7[fuv:0]
  Match failed
New coercion hole: acCa
Emitting new coercion hole
  {acCa} :: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acC9[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acC5[fuv:0], s0_acC7[fuv:0]]
  [WD]
  s0_acC9[fuv:0]
flatten/flat-cache miss
  *: [s0_acC5[fuv:0], s0_acC7[fuv:0]]
  s_acC9[fuv:0]
  [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acC9[fuv:0] :: Unit)
matchFamTcM
  Matching: MkUnit "s" ^: 2
  Match succeeded:
    Rewrites to: MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
    Coercion: Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N
Eager T.F. reduction success
  ^:
  [MkUnit "s", 2]
  MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N :: MkUnit "s"
                                                    ^: 2 ~ MkUnit "s"
                                                           *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  False
matchFamTcM
  Matching: MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  Match failed
matchFamTcM
  Matching: MkUnit "s"
  Match succeeded:
    Rewrites to: Base "s"
    Coercion: UnitDefs.D:R:MkUnit"s"[0]
Eager T.F. reduction success
  MkUnit
  ["s"]
  Base "s"
  UnitDefs.D:R:MkUnit"s"[0] :: MkUnit "s" ~ Base "s"
  False
matchFamTcM
  Matching: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
New coercion hole: acCh
Emitting new coercion hole
  {acCh} :: (Base "s" :: Unit) GHC.Prim.~# (s0_acCg[fuv:0] :: Unit)
extendFlatCache
  Base ["s"]
  [WD]
  s0_acCg[fuv:0]
flatten/flat-cache miss
  Base ["s"]
  s_acCg[fuv:0]
  [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                        GHC.Prim.~#
                        (s0_acCg[fuv:0] :: Unit)
matchFamTcM
  Matching: MkUnit "s" ^: (2 GHC.TypeNats.- 1)
  Match failed
matchFamTcM
  Matching: MkUnit "s"
  Match succeeded:
    Rewrites to: Base "s"
    Coercion: UnitDefs.D:R:MkUnit"s"[0]
Eager T.F. reduction success
  MkUnit
  ["s"]
  Base "s"
  UnitDefs.D:R:MkUnit"s"[0] :: MkUnit "s" ~ Base "s"
  False
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
matchFamTcM
  Matching: 2 GHC.TypeNats.- 1
  Match succeeded:
    Rewrites to: 1
    Coercion: (SubDef (<2>_N, <1>_N))
Eager T.F. reduction success
  GHC.TypeNats.-
  [2, 1]
  1
  (SubDef (<2>_N, <1>_N)) :: 2 GHC.TypeNats.- 1 ~ 1
  False
matchFamTcM
  Matching: s0_acCg[fuv:0] ^: 1
  Match succeeded:
    Rewrites to: s0_acCg[fuv:0]
    Coercion: Data.Theory.UoM.D:R:^:[1] <s0_acCg[fuv:0]>_N
Eager T.F. reduction success
  ^:
  [s0_acCg[fuv:0], 1]
  s0_acCg[fuv:0]
  Data.Theory.UoM.D:R:^:[1] <s0_acCg[fuv:0]>_N :: s0_acCg[fuv:0]
                                                  ^: 1 ~ s0_acCg[fuv:0]
  True
Unfilled tyvar s_acCg[fuv:0]
extendFlatCache
  ^: [s0_acCg[fuv:0], 1]
  [WD]
  s0_acCg[fuv:0]
matchFamTcM
  Matching: s0_acCg[fuv:0] *: s0_acCg[fuv:0]
  Match failed
New coercion hole: acCj
Emitting new coercion hole
  {acCj} :: ((s0_acCg[fuv:0] *: s0_acCg[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s1_acCi[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acCg[fuv:0], s0_acCg[fuv:0]]
  [WD]
  s0_acCi[fuv:0]
flatten/flat-cache miss
  *: [s0_acCg[fuv:0], s0_acCg[fuv:0]]
  s_acCi[fuv:0]
  [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0] *: s0_acCg[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s1_acCi[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acC9[fuv:0] /: s1_acCi[fuv:0]
  Match failed
New coercion hole: acCl
Emitting new coercion hole
  {acCl} :: ((s0_acC9[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acCk[fuv:0] :: Unit)
extendFlatCache
  /: [s0_acC9[fuv:0], s0_acCi[fuv:0]]
  [WD]
  s0_acCk[fuv:0]
flatten/flat-cache miss
  /: [s0_acC9[fuv:0], s0_acCi[fuv:0]]
  s_acCk[fuv:0]
  [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCk[fuv:0] :: Unit)
flatten } s0_acCk[fuv:0]
New coercion hole: acCm
Emitting new coercion hole
  {acCm} :: (w0_acku[tau:1] :: Unit)
            GHC.Prim.~#
            (s0_acCk[fuv:0] :: Unit)
Filling coercion hole
  ackB := U(hole:{acCm}, w0_acku[tau:1], s0_acCk[fuv:0])_N
          ; Sym
              (UnitDefs.D:R:MkUnit"N"[0]
               ; Sym
                   (Sym
                      U(hole:{acCl}, s0_acC9[fuv:0] /: s1_acCi[fuv:0], s0_acCk[fuv:0])_N
                    ; (Trans
                           (Sym {acCa})
                           (Sym (Trans (UnitDefs.D:R:MkUnit"kg"[0]) {acC6})
                            *: Sym (Trans (UnitDefs.D:R:MkUnit"m"[0]) {acC8}))_N
                       /: Sym (Trans
                                   (Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N)
                                   (Sym (Trans
                                             (Sym {acCj})
                                             (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                              *: Trans
                                                     (Sym (Data.Theory.UoM.D:R:^:[1] <s>_N))
                                                     (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                                      ^: Sym (SubDef (<2>_N, <1>_N)))_N)_N))))_N))
rewriteEqEvidence
  [WD] hole{ackB} {0}:: (w0_acku[tau:1] :: Unit)
                        GHC.Prim.~#
                        (MkUnit "N" :: Unit)
  w0_acku[tau:1]
  s0_acCk[fuv:0]
  U(hole:{acCm}, w0_acku[tau:1], s0_acCk[fuv:0])_N
  ; Sym
      (UnitDefs.D:R:MkUnit"N"[0]
       ; Sym
           (Sym
              U(hole:{acCl}, s0_acC9[fuv:0] /: s1_acCi[fuv:0], s0_acCk[fuv:0])_N
            ; (Trans
                   (Sym {acCa})
                   (Sym (Trans (UnitDefs.D:R:MkUnit"kg"[0]) {acC6})
                    *: Sym (Trans (UnitDefs.D:R:MkUnit"m"[0]) {acC8}))_N
               /: Sym (Trans
                           (Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N)
                           (Sym (Trans
                                     (Sym {acCj})
                                     (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                      *: Trans
                                             (Sym (Data.Theory.UoM.D:R:^:[1] <s>_N))
                                             (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                              ^: Sym (SubDef (<2>_N, <1>_N)))_N)_N))))_N))
canEqTyVar
  w_acku[tau:1]
  s_acCk[fuv:0]
  Not-swapped
New coercion hole: acCn
Emitting new coercion hole
  {acCn} :: (s0_acCk[fuv:0] :: Unit)
            GHC.Prim.~#
            (w0_acku[tau:1] :: Unit)
Filling coercion hole
  acCm := Sym U(hole:{acCn}, s0_acCk[fuv:0], w0_acku[tau:1])_N
rewriteEqEvidence
  [WD] hole{acCm} {1}:: (w0_acku[tau:1] :: Unit)
                        GHC.Prim.~#
                        (s0_acCk[fuv:0] :: Unit)
  s0_acCk[fuv:0]
  w0_acku[tau:1]
  Sym U(hole:{acCn}, s0_acCk[fuv:0], w0_acku[tau:1])_N
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (w0_acku[tau:1] :: Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_acCk[fuv:0] :: Unit
      TcLevel of s_acCk[fuv:0] is 0
  RHS: w0_acku[tau:1] :: Unit
addInertEq {
  Adding new inert equality: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                                   GHC.Prim.~#
                                                   (w0_acku[tau:1] :: Unit) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 1[l:1,d:2] Kept as inert:
    [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (w0_acku[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{acC8} {2}:: (Base
                                                           "m" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0] *: s0_acCg[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acix} {0}:: ((MkUnit "m"
                                                          /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                                                        GHC.Prim.~#
                                                        ((MkUnit "m"
                                                          /: (MkUnit "s"
                                                              ^: 2)) :: Unit) (CNonCanonical)
                                  [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (Base "kg" :: Unit) (CNonCanonical)
                                  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_ackv[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "kg"
flatten } "kg"
extendFlatCache
  Base ["kg"]
  [WD]
  s0_acC5[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "kg"
  Match failed
improveTopFunEqs
  Base ["kg"] s_acC5[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acC6} {2}:: (Base
                                                                   "kg" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 2[l:1,d:2] Kept as inert:
    [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                          GHC.Prim.~#
                          (s0_acC5[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                          *: s1_acC7[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0] *: s0_acCg[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acix} {0}:: ((MkUnit "m"
                                                          /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                                                        GHC.Prim.~#
                                                        ((MkUnit "m"
                                                          /: (MkUnit "s"
                                                              ^: 2)) :: Unit) (CNonCanonical)
                                  [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (Base "kg" :: Unit) (CNonCanonical)
                                  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_ackv[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "m"
flatten } "m"
extendFlatCache
  Base ["m"]
  [WD]
  s0_acC7[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                        GHC.Prim.~#
                        (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "m"
  Match failed
improveTopFunEqs
  Base ["m"] s_acC7[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acC8} {2}:: (Base
                                                                   "m" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 3[l:1,d:2] Kept as inert:
    [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                          GHC.Prim.~#
                          (s0_acC7[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                      *: s1_acC7[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{acCh} {3}:: (Base
                                                           "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0] *: s0_acCg[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acix} {0}:: ((MkUnit "m"
                                                          /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                                                        GHC.Prim.~#
                                                        ((MkUnit "m"
                                                          /: (MkUnit "s"
                                                              ^: 2)) :: Unit) (CNonCanonical)
                                  [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (Base "kg" :: Unit) (CNonCanonical)
                                  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_ackv[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                        *: s1_acC7[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acC5[fuv:0]
  s0_acC7[fuv:0]
Unfilled tyvar s_acC5[fuv:0]
Unfilled tyvar s_acC7[fuv:0]
flatten }
  s0_acC5[fuv:0]
  s0_acC7[fuv:0]
extendFlatCache
  *: [s0_acC5[fuv:0], s0_acC7[fuv:0]]
  [WD]
  s0_acC9[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                        *: s1_acC7[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                        *: s1_acC7[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acC5[fuv:0] *: s1_acC7[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acC5[fuv:0], s0_acC7[fuv:0]] s_acC9[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                                  *: s1_acC7[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 4[l:1,d:1] Kept as inert:
    [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acC9[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                       *: s1_acC7[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                          *: s0_acCg[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acix} {0}:: ((MkUnit "m"
                                                          /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                                                        GHC.Prim.~#
                                                        ((MkUnit "m"
                                                          /: (MkUnit "s"
                                                              ^: 2)) :: Unit) (CNonCanonical)
                                  [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (Base "kg" :: Unit) (CNonCanonical)
                                  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_ackv[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "s"
flatten } "s"
extendFlatCache
  Base ["s"]
  [WD]
  s0_acCg[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                        GHC.Prim.~#
                        (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "s"
  Match failed
improveTopFunEqs
  Base ["s"] s_acCg[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acCh} {3}:: (Base
                                                                   "s" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 5[l:1,d:3] Kept as inert:
    [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                          GHC.Prim.~#
                          (s0_acCg[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                      *: s0_acCg[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                          /: s1_acCi[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acix} {0}:: ((MkUnit "m"
                                                          /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                                                        GHC.Prim.~#
                                                        ((MkUnit "m"
                                                          /: (MkUnit "s"
                                                              ^: 2)) :: Unit) (CNonCanonical)
                                  [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (Base "kg" :: Unit) (CNonCanonical)
                                  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_ackv[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                        *: s0_acCg[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acCg[fuv:0]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
flatten }
  s0_acCg[fuv:0]
  s0_acCg[fuv:0]
extendFlatCache
  *: [s0_acCg[fuv:0], s0_acCg[fuv:0]]
  [WD]
  s0_acCi[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                        *: s0_acCg[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                        *: s0_acCg[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0] *: s0_acCg[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acCg[fuv:0] *: s0_acCg[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acCg[fuv:0], s0_acCg[fuv:0]] s_acCi[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                                  *: s0_acCg[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 6[l:1,d:2] Kept as inert:
    [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0] *: s0_acCg[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s1_acCi[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                       *: s0_acCg[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                      /: s1_acCi[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{acix} {0}:: ((MkUnit "m"
                                                          /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                                                        GHC.Prim.~#
                                                        ((MkUnit "m"
                                                          /: (MkUnit "s"
                                                              ^: 2)) :: Unit) (CNonCanonical)
                                  [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (Base "kg" :: Unit) (CNonCanonical)
                                  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_ackv[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acC9[fuv:0]
  s0_acCi[fuv:0]
Unfilled tyvar s_acC9[fuv:0]
Unfilled tyvar s_acCi[fuv:0]
flatten }
  s0_acC9[fuv:0]
  s0_acCi[fuv:0]
extendFlatCache
  /: [s0_acC9[fuv:0], s0_acCi[fuv:0]]
  [WD]
  s0_acCk[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acC9[fuv:0] /: s1_acCi[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acC9[fuv:0], s0_acCi[fuv:0]] s_acCk[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                                  /: s1_acCi[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 7[l:1,d:1] Kept as inert:
    [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acCk[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                       /: s1_acCi[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acix} {0}:: ((MkUnit "m"
                                      /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                                    GHC.Prim.~#
                                    ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{ackm} {0}:: (MkUnit
                                                           "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (Base "kg" :: Unit) (CNonCanonical)
                                  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_ackv[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acix} {0}:: ((MkUnit "m"
                                        /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                                      GHC.Prim.~#
                                      ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{acix} {0}:: ((MkUnit "m"
                          /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                        GHC.Prim.~#
                        ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit) (CNonCanonical)
canEvNC:eq
  MkUnit "m" /: (MkUnit "s" *: MkUnit "s")
  MkUnit "m" /: (MkUnit "s" ^: 2)
can_eq_nc
  False
  [WD] hole{acix} {0}:: ((MkUnit "m"
                          /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                        GHC.Prim.~#
                        ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
  nominal equality
  MkUnit "m" /: (MkUnit "s" *: MkUnit "s")
  MkUnit "m" /: (MkUnit "s" *: MkUnit "s")
  MkUnit "m" /: (MkUnit "s" ^: 2)
  MkUnit "m" /: (MkUnit "s" ^: 2)
flatten { FM_FlattenAll MkUnit "m" /: (MkUnit "s" *: MkUnit "s")
matchFamTcM
  Matching: MkUnit "m" /: (MkUnit "s" *: MkUnit "s")
  Match failed
matchFamTcM
  Matching: MkUnit "m"
  Match succeeded:
    Rewrites to: Base "m"
    Coercion: UnitDefs.D:R:MkUnit"m"[0]
Eager T.F. reduction success
  MkUnit
  ["m"]
  Base "m"
  UnitDefs.D:R:MkUnit"m"[0] :: MkUnit "m" ~ Base "m"
  False
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acC7[fuv:0]
Unfilled tyvar s_acC7[fuv:0]
matchFamTcM
  Matching: MkUnit "s" *: MkUnit "s"
  Match failed
matchFamTcM
  Matching: MkUnit "s"
  Match succeeded:
    Rewrites to: Base "s"
    Coercion: UnitDefs.D:R:MkUnit"s"[0]
Eager T.F. reduction success
  MkUnit
  ["s"]
  Base "s"
  UnitDefs.D:R:MkUnit"s"[0] :: MkUnit "s" ~ Base "s"
  False
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
matchFamTcM
  Matching: MkUnit "s"
  Match succeeded:
    Rewrites to: Base "s"
    Coercion: UnitDefs.D:R:MkUnit"s"[0]
Eager T.F. reduction success
  MkUnit
  ["s"]
  Base "s"
  UnitDefs.D:R:MkUnit"s"[0] :: MkUnit "s" ~ Base "s"
  False
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
flatten/flat-cache hit
  *: [s0_acCg[fuv:0], s0_acCg[fuv:0]]
  s0_acCi[fuv:0]
Unfilled tyvar s_acCi[fuv:0]
matchFamTcM
  Matching: s0_acC7[fuv:0] /: s1_acCi[fuv:0]
  Match failed
New coercion hole: acCp
Emitting new coercion hole
  {acCp} :: ((s0_acC7[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acCo[fuv:0] :: Unit)
extendFlatCache
  /: [s0_acC7[fuv:0], s0_acCi[fuv:0]]
  [WD]
  s0_acCo[fuv:0]
flatten/flat-cache miss
  /: [s0_acC7[fuv:0], s0_acCi[fuv:0]]
  s_acCo[fuv:0]
  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCo[fuv:0] :: Unit)
flatten } s0_acCo[fuv:0]
flatten { FM_FlattenAll MkUnit "m" /: (MkUnit "s" ^: 2)
matchFamTcM
  Matching: MkUnit "m" /: (MkUnit "s" ^: 2)
  Match failed
matchFamTcM
  Matching: MkUnit "m"
  Match succeeded:
    Rewrites to: Base "m"
    Coercion: UnitDefs.D:R:MkUnit"m"[0]
Eager T.F. reduction success
  MkUnit
  ["m"]
  Base "m"
  UnitDefs.D:R:MkUnit"m"[0] :: MkUnit "m" ~ Base "m"
  False
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acC7[fuv:0]
Unfilled tyvar s_acC7[fuv:0]
matchFamTcM
  Matching: MkUnit "s" ^: 2
  Match succeeded:
    Rewrites to: MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
    Coercion: Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N
Eager T.F. reduction success
  ^:
  [MkUnit "s", 2]
  MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N :: MkUnit "s"
                                                    ^: 2 ~ MkUnit "s"
                                                           *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  False
matchFamTcM
  Matching: MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  Match failed
matchFamTcM
  Matching: MkUnit "s"
  Match succeeded:
    Rewrites to: Base "s"
    Coercion: UnitDefs.D:R:MkUnit"s"[0]
Eager T.F. reduction success
  MkUnit
  ["s"]
  Base "s"
  UnitDefs.D:R:MkUnit"s"[0] :: MkUnit "s" ~ Base "s"
  False
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
matchFamTcM
  Matching: MkUnit "s" ^: (2 GHC.TypeNats.- 1)
  Match failed
matchFamTcM
  Matching: MkUnit "s"
  Match succeeded:
    Rewrites to: Base "s"
    Coercion: UnitDefs.D:R:MkUnit"s"[0]
Eager T.F. reduction success
  MkUnit
  ["s"]
  Base "s"
  UnitDefs.D:R:MkUnit"s"[0] :: MkUnit "s" ~ Base "s"
  False
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
matchFamTcM
  Matching: 2 GHC.TypeNats.- 1
  Match succeeded:
    Rewrites to: 1
    Coercion: (SubDef (<2>_N, <1>_N))
Eager T.F. reduction success
  GHC.TypeNats.-
  [2, 1]
  1
  (SubDef (<2>_N, <1>_N)) :: 2 GHC.TypeNats.- 1 ~ 1
  False
flatten/flat-cache hit
  ^: [s0_acCg[fuv:0], 1]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
flatten/flat-cache hit
  *: [s0_acCg[fuv:0], s0_acCg[fuv:0]]
  s0_acCi[fuv:0]
Unfilled tyvar s_acCi[fuv:0]
flatten/flat-cache hit
  /: [s0_acC7[fuv:0], s0_acCi[fuv:0]]
  s0_acCo[fuv:0]
Unfilled tyvar s_acCo[fuv:0]
flatten } s0_acCo[fuv:0]
New coercion hole: acCq
Emitting new coercion hole
  {acCq} :: (s0_acCo[fuv:0] :: Unit)
            GHC.Prim.~#
            (s0_acCo[fuv:0] :: Unit)
Filling coercion hole
  acix := Sym
            (Sym
               U(hole:{acCp}, s0_acC7[fuv:0] /: s1_acCi[fuv:0], s0_acCo[fuv:0])_N
             ; (Sym (Trans (UnitDefs.D:R:MkUnit"m"[0]) {acC8})
                /: Trans
                       (Sym {acCj})
                       (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                        *: Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh}))_N)_N)
          ; Sym
              U(hole:{acCp}, s0_acC7[fuv:0] /: s1_acCi[fuv:0], s0_acCo[fuv:0])_N
          ; (Sym (Trans (UnitDefs.D:R:MkUnit"m"[0]) {acC8})
             /: Sym (Trans
                         (Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N)
                         (Sym (Trans
                                   (Sym {acCj})
                                   (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                    *: Trans
                                           (Sym (Data.Theory.UoM.D:R:^:[1] <s>_N))
                                           (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                            ^: Sym (SubDef (<2>_N, <1>_N)))_N)_N))))_N
rewriteEqEvidence
  [WD] hole{acix} {0}:: ((MkUnit "m"
                          /: (MkUnit "s" *: MkUnit "s")) :: Unit)
                        GHC.Prim.~#
                        ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
  s0_acCo[fuv:0]
  s0_acCo[fuv:0]
  Sym
    (Sym
       U(hole:{acCp}, s0_acC7[fuv:0] /: s1_acCi[fuv:0], s0_acCo[fuv:0])_N
     ; (Sym (Trans (UnitDefs.D:R:MkUnit"m"[0]) {acC8})
        /: Trans
               (Sym {acCj})
               (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                *: Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh}))_N)_N)
  ; Sym
      U(hole:{acCp}, s0_acC7[fuv:0] /: s1_acCi[fuv:0], s0_acCo[fuv:0])_N
  ; (Sym (Trans (UnitDefs.D:R:MkUnit"m"[0]) {acC8})
     /: Sym (Trans
                 (Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N)
                 (Sym (Trans
                           (Sym {acCj})
                           (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                            *: Trans
                                   (Sym (Data.Theory.UoM.D:R:^:[1] <s>_N))
                                   (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                    ^: Sym (SubDef (<2>_N, <1>_N)))_N)_N))))_N
Filling coercion hole acCq := <s0_acCo[fuv:0]>_N
end stage canonicalization }
Step 8[l:1,d:1] Solved by reflexivity:
    [WD] hole{acCq} {1}:: (s0_acCo[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (s0_acCo[fuv:0] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                      /: s1_acCi[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{ackm} {0}:: (MkUnit
                                                           "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (Base "kg" :: Unit) (CNonCanonical)
                                  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_ackv[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acC7[fuv:0]
  s0_acCi[fuv:0]
Unfilled tyvar s_acC7[fuv:0]
Unfilled tyvar s_acCi[fuv:0]
flatten }
  s0_acC7[fuv:0]
  s0_acCi[fuv:0]
extendFlatCache
  /: [s0_acC7[fuv:0], s0_acCi[fuv:0]]
  [WD]
  s0_acCo[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acC7[fuv:0] /: s1_acCi[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acC7[fuv:0], s0_acCi[fuv:0]] s_acCo[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                                  /: s1_acCi[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 9[l:1,d:0] Kept as inert:
    [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acCo[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                       /: s1_acCi[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                                    GHC.Prim.~#
                                    (Base "kg" :: Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{ackz} {0}:: ((MkUnit "m"
                                                          /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_ackv[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                                      GHC.Prim.~#
                                      (Base "kg" :: Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                        GHC.Prim.~#
                        (Base "kg" :: Unit) (CNonCanonical)
canEvNC:eq
  MkUnit "kg"
  Base "kg"
can_eq_nc
  False
  [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                        GHC.Prim.~#
                        (Base "kg" :: Unit)
  nominal equality
  MkUnit "kg"
  MkUnit "kg"
  Base "kg"
  Base "kg"
flatten { FM_FlattenAll MkUnit "kg"
matchFamTcM
  Matching: MkUnit "kg"
  Match succeeded:
    Rewrites to: Base "kg"
    Coercion: UnitDefs.D:R:MkUnit"kg"[0]
Eager T.F. reduction success
  MkUnit
  ["kg"]
  Base "kg"
  UnitDefs.D:R:MkUnit"kg"[0] :: MkUnit "kg" ~ Base "kg"
  False
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acC5[fuv:0]
Unfilled tyvar s_acC5[fuv:0]
flatten } s0_acC5[fuv:0]
flatten { FM_FlattenAll Base "kg"
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acC5[fuv:0]
Unfilled tyvar s_acC5[fuv:0]
flatten } s0_acC5[fuv:0]
New coercion hole: acCr
Emitting new coercion hole
  {acCr} :: (s0_acC5[fuv:0] :: Unit)
            GHC.Prim.~#
            (s0_acC5[fuv:0] :: Unit)
Filling coercion hole
  ackm := UnitDefs.D:R:MkUnit"kg"[0]
          ; U(hole:{acC6}, Base "kg", s0_acC5[fuv:0])_N
          ; Sym U(hole:{acC6}, Base "kg", s0_acC5[fuv:0])_N
rewriteEqEvidence
  [WD] hole{ackm} {0}:: (MkUnit "kg" :: Unit)
                        GHC.Prim.~#
                        (Base "kg" :: Unit)
  s0_acC5[fuv:0]
  s0_acC5[fuv:0]
  UnitDefs.D:R:MkUnit"kg"[0]
  ; U(hole:{acC6}, Base "kg", s0_acC5[fuv:0])_N
  ; Sym U(hole:{acC6}, Base "kg", s0_acC5[fuv:0])_N
Filling coercion hole acCr := <s0_acC5[fuv:0]>_N
end stage canonicalization }
Step 10[l:1,d:1] Solved by reflexivity:
    [WD] hole{acCr} {1}:: (s0_acC5[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (s0_acC5[fuv:0] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{ackz} {0}:: ((MkUnit "m"
                                      /: (MkUnit "s" ^: 2)) :: Unit)
                                    GHC.Prim.~#
                                    (u0_ackv[tau:1] :: Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 1}
  rest of worklist = WL {Funeqs = [WD] hole{ackA} {0}:: (Base
                                                           "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{ackz} {0}:: ((MkUnit "m"
                                        /: (MkUnit "s" ^: 2)) :: Unit)
                                      GHC.Prim.~#
                                      (u0_ackv[tau:1] :: Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                        GHC.Prim.~#
                        (u0_ackv[tau:1] :: Unit) (CNonCanonical)
canEvNC:eq
  MkUnit "m" /: (MkUnit "s" ^: 2)
  u0_ackv[tau:1]
can_eq_nc
  False
  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                        GHC.Prim.~#
                        (u0_ackv[tau:1] :: Unit)
  nominal equality
  MkUnit "m" /: (MkUnit "s" ^: 2)
  MkUnit "m" /: (MkUnit "s" ^: 2)
  u0_ackv[tau:1]
  u0_ackv[tau:1]
flatten { FM_FlattenAll MkUnit "m" /: (MkUnit "s" ^: 2)
matchFamTcM
  Matching: MkUnit "m" /: (MkUnit "s" ^: 2)
  Match failed
matchFamTcM
  Matching: MkUnit "m"
  Match succeeded:
    Rewrites to: Base "m"
    Coercion: UnitDefs.D:R:MkUnit"m"[0]
Eager T.F. reduction success
  MkUnit
  ["m"]
  Base "m"
  UnitDefs.D:R:MkUnit"m"[0] :: MkUnit "m" ~ Base "m"
  False
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acC7[fuv:0]
Unfilled tyvar s_acC7[fuv:0]
matchFamTcM
  Matching: MkUnit "s" ^: 2
  Match succeeded:
    Rewrites to: MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
    Coercion: Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N
Eager T.F. reduction success
  ^:
  [MkUnit "s", 2]
  MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N :: MkUnit "s"
                                                    ^: 2 ~ MkUnit "s"
                                                           *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  False
matchFamTcM
  Matching: MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  Match failed
matchFamTcM
  Matching: MkUnit "s"
  Match succeeded:
    Rewrites to: Base "s"
    Coercion: UnitDefs.D:R:MkUnit"s"[0]
Eager T.F. reduction success
  MkUnit
  ["s"]
  Base "s"
  UnitDefs.D:R:MkUnit"s"[0] :: MkUnit "s" ~ Base "s"
  False
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
matchFamTcM
  Matching: MkUnit "s" ^: (2 GHC.TypeNats.- 1)
  Match failed
matchFamTcM
  Matching: MkUnit "s"
  Match succeeded:
    Rewrites to: Base "s"
    Coercion: UnitDefs.D:R:MkUnit"s"[0]
Eager T.F. reduction success
  MkUnit
  ["s"]
  Base "s"
  UnitDefs.D:R:MkUnit"s"[0] :: MkUnit "s" ~ Base "s"
  False
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
matchFamTcM
  Matching: 2 GHC.TypeNats.- 1
  Match succeeded:
    Rewrites to: 1
    Coercion: (SubDef (<2>_N, <1>_N))
Eager T.F. reduction success
  GHC.TypeNats.-
  [2, 1]
  1
  (SubDef (<2>_N, <1>_N)) :: 2 GHC.TypeNats.- 1 ~ 1
  False
flatten/flat-cache hit
  ^: [s0_acCg[fuv:0], 1]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
flatten/flat-cache hit
  *: [s0_acCg[fuv:0], s0_acCg[fuv:0]]
  s0_acCi[fuv:0]
Unfilled tyvar s_acCi[fuv:0]
flatten/flat-cache hit
  /: [s0_acC7[fuv:0], s0_acCi[fuv:0]]
  s0_acCo[fuv:0]
Unfilled tyvar s_acCo[fuv:0]
flatten } s0_acCo[fuv:0]
flatten { FM_FlattenAll u0_ackv[tau:1]
Unfilled tyvar u_ackv[tau:1]
flatten } u0_ackv[tau:1]
New coercion hole: acCs
Emitting new coercion hole
  {acCs} :: (s0_acCo[fuv:0] :: Unit)
            GHC.Prim.~#
            (u0_ackv[tau:1] :: Unit)
Filling coercion hole
  ackz := Sym
            (Sym
               U(hole:{acCp}, s0_acC7[fuv:0] /: s1_acCi[fuv:0], s0_acCo[fuv:0])_N
             ; (Sym (Trans (UnitDefs.D:R:MkUnit"m"[0]) {acC8})
                /: Sym (Trans
                            (Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N)
                            (Sym (Trans
                                      (Sym {acCj})
                                      (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                       *: Trans
                                              (Sym (Data.Theory.UoM.D:R:^:[1] <s>_N))
                                              (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                               ^: Sym (SubDef (<2>_N, <1>_N)))_N)_N))))_N)
          ; U(hole:{acCs}, s0_acCo[fuv:0], u0_ackv[tau:1])_N
rewriteEqEvidence
  [WD] hole{ackz} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                        GHC.Prim.~#
                        (u0_ackv[tau:1] :: Unit)
  s0_acCo[fuv:0]
  u0_ackv[tau:1]
  Sym
    (Sym
       U(hole:{acCp}, s0_acC7[fuv:0] /: s1_acCi[fuv:0], s0_acCo[fuv:0])_N
     ; (Sym (Trans (UnitDefs.D:R:MkUnit"m"[0]) {acC8})
        /: Sym (Trans
                    (Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N)
                    (Sym (Trans
                              (Sym {acCj})
                              (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                               *: Trans
                                      (Sym (Data.Theory.UoM.D:R:^:[1] <s>_N))
                                      (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                       ^: Sym (SubDef (<2>_N, <1>_N)))_N)_N))))_N)
  ; U(hole:{acCs}, s0_acCo[fuv:0], u0_ackv[tau:1])_N
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (u0_ackv[tau:1] :: Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_acCo[fuv:0] :: Unit
      TcLevel of s_acCo[fuv:0] is 0
  RHS: u0_ackv[tau:1] :: Unit
addInertEq {
  Adding new inert equality: [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                                   GHC.Prim.~#
                                                   (u0_ackv[tau:1] :: Unit) (CTyEqCan)
Kick out, tv = s_acCo[fuv:0]
  n-kicked = 1
  kicked_out = WL {Funeqs = [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                    /: s1_acCi[fuv:0]) :: Unit)
                                                  GHC.Prim.~#
                                                  (s2_acCo[fuv:0] :: Unit) (CFunEqCan)}
  Residual inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                                       GHC.Prim.~#
                                                       (w0_acku[tau:1] :: Unit) (CTyEqCan)
                     Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                         "kg" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                                        *: s1_acC7[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                                        *: s0_acCg[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                     Unsolved goals = 1}
addInertEq }
end stage interact with inerts }
Step 11[l:1,d:1] Kept as inert:
    [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_ackv[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                      /: s1_acCi[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 2}
  rest of worklist = WL {Funeqs = [WD] hole{ackA} {0}:: (Base
                                                           "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acC7[fuv:0]
  s0_acCi[fuv:0]
Unfilled tyvar s_acC7[fuv:0]
Unfilled tyvar s_acCi[fuv:0]
flatten }
  s0_acC7[fuv:0]
  s0_acCi[fuv:0]
extendFlatCache
  /: [s0_acC7[fuv:0], s0_acCi[fuv:0]]
  [WD]
  s0_acCo[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acC7[fuv:0] /: s1_acCi[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acC7[fuv:0], s0_acCi[fuv:0]] s_acCo[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                                  /: s1_acCi[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 12[l:1,d:0] Kept as inert:
    [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acCo[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                       /: s1_acCi[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                    GHC.Prim.~#
                                    (v0_ackw[tau:1] :: Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 2}
  rest of worklist = WL {Funeqs = [WD] hole{acA8} {0}:: (Base
                                                           "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (v0_ackw[tau:1] :: Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (v0_ackw[tau:1] :: Unit) (CNonCanonical)
canEvNC:eq
  Base "kg"
  v0_ackw[tau:1]
can_eq_nc
  False
  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (v0_ackw[tau:1] :: Unit)
  nominal equality
  Base "kg"
  Base "kg"
  v0_ackw[tau:1]
  v0_ackw[tau:1]
flatten { FM_FlattenAll Base "kg"
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acC5[fuv:0]
Unfilled tyvar s_acC5[fuv:0]
flatten } s0_acC5[fuv:0]
flatten { FM_FlattenAll v0_ackw[tau:1]
Unfilled tyvar v_ackw[tau:1]
flatten } v0_ackw[tau:1]
New coercion hole: acCt
Emitting new coercion hole
  {acCt} :: (s0_acC5[fuv:0] :: Unit)
            GHC.Prim.~#
            (v0_ackw[tau:1] :: Unit)
Filling coercion hole
  ackA := U(hole:{acC6}, Base "kg", s0_acC5[fuv:0])_N
          ; U(hole:{acCt}, s0_acC5[fuv:0], v0_ackw[tau:1])_N
rewriteEqEvidence
  [WD] hole{ackA} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (v0_ackw[tau:1] :: Unit)
  s0_acC5[fuv:0]
  v0_ackw[tau:1]
  U(hole:{acC6}, Base "kg", s0_acC5[fuv:0])_N
  ; U(hole:{acCt}, s0_acC5[fuv:0], v0_ackw[tau:1])_N
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (v0_ackw[tau:1] :: Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_acC5[fuv:0] :: Unit
      TcLevel of s_acC5[fuv:0] is 0
  RHS: v0_ackw[tau:1] :: Unit
addInertEq {
  Adding new inert equality: [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                                                   GHC.Prim.~#
                                                   (v0_ackw[tau:1] :: Unit) (CTyEqCan)
Kick out, tv = s_acC5[fuv:0]
  n-kicked = 2
  kicked_out = WL {Funeqs = [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                  GHC.Prim.~#
                                                  (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                            [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                                                  GHC.Prim.~#
                                                  (s2_acC9[fuv:0] :: Unit) (CFunEqCan)}
  Residual inerts = {Equalities: [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                                       GHC.Prim.~#
                                                       (u0_ackv[tau:1] :: Unit) (CTyEqCan)
                                 [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                                       GHC.Prim.~#
                                                       (w0_acku[tau:1] :: Unit) (CTyEqCan)
                     Type-function equalities = [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                                        *: s0_acCg[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                     Unsolved goals = 2}
addInertEq }
end stage interact with inerts }
Step 13[l:1,d:1] Kept as inert:
    [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (v0_ackw[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (v0_ackw[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Funeqs = [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                          *: s1_acC7[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "kg"
flatten } "kg"
extendFlatCache
  Base ["kg"]
  [WD]
  s0_acC5[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "kg"
  Match failed
improveTopFunEqs
  Base ["kg"] s_acC5[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acC6} {2}:: (Base
                                                                   "kg" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 14[l:1,d:2] Kept as inert:
    [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                          GHC.Prim.~#
                          (s0_acC5[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                      *: s1_acC7[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (v0_ackw[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Funeqs = [WD] hole{acA8} {0}:: (Base
                                                           "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                        *: s1_acC7[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acC5[fuv:0]
  s0_acC7[fuv:0]
Unfilled tyvar s_acC5[fuv:0]
Unfilled tyvar s_acC7[fuv:0]
flatten }
  s0_acC5[fuv:0]
  s0_acC7[fuv:0]
extendFlatCache
  *: [s0_acC5[fuv:0], s0_acC7[fuv:0]]
  [WD]
  s0_acC9[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                        *: s1_acC7[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                        *: s1_acC7[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acC5[fuv:0] *: s1_acC7[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acC5[fuv:0], s0_acC7[fuv:0]] s_acC9[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                                  *: s1_acC7[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
Emit derived shadow
  [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
Emitting fresh work
  [D] _ {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
              GHC.Prim.~#
              (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 15[l:1,d:1] Kept as inert:
    [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acC9[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                       *: s1_acC7[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [D] _ {1}:: ((s0_acC5[fuv:0]
                            *: s1_acC7[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (v0_ackw[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Funeqs = [WD] hole{acA8} {0}:: (Base
                                                           "kg" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [D] _ {1}:: ((s0_acC5[fuv:0]
                              *: s1_acC7[fuv:0]) :: Unit)
                            GHC.Prim.~#
                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acC5[fuv:0]
  s0_acC7[fuv:0]
Unfilled tyvar s_acC5[fuv:0]
Following inert tyvar
  FM_FlattenAll s_acC5[fuv:0] = v0_ackw[tau:1]
  [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (v0_ackw[tau:1] :: Unit)
Unfilled tyvar v_ackw[tau:1]
Unfilled tyvar s_acC7[fuv:0]
flatten }
  v0_ackw[tau:1]
  s0_acC7[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [D] _ {1}:: ((v0_ackw[tau:1]
                              *: s0_acC7[fuv:0]) :: Unit)
                            GHC.Prim.~#
                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [D] _ {1}:: ((v0_ackw[tau:1]
                              *: s0_acC7[fuv:0]) :: Unit)
                            GHC.Prim.~#
                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [D] _ {1}:: ((v0_ackw[tau:1] *: s0_acC7[fuv:0]) :: Unit)
              GHC.Prim.~#
              (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: v0_ackw[tau:1] *: s0_acC7[fuv:0]
  Match failed
improveTopFunEqs
  *: [v0_ackw[tau:1], s0_acC7[fuv:0]] s_acC9[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [D] _ {1}:: ((v0_ackw[tau:1]
                                                        *: s0_acC7[fuv:0]) :: Unit)
                                                      GHC.Prim.~#
                                                      (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 16[l:1,d:1] Kept as inert:
    [D] _ {1}:: ((v0_ackw[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                GHC.Prim.~#
                (s1_acC9[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [D] _ {1}:: ((v0_ackw[tau:1]
                             *: s0_acC7[fuv:0]) :: Unit)
                           GHC.Prim.~#
                           (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (v0_ackw[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((v0_ackw[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Funeqs = [WD] hole{acAj} {0}:: ((MkUnit "m"
                                                          /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (u0_acA5[tau:1] :: Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (u0_acA5[tau:1] :: Unit) (CNonCanonical)
canEvNC:eq
  Base "kg"
  u0_acA5[tau:1]
can_eq_nc
  False
  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (u0_acA5[tau:1] :: Unit)
  nominal equality
  Base "kg"
  Base "kg"
  u0_acA5[tau:1]
  u0_acA5[tau:1]
flatten { FM_FlattenAll Base "kg"
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acC5[fuv:0]
Unfilled tyvar s_acC5[fuv:0]
flatten } s0_acC5[fuv:0]
flatten { FM_FlattenAll u0_acA5[tau:1]
Unfilled tyvar u_acA5[tau:1]
flatten } u0_acA5[tau:1]
New coercion hole: acCu
Emitting new coercion hole
  {acCu} :: (s0_acC5[fuv:0] :: Unit)
            GHC.Prim.~#
            (u0_acA5[tau:1] :: Unit)
Filling coercion hole
  acA8 := U(hole:{acC6}, Base "kg", s0_acC5[fuv:0])_N
          ; U(hole:{acCu}, s0_acC5[fuv:0], u0_acA5[tau:1])_N
rewriteEqEvidence
  [WD] hole{acA8} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (u0_acA5[tau:1] :: Unit)
  s0_acC5[fuv:0]
  u0_acA5[tau:1]
  U(hole:{acC6}, Base "kg", s0_acC5[fuv:0])_N
  ; U(hole:{acCu}, s0_acC5[fuv:0], u0_acA5[tau:1])_N
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (u0_acA5[tau:1] :: Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_acC5[fuv:0] :: Unit
      TcLevel of s_acC5[fuv:0] is 0
  RHS: u0_acA5[tau:1] :: Unit
addInertEq {
  Adding new inert equality: [WD] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                                   GHC.Prim.~#
                                                   (u0_acA5[tau:1] :: Unit) (CTyEqCan)
Emit derived shadow
  [WD] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (u0_acA5[tau:1] :: Unit) (CTyEqCan)
Emitting fresh work
  [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acA5[tau:1] :: Unit) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 17[l:1,d:1] Kept as inert:
    [WD] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acA5[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acA5[tau:1] :: Unit) (CTyEqCan)
  inerts = {Equalities: [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (v0_ackw[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((v0_ackw[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 4}
  rest of worklist = WL {Funeqs = [WD] hole{acAj} {0}:: ((MkUnit "m"
                                                          /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                            GHC.Prim.~#
                            (u0_acA5[tau:1] :: Unit) (CTyEqCan)
can_eq_nc
  False
  [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acA5[tau:1] :: Unit)
  nominal equality
  s0_acC5[fuv:0]
  s0_acC5[fuv:0]
  u0_acA5[tau:1]
  u0_acA5[tau:1]
flatten { FM_FlattenAll s0_acC5[fuv:0]
Unfilled tyvar s_acC5[fuv:0]
Following inert tyvar
  FM_FlattenAll s_acC5[fuv:0] = v0_ackw[tau:1]
  [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (v0_ackw[tau:1] :: Unit)
Unfilled tyvar v_ackw[tau:1]
flatten } v0_ackw[tau:1]
flatten { FM_FlattenAll u0_acA5[tau:1]
Unfilled tyvar u_acA5[tau:1]
flatten } u0_acA5[tau:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [D] _ {1}:: (v0_ackw[tau:1] :: Unit)
                            GHC.Prim.~#
                            (u0_acA5[tau:1] :: Unit) (CTyEqCan)
Sneaky unification:
  Unifies: v_ackw[tau:1] := u0_acA5[tau:1]
  Coercion: v0_ackw[tau:1] ~ u0_acA5[tau:1]
  Left Kind is: Unit
  Right Kind is: Unit
unifyTyVar v_ackw[tau:1] := u0_acA5[tau:1]
writeMetaTyVar v_ackw[tau:1] :: Unit := u0_acA5[tau:1]
Kick out, tv = v_ackw[tau:1]
  n-kicked = 2
  kicked_out = WL {Eqs = [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                                               GHC.Prim.~#
                                               (v0_ackw[tau:1] :: Unit) (CTyEqCan)
                   Funeqs = [D] _ {1}:: ((v0_ackw[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                        GHC.Prim.~#
                                        (s1_acC9[fuv:0] :: Unit) (CFunEqCan)}
  Residual inerts = {Equalities: [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                                 [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                                       GHC.Prim.~#
                                                       (w0_acku[tau:1] :: Unit) (CTyEqCan)
                                 [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                                       GHC.Prim.~#
                                                       (u0_ackv[tau:1] :: Unit) (CTyEqCan)
                     Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                                        *: s0_acCg[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                                [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                                       *: s1_acC7[fuv:0]) :: Unit)
                                                                     GHC.Prim.~#
                                                                     (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                     Unsolved goals = 3}
end stage interact with inerts }
Step 18[l:1,d:1] Solved by unification (2 kicked out):
    [D] _ {1}:: (v0_ackw[tau:1] :: Unit)
                GHC.Prim.~#
                (u0_acA5[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (v0_ackw[tau:1] :: Unit) (CTyEqCan)
  inerts = {Equalities: [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Funeqs = [D] _ {1}:: ((v0_ackw[tau:1]
                                                *: s0_acC7[fuv:0]) :: Unit)
                                              GHC.Prim.~#
                                              (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (v0_ackw[tau:1] :: Unit) (CTyEqCan)
can_eq_nc
  False
  [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (v0_ackw[tau:1] :: Unit)
  nominal equality
  s0_acC5[fuv:0]
  s0_acC5[fuv:0]
  u0_acA5[tau:1]
  v0_ackw[tau:1]
flatten { FM_FlattenAll s0_acC5[fuv:0]
Unfilled tyvar s_acC5[fuv:0]
flatten } s0_acC5[fuv:0]
flatten { FM_FlattenAll v0_ackw[tau:1]
Following filled tyvar v_ackw[tau:1] = u0_acA5[tau:1]
Unfilled tyvar u_acA5[tau:1]
flatten } u0_acA5[tau:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (u0_acA5[tau:1] :: Unit) (CTyEqCan)
Filling coercion hole
  acCt := U(hole:{acCu}, s0_acC5[fuv:0], u0_acA5[tau:1])_N
Emitting fresh work
  [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acA5[tau:1] :: Unit) (CTyEqCan)
end stage interact with inerts }
Step 19[l:1,d:1] Solved from inert:
    [WD] hole{acCt} {1}:: (s0_acC5[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acA5[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acA5[tau:1] :: Unit) (CTyEqCan)
  inerts = {Equalities: [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Funeqs = [D] _ {1}:: ((v0_ackw[tau:1]
                                                *: s0_acC7[fuv:0]) :: Unit)
                                              GHC.Prim.~#
                                              (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                            GHC.Prim.~#
                            (u0_acA5[tau:1] :: Unit) (CTyEqCan)
can_eq_nc
  False
  [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acA5[tau:1] :: Unit)
  nominal equality
  s0_acC5[fuv:0]
  s0_acC5[fuv:0]
  u0_acA5[tau:1]
  u0_acA5[tau:1]
flatten { FM_FlattenAll s0_acC5[fuv:0]
Unfilled tyvar s_acC5[fuv:0]
flatten } s0_acC5[fuv:0]
flatten { FM_FlattenAll u0_acA5[tau:1]
Unfilled tyvar u_acA5[tau:1]
flatten } u0_acA5[tau:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                            GHC.Prim.~#
                            (u0_acA5[tau:1] :: Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_acC5[fuv:0] :: Unit
      TcLevel of s_acC5[fuv:0] is 0
  RHS: u0_acA5[tau:1] :: Unit
addInertEq {
  Adding new inert equality: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                         GHC.Prim.~#
                                         (u0_acA5[tau:1] :: Unit) (CTyEqCan)
Kick out, tv = s_acC5[fuv:0]
  n-kicked = 1
  kicked_out = WL {Funeqs = [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                  GHC.Prim.~#
                                                  (s0_acC5[fuv:0] :: Unit) (CFunEqCan)}
  Residual inerts = {Equalities: [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                                       GHC.Prim.~#
                                                       (u0_ackv[tau:1] :: Unit) (CTyEqCan)
                                 [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                                       GHC.Prim.~#
                                                       (w0_acku[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                     Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                                        *: s0_acCg[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                                [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                                       *: s1_acC7[fuv:0]) :: Unit)
                                                                     GHC.Prim.~#
                                                                     (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                     Unsolved goals = 3}
addInertEq }
end stage interact with inerts }
Step 20[l:1,d:1] Kept as inert:
    [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                GHC.Prim.~#
                (u0_acA5[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Funeqs = [D] _ {1}:: ((v0_ackw[tau:1]
                                                *: s0_acC7[fuv:0]) :: Unit)
                                              GHC.Prim.~#
                                              (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "kg"
flatten } "kg"
extendFlatCache
  Base ["kg"]
  [WD]
  s0_acC5[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "kg"
  Match failed
improveTopFunEqs
  Base ["kg"] s_acC5[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acC6} {2}:: (Base
                                                                   "kg" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 21[l:1,d:2] Kept as inert:
    [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                          GHC.Prim.~#
                          (s0_acC5[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [D] _ {1}:: ((v0_ackw[tau:1]
                            *: s0_acC7[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Funeqs = [WD] hole{acAj} {0}:: ((MkUnit "m"
                                                          /: (MkUnit "s" ^: 2)) :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
                                  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [D] _ {1}:: ((v0_ackw[tau:1]
                              *: s0_acC7[fuv:0]) :: Unit)
                            GHC.Prim.~#
                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  v0_ackw[tau:1]
  s0_acC7[fuv:0]
Following filled tyvar v_ackw[tau:1] = u0_acA5[tau:1]
Unfilled tyvar u_acA5[tau:1]
Unfilled tyvar s_acC7[fuv:0]
flatten }
  u0_acA5[tau:1]
  s0_acC7[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [D] _ {1}:: ((u0_acA5[tau:1]
                              *: s0_acC7[fuv:0]) :: Unit)
                            GHC.Prim.~#
                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [D] _ {1}:: ((u0_acA5[tau:1]
                              *: s0_acC7[fuv:0]) :: Unit)
                            GHC.Prim.~#
                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
              GHC.Prim.~#
              (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: u0_acA5[tau:1] *: s0_acC7[fuv:0]
  Match failed
improveTopFunEqs
  *: [u0_acA5[tau:1], s0_acC7[fuv:0]] s_acC9[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [D] _ {1}:: ((u0_acA5[tau:1]
                                                        *: s0_acC7[fuv:0]) :: Unit)
                                                      GHC.Prim.~#
                                                      (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 22[l:1,d:1] Kept as inert:
    [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                GHC.Prim.~#
                (s1_acC9[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [D] _ {1}:: ((u0_acA5[tau:1]
                             *: s0_acC7[fuv:0]) :: Unit)
                           GHC.Prim.~#
                           (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acAj} {0}:: ((MkUnit "m"
                                      /: (MkUnit "s" ^: 2)) :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CNonCanonical)
  inerts = {Equalities: [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Funeqs = [WD] hole{acAu} {0}:: (MkUnit
                                                           "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acAj} {0}:: ((MkUnit "m"
                                        /: (MkUnit "s" ^: 2)) :: Unit)
                                      GHC.Prim.~#
                                      (u0_acAg[tau:1] :: Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                        GHC.Prim.~#
                        (u0_acAg[tau:1] :: Unit) (CNonCanonical)
canEvNC:eq
  MkUnit "m" /: (MkUnit "s" ^: 2)
  u0_acAg[tau:1]
can_eq_nc
  False
  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                        GHC.Prim.~#
                        (u0_acAg[tau:1] :: Unit)
  nominal equality
  MkUnit "m" /: (MkUnit "s" ^: 2)
  MkUnit "m" /: (MkUnit "s" ^: 2)
  u0_acAg[tau:1]
  u0_acAg[tau:1]
flatten { FM_FlattenAll MkUnit "m" /: (MkUnit "s" ^: 2)
matchFamTcM
  Matching: MkUnit "m" /: (MkUnit "s" ^: 2)
  Match failed
matchFamTcM
  Matching: MkUnit "m"
  Match succeeded:
    Rewrites to: Base "m"
    Coercion: UnitDefs.D:R:MkUnit"m"[0]
Eager T.F. reduction success
  MkUnit
  ["m"]
  Base "m"
  UnitDefs.D:R:MkUnit"m"[0] :: MkUnit "m" ~ Base "m"
  False
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acC7[fuv:0]
Unfilled tyvar s_acC7[fuv:0]
matchFamTcM
  Matching: MkUnit "s" ^: 2
  Match succeeded:
    Rewrites to: MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
    Coercion: Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N
Eager T.F. reduction success
  ^:
  [MkUnit "s", 2]
  MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N :: MkUnit "s"
                                                    ^: 2 ~ MkUnit "s"
                                                           *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  False
matchFamTcM
  Matching: MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  Match failed
matchFamTcM
  Matching: MkUnit "s"
  Match succeeded:
    Rewrites to: Base "s"
    Coercion: UnitDefs.D:R:MkUnit"s"[0]
Eager T.F. reduction success
  MkUnit
  ["s"]
  Base "s"
  UnitDefs.D:R:MkUnit"s"[0] :: MkUnit "s" ~ Base "s"
  False
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
matchFamTcM
  Matching: MkUnit "s" ^: (2 GHC.TypeNats.- 1)
  Match failed
matchFamTcM
  Matching: MkUnit "s"
  Match succeeded:
    Rewrites to: Base "s"
    Coercion: UnitDefs.D:R:MkUnit"s"[0]
Eager T.F. reduction success
  MkUnit
  ["s"]
  Base "s"
  UnitDefs.D:R:MkUnit"s"[0] :: MkUnit "s" ~ Base "s"
  False
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
matchFamTcM
  Matching: 2 GHC.TypeNats.- 1
  Match succeeded:
    Rewrites to: 1
    Coercion: (SubDef (<2>_N, <1>_N))
Eager T.F. reduction success
  GHC.TypeNats.-
  [2, 1]
  1
  (SubDef (<2>_N, <1>_N)) :: 2 GHC.TypeNats.- 1 ~ 1
  False
flatten/flat-cache hit
  ^: [s0_acCg[fuv:0], 1]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
flatten/flat-cache hit
  *: [s0_acCg[fuv:0], s0_acCg[fuv:0]]
  s0_acCi[fuv:0]
Unfilled tyvar s_acCi[fuv:0]
flatten/flat-cache hit
  /: [s0_acC7[fuv:0], s0_acCi[fuv:0]]
  s0_acCo[fuv:0]
Unfilled tyvar s_acCo[fuv:0]
flatten } s0_acCo[fuv:0]
flatten { FM_FlattenAll u0_acAg[tau:1]
Unfilled tyvar u_acAg[tau:1]
flatten } u0_acAg[tau:1]
New coercion hole: acCv
Emitting new coercion hole
  {acCv} :: (s0_acCo[fuv:0] :: Unit)
            GHC.Prim.~#
            (u0_acAg[tau:1] :: Unit)
Filling coercion hole
  acAj := Sym
            (Sym
               U(hole:{acCp}, s0_acC7[fuv:0] /: s1_acCi[fuv:0], s0_acCo[fuv:0])_N
             ; (Sym (Trans (UnitDefs.D:R:MkUnit"m"[0]) {acC8})
                /: Sym (Trans
                            (Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N)
                            (Sym (Trans
                                      (Sym {acCj})
                                      (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                       *: Trans
                                              (Sym (Data.Theory.UoM.D:R:^:[1] <s>_N))
                                              (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                               ^: Sym (SubDef (<2>_N, <1>_N)))_N)_N))))_N)
          ; U(hole:{acCv}, s0_acCo[fuv:0], u0_acAg[tau:1])_N
rewriteEqEvidence
  [WD] hole{acAj} {0}:: ((MkUnit "m" /: (MkUnit "s" ^: 2)) :: Unit)
                        GHC.Prim.~#
                        (u0_acAg[tau:1] :: Unit)
  s0_acCo[fuv:0]
  u0_acAg[tau:1]
  Sym
    (Sym
       U(hole:{acCp}, s0_acC7[fuv:0] /: s1_acCi[fuv:0], s0_acCo[fuv:0])_N
     ; (Sym (Trans (UnitDefs.D:R:MkUnit"m"[0]) {acC8})
        /: Sym (Trans
                    (Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N)
                    (Sym (Trans
                              (Sym {acCj})
                              (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                               *: Trans
                                      (Sym (Data.Theory.UoM.D:R:^:[1] <s>_N))
                                      (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                       ^: Sym (SubDef (<2>_N, <1>_N)))_N)_N))))_N)
  ; U(hole:{acCv}, s0_acCo[fuv:0], u0_acAg[tau:1])_N
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (u0_acAg[tau:1] :: Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_acCo[fuv:0] :: Unit
      TcLevel of s_acCo[fuv:0] is 0
  RHS: u0_acAg[tau:1] :: Unit
addInertEq {
  Adding new inert equality: [WD] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                                   GHC.Prim.~#
                                                   (u0_acAg[tau:1] :: Unit) (CTyEqCan)
Emit derived shadow
  [WD] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (u0_acAg[tau:1] :: Unit) (CTyEqCan)
Emitting fresh work
  [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acAg[tau:1] :: Unit) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 23[l:1,d:1] Kept as inert:
    [WD] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acAg[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acAg[tau:1] :: Unit) (CTyEqCan)
  inerts = {Equalities: [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_ackv[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 4}
  rest of worklist = WL {Funeqs = [WD] hole{acAu} {0}:: (MkUnit
                                                           "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                            GHC.Prim.~#
                            (u0_acAg[tau:1] :: Unit) (CTyEqCan)
can_eq_nc
  False
  [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acAg[tau:1] :: Unit)
  nominal equality
  s0_acCo[fuv:0]
  s0_acCo[fuv:0]
  u0_acAg[tau:1]
  u0_acAg[tau:1]
flatten { FM_FlattenAll s0_acCo[fuv:0]
Unfilled tyvar s_acCo[fuv:0]
Following inert tyvar
  FM_FlattenAll s_acCo[fuv:0] = u0_ackv[tau:1]
  [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (u0_ackv[tau:1] :: Unit)
Unfilled tyvar u_ackv[tau:1]
flatten } u0_ackv[tau:1]
flatten { FM_FlattenAll u0_acAg[tau:1]
Unfilled tyvar u_acAg[tau:1]
flatten } u0_acAg[tau:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [D] _ {1}:: (u0_ackv[tau:1] :: Unit)
                            GHC.Prim.~#
                            (u1_acAg[tau:1] :: Unit) (CTyEqCan)
Sneaky unification:
  Unifies: u_ackv[tau:1] := u0_acAg[tau:1]
  Coercion: u0_ackv[tau:1] ~ u0_acAg[tau:1]
  Left Kind is: Unit
  Right Kind is: Unit
unifyTyVar u_ackv[tau:1] := u0_acAg[tau:1]
writeMetaTyVar u_ackv[tau:1] :: Unit := u0_acAg[tau:1]
Kick out, tv = u_ackv[tau:1]
  n-kicked = 1
  kicked_out = WL {Eqs = [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                               GHC.Prim.~#
                                               (u0_ackv[tau:1] :: Unit) (CTyEqCan)}
  Residual inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                                 [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                                       GHC.Prim.~#
                                                       (w0_acku[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                     Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                                        *: s0_acCg[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                                [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                                       *: s1_acC7[fuv:0]) :: Unit)
                                                                     GHC.Prim.~#
                                                                     (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                                [D] _ {1}:: ((u0_acA5[tau:1]
                                                              *: s0_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                     Unsolved goals = 3}
end stage interact with inerts }
Step 24[l:1,d:1] Solved by unification (1 kicked out):
    [D] _ {1}:: (u0_ackv[tau:1] :: Unit)
                GHC.Prim.~#
                (u1_acAg[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_ackv[tau:1] :: Unit) (CTyEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Funeqs = [WD] hole{acAu} {0}:: (MkUnit
                                                           "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (u0_ackv[tau:1] :: Unit) (CTyEqCan)
can_eq_nc
  False
  [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (u0_ackv[tau:1] :: Unit)
  nominal equality
  s0_acCo[fuv:0]
  s0_acCo[fuv:0]
  u0_acAg[tau:1]
  u0_ackv[tau:1]
flatten { FM_FlattenAll s0_acCo[fuv:0]
Unfilled tyvar s_acCo[fuv:0]
flatten } s0_acCo[fuv:0]
flatten { FM_FlattenAll u0_ackv[tau:1]
Following filled tyvar u_ackv[tau:1] = u0_acAg[tau:1]
Unfilled tyvar u_acAg[tau:1]
flatten } u0_acAg[tau:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (u0_acAg[tau:1] :: Unit) (CTyEqCan)
Filling coercion hole
  acCs := U(hole:{acCv}, s0_acCo[fuv:0], u0_acAg[tau:1])_N
Emitting fresh work
  [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acAg[tau:1] :: Unit) (CTyEqCan)
end stage interact with inerts }
Step 25[l:1,d:1] Solved from inert:
    [WD] hole{acCs} {1}:: (s0_acCo[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acAg[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acAg[tau:1] :: Unit) (CTyEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Funeqs = [WD] hole{acAu} {0}:: (MkUnit
                                                           "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                            GHC.Prim.~#
                            (u0_acAg[tau:1] :: Unit) (CTyEqCan)
can_eq_nc
  False
  [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acAg[tau:1] :: Unit)
  nominal equality
  s0_acCo[fuv:0]
  s0_acCo[fuv:0]
  u0_acAg[tau:1]
  u0_acAg[tau:1]
flatten { FM_FlattenAll s0_acCo[fuv:0]
Unfilled tyvar s_acCo[fuv:0]
flatten } s0_acCo[fuv:0]
flatten { FM_FlattenAll u0_acAg[tau:1]
Unfilled tyvar u_acAg[tau:1]
flatten } u0_acAg[tau:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                            GHC.Prim.~#
                            (u0_acAg[tau:1] :: Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_acCo[fuv:0] :: Unit
      TcLevel of s_acCo[fuv:0] is 0
  RHS: u0_acAg[tau:1] :: Unit
addInertEq {
  Adding new inert equality: [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                         GHC.Prim.~#
                                         (u0_acAg[tau:1] :: Unit) (CTyEqCan)
Kick out, tv = s_acCo[fuv:0]
  n-kicked = 1
  kicked_out = WL {Funeqs = [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                    /: s1_acCi[fuv:0]) :: Unit)
                                                  GHC.Prim.~#
                                                  (s2_acCo[fuv:0] :: Unit) (CFunEqCan)}
  Residual inerts = {Equalities: [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                                 [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                                       GHC.Prim.~#
                                                       (w0_acku[tau:1] :: Unit) (CTyEqCan)
                                 [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                     Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                                        *: s0_acCg[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                                [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                                       *: s1_acC7[fuv:0]) :: Unit)
                                                                     GHC.Prim.~#
                                                                     (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                                [D] _ {1}:: ((u0_acA5[tau:1]
                                                              *: s0_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                     Unsolved goals = 3}
addInertEq }
end stage interact with inerts }
Step 26[l:1,d:1] Kept as inert:
    [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                GHC.Prim.~#
                (u0_acAg[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                      /: s1_acCi[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Funeqs = [WD] hole{acAu} {0}:: (MkUnit
                                                           "N" :: Unit)
                                                        GHC.Prim.~#
                                                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acC7[fuv:0]
  s0_acCi[fuv:0]
Unfilled tyvar s_acC7[fuv:0]
Unfilled tyvar s_acCi[fuv:0]
flatten }
  s0_acC7[fuv:0]
  s0_acCi[fuv:0]
extendFlatCache
  /: [s0_acC7[fuv:0], s0_acCi[fuv:0]]
  [WD]
  s0_acCo[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acC7[fuv:0] /: s1_acCi[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acC7[fuv:0], s0_acCi[fuv:0]] s_acCo[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                                  /: s1_acCi[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 27[l:1,d:0] Kept as inert:
    [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acCo[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                       /: s1_acCi[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                                      GHC.Prim.~#
                                      (u0_acAr[tau:1] :: Unit) (CNonCanonical)
canonicalize (non-canonical)
  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                        GHC.Prim.~#
                        (u0_acAr[tau:1] :: Unit) (CNonCanonical)
canEvNC:eq
  MkUnit "N"
  u0_acAr[tau:1]
can_eq_nc
  False
  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                        GHC.Prim.~#
                        (u0_acAr[tau:1] :: Unit)
  nominal equality
  MkUnit "N"
  MkUnit "N"
  u0_acAr[tau:1]
  u0_acAr[tau:1]
flatten { FM_FlattenAll MkUnit "N"
matchFamTcM
  Matching: MkUnit "N"
  Match succeeded:
    Rewrites to: (MkUnit "kg" *: MkUnit "m") /: (MkUnit "s" ^: 2)
    Coercion: UnitDefs.D:R:MkUnit"N"[0]
Eager T.F. reduction success
  MkUnit
  ["N"]
  (MkUnit "kg" *: MkUnit "m") /: (MkUnit "s" ^: 2)
  UnitDefs.D:R:MkUnit"N"[0] :: MkUnit "N" ~ (MkUnit "kg"
                                             *: MkUnit "m")
                                            /: (MkUnit "s" ^: 2)
  False
matchFamTcM
  Matching: (MkUnit "kg" *: MkUnit "m") /: (MkUnit "s" ^: 2)
  Match failed
matchFamTcM
  Matching: MkUnit "kg" *: MkUnit "m"
  Match failed
matchFamTcM
  Matching: MkUnit "kg"
  Match succeeded:
    Rewrites to: Base "kg"
    Coercion: UnitDefs.D:R:MkUnit"kg"[0]
Eager T.F. reduction success
  MkUnit
  ["kg"]
  Base "kg"
  UnitDefs.D:R:MkUnit"kg"[0] :: MkUnit "kg" ~ Base "kg"
  False
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acC5[fuv:0]
Unfilled tyvar s_acC5[fuv:0]
matchFamTcM
  Matching: MkUnit "m"
  Match succeeded:
    Rewrites to: Base "m"
    Coercion: UnitDefs.D:R:MkUnit"m"[0]
Eager T.F. reduction success
  MkUnit
  ["m"]
  Base "m"
  UnitDefs.D:R:MkUnit"m"[0] :: MkUnit "m" ~ Base "m"
  False
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acC7[fuv:0]
Unfilled tyvar s_acC7[fuv:0]
matchFamTcM
  Matching: s0_acC5[fuv:0] *: s1_acC7[fuv:0]
  Match failed
New coercion hole: acCx
Emitting new coercion hole
  {acCx} :: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acCw[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acC5[fuv:0], s0_acC7[fuv:0]]
  [WD]
  s0_acCw[fuv:0]
flatten/flat-cache miss
  *: [s0_acC5[fuv:0], s0_acC7[fuv:0]]
  s_acCw[fuv:0]
  [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCw[fuv:0] :: Unit)
matchFamTcM
  Matching: MkUnit "s" ^: 2
  Match succeeded:
    Rewrites to: MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
    Coercion: Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N
Eager T.F. reduction success
  ^:
  [MkUnit "s", 2]
  MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N :: MkUnit "s"
                                                    ^: 2 ~ MkUnit "s"
                                                           *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  False
matchFamTcM
  Matching: MkUnit "s" *: (MkUnit "s" ^: (2 GHC.TypeNats.- 1))
  Match failed
matchFamTcM
  Matching: MkUnit "s"
  Match succeeded:
    Rewrites to: Base "s"
    Coercion: UnitDefs.D:R:MkUnit"s"[0]
Eager T.F. reduction success
  MkUnit
  ["s"]
  Base "s"
  UnitDefs.D:R:MkUnit"s"[0] :: MkUnit "s" ~ Base "s"
  False
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
matchFamTcM
  Matching: MkUnit "s" ^: (2 GHC.TypeNats.- 1)
  Match failed
matchFamTcM
  Matching: MkUnit "s"
  Match succeeded:
    Rewrites to: Base "s"
    Coercion: UnitDefs.D:R:MkUnit"s"[0]
Eager T.F. reduction success
  MkUnit
  ["s"]
  Base "s"
  UnitDefs.D:R:MkUnit"s"[0] :: MkUnit "s" ~ Base "s"
  False
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
matchFamTcM
  Matching: 2 GHC.TypeNats.- 1
  Match succeeded:
    Rewrites to: 1
    Coercion: (SubDef (<2>_N, <1>_N))
Eager T.F. reduction success
  GHC.TypeNats.-
  [2, 1]
  1
  (SubDef (<2>_N, <1>_N)) :: 2 GHC.TypeNats.- 1 ~ 1
  False
flatten/flat-cache hit
  ^: [s0_acCg[fuv:0], 1]
  s0_acCg[fuv:0]
Unfilled tyvar s_acCg[fuv:0]
flatten/flat-cache hit
  *: [s0_acCg[fuv:0], s0_acCg[fuv:0]]
  s0_acCi[fuv:0]
Unfilled tyvar s_acCi[fuv:0]
matchFamTcM
  Matching: s0_acCw[fuv:0] /: s1_acCi[fuv:0]
  Match failed
New coercion hole: acCz
Emitting new coercion hole
  {acCz} :: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acCy[fuv:0] :: Unit)
extendFlatCache
  /: [s0_acCw[fuv:0], s0_acCi[fuv:0]]
  [WD]
  s0_acCy[fuv:0]
flatten/flat-cache miss
  /: [s0_acCw[fuv:0], s0_acCi[fuv:0]]
  s_acCy[fuv:0]
  [WD] hole{acCz} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCy[fuv:0] :: Unit)
flatten } s0_acCy[fuv:0]
flatten { FM_FlattenAll u0_acAr[tau:1]
Unfilled tyvar u_acAr[tau:1]
flatten } u0_acAr[tau:1]
New coercion hole: acCA
Emitting new coercion hole
  {acCA} :: (s0_acCy[fuv:0] :: Unit)
            GHC.Prim.~#
            (u0_acAr[tau:1] :: Unit)
Filling coercion hole
  acAu := UnitDefs.D:R:MkUnit"N"[0]
          ; Sym
              (Sym
                 U(hole:{acCz}, s0_acCw[fuv:0] /: s1_acCi[fuv:0], s0_acCy[fuv:0])_N
               ; (Trans
                      (Sym {acCx})
                      (Sym (Trans (UnitDefs.D:R:MkUnit"kg"[0]) {acC6})
                       *: Sym (Trans (UnitDefs.D:R:MkUnit"m"[0]) {acC8}))_N
                  /: Sym (Trans
                              (Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N)
                              (Sym (Trans
                                        (Sym {acCj})
                                        (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                         *: Trans
                                                (Sym (Data.Theory.UoM.D:R:^:[1] <s>_N))
                                                (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                                 ^: Sym (SubDef (<2>_N, <1>_N)))_N)_N))))_N)
          ; U(hole:{acCA}, s0_acCy[fuv:0], u0_acAr[tau:1])_N
rewriteEqEvidence
  [WD] hole{acAu} {0}:: (MkUnit "N" :: Unit)
                        GHC.Prim.~#
                        (u0_acAr[tau:1] :: Unit)
  s0_acCy[fuv:0]
  u0_acAr[tau:1]
  UnitDefs.D:R:MkUnit"N"[0]
  ; Sym
      (Sym
         U(hole:{acCz}, s0_acCw[fuv:0] /: s1_acCi[fuv:0], s0_acCy[fuv:0])_N
       ; (Trans
              (Sym {acCx})
              (Sym (Trans (UnitDefs.D:R:MkUnit"kg"[0]) {acC6})
               *: Sym (Trans (UnitDefs.D:R:MkUnit"m"[0]) {acC8}))_N
          /: Sym (Trans
                      (Data.Theory.UoM.D:R:^:[2] <MkUnit "s">_N <2>_N)
                      (Sym (Trans
                                (Sym {acCj})
                                (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                 *: Trans
                                        (Sym (Data.Theory.UoM.D:R:^:[1] <s>_N))
                                        (Sym (Trans (UnitDefs.D:R:MkUnit"s"[0]) {acCh})
                                         ^: Sym (SubDef (<2>_N, <1>_N)))_N)_N))))_N)
  ; U(hole:{acCA}, s0_acCy[fuv:0], u0_acAr[tau:1])_N
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCA} {1}:: (s0_acCy[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (u0_acAr[tau:1] :: Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_acCy[fuv:0] :: Unit
      TcLevel of s_acCy[fuv:0] is 0
  RHS: u0_acAr[tau:1] :: Unit
addInertEq {
  Adding new inert equality: [WD] hole{acCA} {1}:: (s0_acCy[fuv:0] :: Unit)
                                                   GHC.Prim.~#
                                                   (u0_acAr[tau:1] :: Unit) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 28[l:1,d:1] Kept as inert:
    [WD] hole{acCA} {1}:: (s0_acCy[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acAr[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                      *: s1_acC7[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCA} {1}:: (s0_acCy[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_acAr[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                                              *: s1_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s2_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 4}
  rest of worklist = WL {Funeqs = [WD] hole{acCz} {1}:: ((s0_acCw[fuv:0]
                                                          /: s1_acCi[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acCy[fuv:0] :: Unit) (CFunEqCan)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                        *: s1_acC7[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acC5[fuv:0]
  s0_acC7[fuv:0]
Unfilled tyvar s_acC5[fuv:0]
Unfilled tyvar s_acC7[fuv:0]
flatten }
  s0_acC5[fuv:0]
  s0_acC7[fuv:0]
extendFlatCache
  *: [s0_acC5[fuv:0], s0_acC7[fuv:0]]
  [WD]
  s0_acCw[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                        *: s1_acC7[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
reactFunEq (rewrite inert item):
  work_item = [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                      *: s1_acC7[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
  inertItem= [W] hole{acCa} {1}:: ((s0_acC5[fuv:0]
                                    *: s1_acC7[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acC9[fuv:0] :: Unit)
  (swap_flag, upgrade) (Is-swapped, True)
reactFunEq
  [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCw[fuv:0] :: Unit)
  s_acCw[fuv:0]
  [W] hole{acCa} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                       GHC.Prim.~#
                       (s2_acC9[fuv:0] :: Unit)
  s_acC9[fuv:0]
Filling coercion hole
  acCa := U(hole:{acCx}, s0_acC5[fuv:0]
                         *: s1_acC7[fuv:0], s0_acCw[fuv:0])_N
unflattenFmv s_acC9[fuv:0] := s0_acCw[fuv:0]
writeMetaTyVar s_acC9[fuv:0] :: Unit := s0_acCw[fuv:0]
Kick out, tv = s_acC9[fuv:0]
  n-kicked = 2
  kicked_out = WL {Funeqs = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                                    /: s1_acCi[fuv:0]) :: Unit)
                                                  GHC.Prim.~#
                                                  (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                            [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                        GHC.Prim.~#
                                        (s1_acC9[fuv:0] :: Unit) (CFunEqCan)}
  Residual inerts = {Equalities: [WD] hole{acCA} {1}:: (s0_acCy[fuv:0] :: Unit)
                                                       GHC.Prim.~#
                                                       (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                                 [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                                 [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                                       GHC.Prim.~#
                                                       (w0_acku[tau:1] :: Unit) (CTyEqCan)
                                 [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                     Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                         "kg" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                                        *: s0_acCg[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                                        *: s1_acC7[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                     Unsolved goals = 4}
dischargeFmv
  s_acC9[fuv:0] = s0_acCw[fuv:0]
  (2 kicked out)
reactFunEq done
  [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCw[fuv:0] :: Unit)
  s_acCw[fuv:0]
  [W] hole{acCa} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                       GHC.Prim.~#
                       (s2_acC9[fuv:0] :: Unit)
  s_acC9[fuv:0]
end stage interact with inerts }
Step 29[l:1,d:1] Work item rewrites inert:
    [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acCw[fuv:0] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                      /: s1_acCi[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCA} {1}:: (s0_acCy[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 4}
  rest of worklist = WL {Funeqs = [D] _ {1}:: ((u0_acA5[tau:1]
                                                *: s0_acC7[fuv:0]) :: Unit)
                                              GHC.Prim.~#
                                              (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acCz} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acCy[fuv:0] :: Unit) (CFunEqCan)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCl} {1}:: ((s0_acC9[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acC9[fuv:0]
  s0_acCi[fuv:0]
Following filled tyvar s_acC9[fuv:0] = s0_acCw[fuv:0]
Unfilled tyvar s_acCw[fuv:0]
Unfilled tyvar s_acCi[fuv:0]
flatten }
  s0_acCw[fuv:0]
  s0_acCi[fuv:0]
extendFlatCache
  /: [s0_acCw[fuv:0], s0_acCi[fuv:0]]
  [WD]
  s0_acCk[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acCw[fuv:0] /: s1_acCi[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acCw[fuv:0], s0_acCi[fuv:0]] s_acCk[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                                  /: s1_acCi[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 30[l:1,d:1] Kept as inert:
    [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acCk[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                       /: s1_acCi[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [D] _ {1}:: ((u0_acA5[tau:1]
                            *: s0_acC7[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCA} {1}:: (s0_acCy[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 4}
  rest of worklist = WL {Funeqs = [WD] hole{acCz} {1}:: ((s0_acCw[fuv:0]
                                                          /: s1_acCi[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acCy[fuv:0] :: Unit) (CFunEqCan)
                         Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [D] _ {1}:: ((u0_acA5[tau:1]
                              *: s0_acC7[fuv:0]) :: Unit)
                            GHC.Prim.~#
                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  u0_acA5[tau:1]
  s0_acC7[fuv:0]
Unfilled tyvar u_acA5[tau:1]
Unfilled tyvar s_acC7[fuv:0]
flatten }
  u0_acA5[tau:1]
  s0_acC7[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [D] _ {1}:: ((u0_acA5[tau:1]
                              *: s0_acC7[fuv:0]) :: Unit)
                            GHC.Prim.~#
                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [D] _ {1}:: ((u0_acA5[tau:1]
                              *: s0_acC7[fuv:0]) :: Unit)
                            GHC.Prim.~#
                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
              GHC.Prim.~#
              (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: u0_acA5[tau:1] *: s0_acC7[fuv:0]
  Match failed
improveTopFunEqs
  *: [u0_acA5[tau:1], s0_acC7[fuv:0]] s_acC9[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [D] _ {1}:: ((u0_acA5[tau:1]
                                                        *: s0_acC7[fuv:0]) :: Unit)
                                                      GHC.Prim.~#
                                                      (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 31[l:1,d:1] Kept as inert:
    [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                GHC.Prim.~#
                (s1_acC9[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [D] _ {1}:: ((u0_acA5[tau:1]
                             *: s0_acC7[fuv:0]) :: Unit)
                           GHC.Prim.~#
                           (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCz} {1}:: ((s0_acCw[fuv:0]
                                      /: s1_acCi[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acCy[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [WD] hole{acCA} {1}:: (s0_acCy[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 4}
  rest of worklist = WL {Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCz} {1}:: ((s0_acCw[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCy[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acCw[fuv:0]
  s0_acCi[fuv:0]
Unfilled tyvar s_acCw[fuv:0]
Unfilled tyvar s_acCi[fuv:0]
flatten }
  s0_acCw[fuv:0]
  s0_acCi[fuv:0]
extendFlatCache
  /: [s0_acCw[fuv:0], s0_acCi[fuv:0]]
  [WD]
  s0_acCy[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCz} {1}:: ((s0_acCw[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCy[fuv:0] :: Unit) (CFunEqCan)
reactFunEq (rewrite inert item):
  work_item = [WD] hole{acCz} {1}:: ((s0_acCw[fuv:0]
                                      /: s1_acCi[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acCy[fuv:0] :: Unit) (CFunEqCan)
  inertItem= [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                     /: s1_acCi[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acCk[fuv:0] :: Unit)
  (swap_flag, upgrade) (Not-swapped, False)
reactFunEq
  [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCk[fuv:0] :: Unit)
  s_acCk[fuv:0]
  [WD] hole{acCz} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCy[fuv:0] :: Unit)
  s_acCy[fuv:0]
Filling coercion hole
  acCz := U(hole:{acCl}, s0_acCw[fuv:0]
                         /: s1_acCi[fuv:0], s0_acCk[fuv:0])_N
unflattenFmv s_acCy[fuv:0] := s0_acCk[fuv:0]
writeMetaTyVar s_acCy[fuv:0] :: Unit := s0_acCk[fuv:0]
Kick out, tv = s_acCy[fuv:0]
  n-kicked = 1
  kicked_out = WL {Eqs = [WD] hole{acCA} {1}:: (s0_acCy[fuv:0] :: Unit)
                                               GHC.Prim.~#
                                               (u0_acAr[tau:1] :: Unit) (CTyEqCan)}
  Residual inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                                 [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                                       GHC.Prim.~#
                                                       (w0_acku[tau:1] :: Unit) (CTyEqCan)
                                 [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                     Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                         "kg" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                                        *: s0_acCg[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                                        *: s1_acC7[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                                [D] _ {1}:: ((u0_acA5[tau:1]
                                                              *: s0_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                     Unsolved goals = 3}
dischargeFmv
  s_acCy[fuv:0] = s0_acCk[fuv:0]
  (1 kicked out)
reactFunEq done
  [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCk[fuv:0] :: Unit)
  s_acCk[fuv:0]
  [WD] hole{acCz} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCy[fuv:0] :: Unit)
  s_acCy[fuv:0]
end stage interact with inerts }
Step 32[l:1,d:1] Inert rewrites work item:
    [WD] hole{acCz} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acCy[fuv:0] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCA} {1}:: (s0_acCy[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCA} {1}:: (s0_acCy[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (u0_acAr[tau:1] :: Unit) (CTyEqCan)
can_eq_nc
  False
  [WD] hole{acCA} {1}:: (s0_acCy[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (u0_acAr[tau:1] :: Unit)
  nominal equality
  s0_acCk[fuv:0]
  s0_acCy[fuv:0]
  u0_acAr[tau:1]
  u0_acAr[tau:1]
flatten { FM_FlattenAll s0_acCy[fuv:0]
Following filled tyvar s_acCy[fuv:0] = s0_acCk[fuv:0]
Unfilled tyvar s_acCk[fuv:0]
flatten } s0_acCk[fuv:0]
flatten { FM_FlattenAll u0_acAr[tau:1]
Unfilled tyvar u_acAr[tau:1]
flatten } u0_acAr[tau:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (u0_acAr[tau:1] :: Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_acCk[fuv:0] :: Unit
      TcLevel of s_acCk[fuv:0] is 0
  RHS: u0_acAr[tau:1] :: Unit
addInertEq {
  Adding new inert equality: [WD] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                                   GHC.Prim.~#
                                                   (u0_acAr[tau:1] :: Unit) (CTyEqCan)
Emit derived shadow
  [WD] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (u0_acAr[tau:1] :: Unit) (CTyEqCan)
Emitting fresh work
  [D] _ {1}:: (s0_acCk[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acAr[tau:1] :: Unit) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 33[l:1,d:1] Kept as inert:
    [WD] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acAr[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [D] _ {1}:: (s0_acCk[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acAr[tau:1] :: Unit) (CTyEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                              GHC.Prim.~#
                                              (w0_acku[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 4}
  rest of worklist = WL {Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [D] _ {1}:: (s0_acCk[fuv:0] :: Unit)
                            GHC.Prim.~#
                            (u0_acAr[tau:1] :: Unit) (CTyEqCan)
can_eq_nc
  False
  [D] _ {1}:: (s0_acCk[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acAr[tau:1] :: Unit)
  nominal equality
  s0_acCk[fuv:0]
  s0_acCk[fuv:0]
  u0_acAr[tau:1]
  u0_acAr[tau:1]
flatten { FM_FlattenAll s0_acCk[fuv:0]
Unfilled tyvar s_acCk[fuv:0]
Following inert tyvar
  FM_FlattenAll s_acCk[fuv:0] = w0_acku[tau:1]
  [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (w0_acku[tau:1] :: Unit)
Unfilled tyvar w_acku[tau:1]
flatten } w0_acku[tau:1]
flatten { FM_FlattenAll u0_acAr[tau:1]
Unfilled tyvar u_acAr[tau:1]
flatten } u0_acAr[tau:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [D] _ {1}:: (w0_acku[tau:1] :: Unit)
                            GHC.Prim.~#
                            (u0_acAr[tau:1] :: Unit) (CTyEqCan)
Sneaky unification:
  Unifies: w_acku[tau:1] := u0_acAr[tau:1]
  Coercion: w0_acku[tau:1] ~ u0_acAr[tau:1]
  Left Kind is: Unit
  Right Kind is: Unit
unifyTyVar w_acku[tau:1] := u0_acAr[tau:1]
writeMetaTyVar w_acku[tau:1] :: Unit := u0_acAr[tau:1]
Kick out, tv = w_acku[tau:1]
  n-kicked = 1
  kicked_out = WL {Eqs = [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                               GHC.Prim.~#
                                               (w0_acku[tau:1] :: Unit) (CTyEqCan)}
  Residual inerts = {Equalities: [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                                 [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                     Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                         "kg" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                                        *: s0_acCg[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                                        *: s1_acC7[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                                [D] _ {1}:: ((u0_acA5[tau:1]
                                                              *: s0_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                     Unsolved goals = 3}
end stage interact with inerts }
Step 34[l:1,d:1] Solved by unification (1 kicked out):
    [D] _ {1}:: (w0_acku[tau:1] :: Unit)
                GHC.Prim.~#
                (u0_acAr[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (w0_acku[tau:1] :: Unit) (CTyEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (w0_acku[tau:1] :: Unit) (CTyEqCan)
can_eq_nc
  False
  [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (w0_acku[tau:1] :: Unit)
  nominal equality
  s0_acCk[fuv:0]
  s0_acCk[fuv:0]
  u0_acAr[tau:1]
  w0_acku[tau:1]
flatten { FM_FlattenAll s0_acCk[fuv:0]
Unfilled tyvar s_acCk[fuv:0]
flatten } s0_acCk[fuv:0]
flatten { FM_FlattenAll w0_acku[tau:1]
Following filled tyvar w_acku[tau:1] = u0_acAr[tau:1]
Unfilled tyvar u_acAr[tau:1]
flatten } u0_acAr[tau:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                                      GHC.Prim.~#
                                      (u0_acAr[tau:1] :: Unit) (CTyEqCan)
Filling coercion hole
  acCn := U(hole:{acCA}, s0_acCk[fuv:0], u0_acAr[tau:1])_N
Emitting fresh work
  [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acAr[tau:1] :: Unit) (CTyEqCan)
end stage interact with inerts }
Step 35[l:1,d:2] Solved from inert:
    [WD] hole{acCn} {2}:: (s0_acCk[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acAr[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                          GHC.Prim.~#
                          (u0_acAr[tau:1] :: Unit) (CTyEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                            GHC.Prim.~#
                            (u0_acAr[tau:1] :: Unit) (CTyEqCan)
can_eq_nc
  False
  [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acAr[tau:1] :: Unit)
  nominal equality
  s0_acCk[fuv:0]
  s0_acCk[fuv:0]
  u0_acAr[tau:1]
  u0_acAr[tau:1]
flatten { FM_FlattenAll s0_acCk[fuv:0]
Unfilled tyvar s_acCk[fuv:0]
flatten } s0_acCk[fuv:0]
flatten { FM_FlattenAll u0_acAr[tau:1]
Unfilled tyvar u_acAr[tau:1]
flatten } u0_acAr[tau:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                            GHC.Prim.~#
                            (u0_acAr[tau:1] :: Unit) (CTyEqCan)
Can't solve tyvar equality
  LHS: s_acCk[fuv:0] :: Unit
      TcLevel of s_acCk[fuv:0] is 0
  RHS: u0_acAr[tau:1] :: Unit
addInertEq {
  Adding new inert equality: [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                         GHC.Prim.~#
                                         (u0_acAr[tau:1] :: Unit) (CTyEqCan)
Kick out, tv = s_acCk[fuv:0]
  n-kicked = 1
  kicked_out = WL {Funeqs = [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                    /: s1_acCi[fuv:0]) :: Unit)
                                                  GHC.Prim.~#
                                                  (s2_acCk[fuv:0] :: Unit) (CFunEqCan)}
  Residual inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                                 [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                                 [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                                      GHC.Prim.~#
                                                      (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                     Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                         "kg" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                                        /: s1_acCi[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                                        *: s0_acCg[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                                [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                                        *: s1_acC7[fuv:0]) :: Unit)
                                                                      GHC.Prim.~#
                                                                      (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                                [D] _ {1}:: ((u0_acA5[tau:1]
                                                              *: s0_acC7[fuv:0]) :: Unit)
                                                            GHC.Prim.~#
                                                            (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                     Unsolved goals = 3}
addInertEq }
end stage interact with inerts }
Step 36[l:1,d:2] Kept as inert:
    [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                GHC.Prim.~#
                (u0_acAr[tau:1] :: Unit)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                      /: s1_acCi[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Non-eqs = [WD] $dFractional_aciw {0}:: Fractional
                                                                  a0_aciv[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acCw[fuv:0]
  s0_acCi[fuv:0]
Unfilled tyvar s_acCw[fuv:0]
Unfilled tyvar s_acCi[fuv:0]
flatten }
  s0_acCw[fuv:0]
  s0_acCi[fuv:0]
extendFlatCache
  /: [s0_acCw[fuv:0], s0_acCi[fuv:0]]
  [WD]
  s0_acCk[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                        /: s1_acCi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acCw[fuv:0] /: s1_acCi[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acCw[fuv:0], s0_acCi[fuv:0]] s_acCk[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                                  /: s1_acCi[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 37[l:1,d:1] Kept as inert:
    [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acCk[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                       /: s1_acCi[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] $dFractional_aciw {0}:: Fractional
                                             a0_aciv[tau:1] (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
  rest of worklist = WL {Non-eqs = [WD] $dNum_ackl {0}:: Num
                                                           a0_ackk[tau:1] (CNonCanonical)
                                   [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dFractional_aciw {0}:: Fractional
                                               a0_aciv[tau:1] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dFractional_aciw {0}:: Fractional
                                 a0_aciv[tau:1] (CNonCanonical)
canEvNC:cls Fractional [a0_aciv[tau:1]]
flatten_many { a0_aciv[tau:1]
Following filled tyvar a_aciv[tau:1] = a0_acin[tau:1]
Following filled tyvar a_acin[tau:1] = Double
flatten } Double
canClass
  [WD] $dFractional_aciw {0}:: Fractional a0_aciv[tau:1]
  Fractional Double
  ContinueWith [WD] $dFractional_aciw {0}:: Fractional Double
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dFractional_aciw {0}:: Fractional
                                               Double (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dFractional_aciw {0}:: Fractional
                                               Double (CDictCan(psc))
doTopReact
  [WD] $dFractional_aciw {0}:: Fractional Double (CDictCan(psc))
matchClassInst pred = Fractional Double {
matchClass success
  dict Fractional Double
  witness GHC.Float.$fFractionalDouble Fractional Double
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for
  [WD] $dFractional_aciw {0}:: Fractional Double
updSolvedSetTcs: [WD] $dFractional_aciw {0}:: Fractional Double
addTcEvBind
  acC4
  [W] $dFractional_aciw = GHC.Float.$fFractionalDouble @[] []
end stage top-level reactions }
Step 38[l:1,d:0] Top react: Dict/Top (solved wanted):
    [WD] $dFractional_aciw {0}:: Fractional Double
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dNum_ackl {0}:: Num
                                      a0_ackk[tau:1] (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
  rest of worklist = WL {Non-eqs = [WD] $dNum_ackx {0}:: Num
                                                           a0_ackt[tau:1] (CNonCanonical)
                                   [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dNum_ackl {0}:: Num
                                        a0_ackk[tau:1] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1] (CNonCanonical)
canEvNC:cls Num [a0_ackk[tau:1]]
flatten_many { a0_ackk[tau:1]
Following filled tyvar a_ackk[tau:1] = a0_aciR[tau:1]
Following filled tyvar a_aciR[tau:1] = Double
flatten } Double
canClass
  [WD] $dNum_ackl {0}:: Num a0_ackk[tau:1]
  Num Double
  ContinueWith [WD] $dNum_ackl {0}:: Num Double
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dNum_ackl {0}:: Num Double (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dNum_ackl {0}:: Num Double (CDictCan)
doTopReact [WD] $dNum_ackl {0}:: Num Double (CDictCan)
matchClassInst pred = Num Double {
matchClass success
  dict Num Double
  witness GHC.Float.$fNumDouble Num Double
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for [WD] $dNum_ackl {0}:: Num Double
updSolvedSetTcs: [WD] $dNum_ackl {0}:: Num Double
addTcEvBind
  acC4
  [W] $dNum_ackl = GHC.Float.$fNumDouble @[] []
end stage top-level reactions }
Step 39[l:1,d:0] Top react: Dict/Top (solved wanted):
    [WD] $dNum_ackl {0}:: Num Double
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dNum_ackx {0}:: Num
                                      a0_ackt[tau:1] (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
  rest of worklist = WL {Non-eqs = [WD] irred_acky {0}:: w0_acku[tau:1]
                                                         Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                                        *: v0_ackw[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dNum_ackx {0}:: Num
                                        a0_ackt[tau:1] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1] (CNonCanonical)
canEvNC:cls Num [a0_ackt[tau:1]]
flatten_many { a0_ackt[tau:1]
Following filled tyvar a_ackt[tau:1] = Double
flatten } Double
canClass
  [WD] $dNum_ackx {0}:: Num a0_ackt[tau:1]
  Num Double
  ContinueWith [WD] $dNum_ackx {0}:: Num Double
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dNum_ackx {0}:: Num Double (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dNum_ackx {0}:: Num Double (CDictCan)
doTopReact [WD] $dNum_ackx {0}:: Num Double (CDictCan)
addTcEvBind
  acC4
  [W] $dNum_ackx = $dNum_ackl
end stage top-level reactions }
Step 40[l:1,d:0] Top react: Dict/Top (cached):
    [WD] $dNum_ackx {0}:: Num Double
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_acky {0}:: w0_acku[tau:1]
                                    Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                   *: v0_ackw[tau:1]) (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
            Unsolved goals = 3}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
  rest of worklist = WL {Non-eqs = [WD] $dEq_acxx {0}:: Eq
                                                          a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] irred_acky {0}:: w0_acku[tau:1]
                                      Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                                     *: v0_ackw[tau:1]) (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_acky {0}:: w0_acku[tau:1]
                        Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1]
                                                       *: v0_ackw[tau:1]) (CNonCanonical)
canEvNC:irred
  w0_acku[tau:1]
  Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1] *: v0_ackw[tau:1])
can_pred
  IrredPred =  w0_acku[tau:1]
               Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1] *: v0_ackw[tau:1])
flatten {
  FM_FlattenAll w0_acku[tau:1]
                Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1] *: v0_ackw[tau:1])
matchFamTcM
  Matching: w0_acku[tau:1]
            Data.UnitsOfMeasure.Syntax.~~ (u0_ackv[tau:1] *: v0_ackw[tau:1])
  Match failed
Following filled tyvar w_acku[tau:1] = u0_acAr[tau:1]
Unfilled tyvar u_acAr[tau:1]
matchFamTcM
  Matching: u0_ackv[tau:1] *: v0_ackw[tau:1]
  Match failed
Following filled tyvar u_ackv[tau:1] = u0_acAg[tau:1]
Unfilled tyvar u_acAg[tau:1]
Following filled tyvar v_ackw[tau:1] = u0_acA5[tau:1]
Unfilled tyvar u_acA5[tau:1]
matchFamTcM
  Matching: u0_acAg[tau:1] *: u1_acA5[tau:1]
  Match failed
New coercion hole: acCE
Emitting new coercion hole
  {acCE} :: ((u0_acAg[tau:1] *: u1_acA5[tau:1]) :: Unit)
            GHC.Prim.~#
            (s0_acCD[fuv:0] :: Unit)
extendFlatCache
  *: [u0_acAg[tau:1], u0_acA5[tau:1]]
  [WD]
  s0_acCD[fuv:0]
flatten/flat-cache miss
  *: [u0_acAg[tau:1], u0_acA5[tau:1]]
  s_acCD[fuv:0]
  [WD] hole{acCE} {0}:: ((u0_acAg[tau:1] *: u1_acA5[tau:1]) :: Unit)
                        GHC.Prim.~#
                        (s0_acCD[fuv:0] :: Unit)
matchFamTcM
  Matching: u0_acAr[tau:1]
            Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]
  Match failed
New coercion hole: acCG
Emitting new coercion hole
  {acCG} :: ((u0_acAr[tau:1]
              Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
            GHC.Prim.~#
            (s1_acCF[fuv:0] :: Constraint)
extendFlatCache
  Data.UnitsOfMeasure.Syntax.~~ [u0_acAr[tau:1], s0_acCD[fuv:0]]
  [WD]
  s0_acCF[fuv:0]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Syntax.~~ [u0_acAr[tau:1], s0_acCD[fuv:0]]
  s_acCF[fuv:0]
  [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                          Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                        GHC.Prim.~#
                        (s1_acCF[fuv:0] :: Constraint)
flatten } s0_acCF[fuv:0]
Emitting new wanted
  irred_acCH :: s0_acCF[fuv:0]
  arising from a use of ‘*:’ at test-suite-force/Tests.hs:49:17-40
addTcEvBind
  acC4
  [W] irred_acky
    = irred_acCH `cast` (Sub
                           (Sym
                              U(hole:{acCG}, u0_acAr[tau:1]
                                             Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0], s0_acCF[fuv:0])_N
                            ; (<u>_N Data.UnitsOfMeasure.Syntax.~~ Sym {acCE})_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
doTopReact [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
addInertCan }
Step 41[l:1,d:0] Kept as inert:
    [WD] irred_acCH {0}:: s0_acCF[fuv:0]
End solver pipeline (kept as inert) }
  final_item = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                      *: u1_acA5[tau:1]) :: Unit)
                                    GHC.Prim.~#
                                    (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 4}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
  rest of worklist = WL {Funeqs = [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                          Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                        *: u1_acA5[tau:1]) :: Unit)
                                      GHC.Prim.~#
                                      (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  u0_acAg[tau:1]
  u0_acA5[tau:1]
Unfilled tyvar u_acAg[tau:1]
Unfilled tyvar u_acA5[tau:1]
flatten }
  u0_acAg[tau:1]
  u0_acA5[tau:1]
extendFlatCache
  *: [u0_acAg[tau:1], u0_acA5[tau:1]]
  [WD]
  s0_acCD[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                        *: u1_acA5[tau:1]) :: Unit)
                                      GHC.Prim.~#
                                      (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                        *: u1_acA5[tau:1]) :: Unit)
                                      GHC.Prim.~#
                                      (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acCE} {0}:: ((u0_acAg[tau:1] *: u1_acA5[tau:1]) :: Unit)
                        GHC.Prim.~#
                        (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: u0_acAg[tau:1] *: u1_acA5[tau:1]
  Match failed
improveTopFunEqs
  *: [u0_acAg[tau:1], u0_acA5[tau:1]] s_acCD[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                                  *: u1_acA5[tau:1]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 42[l:1,d:0] Kept as inert:
    [WD] hole{acCE} {0}:: ((u0_acAg[tau:1] *: u1_acA5[tau:1]) :: Unit)
                          GHC.Prim.~#
                          (s0_acCD[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                       *: u1_acA5[tau:1]) :: Unit)
                                     GHC.Prim.~#
                                     (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                      Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                    GHC.Prim.~#
                                    (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 4}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
  rest of worklist = WL {Non-eqs = [WD] $dEq_acxx {0}:: Eq
                                                          a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                        Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
flatten_many {
  u0_acAr[tau:1]
  s0_acCD[fuv:0]
Unfilled tyvar u_acAr[tau:1]
Unfilled tyvar s_acCD[fuv:0]
flatten }
  u0_acAr[tau:1]
  s0_acCD[fuv:0]
extendFlatCache
  Data.UnitsOfMeasure.Syntax.~~ [u0_acAr[tau:1], s0_acCD[fuv:0]]
  [WD]
  s0_acCF[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                        Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                        Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
doTopReact
  [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                          Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                        GHC.Prim.~#
                        (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
matchFamTcM
  Matching: u0_acAr[tau:1]
            Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]
  Match failed
improveTopFunEqs
  Data.UnitsOfMeasure.Syntax.~~ [u0_acAr[tau:1],
                                 s0_acCD[fuv:0]] s_acCF[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                                  Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                                GHC.Prim.~#
                                                                (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
addInertCan }
Step 43[l:1,d:0] Kept as inert:
    [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                            Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                          GHC.Prim.~#
                          (s1_acCF[fuv:0] :: Constraint)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                       Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                     GHC.Prim.~#
                                     (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 4}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
  rest of worklist = WL {Non-eqs = [WD] $dShow_acxy {0}:: Show
                                                            a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dEq_acxx {0}:: Eq
                                       a0_acxw[tau:1] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1] (CNonCanonical)
canEvNC:cls Eq [a0_acxw[tau:1]]
flatten_many { a0_acxw[tau:1]
Following filled tyvar a_acxw[tau:1] = String
flatten } String
canClass
  [WD] $dEq_acxx {0}:: Eq a0_acxw[tau:1]
  Eq String
  ContinueWith [WD] $dEq_acxx {0}:: Eq String
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dEq_acxx {0}:: Eq String (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dEq_acxx {0}:: Eq String (CDictCan)
doTopReact [WD] $dEq_acxx {0}:: Eq String (CDictCan)
matchClassInst pred = Eq String {
matchClass success
  dict Eq String
  witness GHC.Classes.$fEq[] forall a. Eq a => Eq [a]
} matchClassInst result
  GenInst [Eq Char]
          [safe]
doTopReact/found instance for [WD] $dEq_acxx {0}:: Eq String
updSolvedSetTcs: [WD] $dEq_acxx {0}:: Eq String
Emitting new wanted
  $dEq_acCM :: Eq Char
  arising from a use of ‘@?=’ at test-suite-force/Tests.hs:57:35-75
addTcEvBind
  acC4
  [W] $dEq_acxx = GHC.Classes.$fEq[] @[Char] [$dEq_acCM]
Emitting fresh work [WD] $dEq_acCM {1}:: Eq Char (CNonCanonical)
end stage top-level reactions }
Step 44[l:1,d:0] Top react: Dict/Top (solved wanted):
    [WD] $dEq_acxx {0}:: Eq String
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dEq_acCM {1}:: Eq Char (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 4}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
  rest of worklist = WL {Non-eqs = [WD] $dShow_acxy {0}:: Show
                                                            a0_acxw[tau:1] (CNonCanonical)
                                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dEq_acCM {1}:: Eq Char (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dEq_acCM {1}:: Eq Char (CNonCanonical)
canEvNC:cls Eq [Char]
flatten_many { Char
flatten } Char
canClass
  [WD] $dEq_acCM {1}:: Eq Char
  Eq Char
  ContinueWith [WD] $dEq_acCM {1}:: Eq Char
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dEq_acCM {1}:: Eq Char (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dEq_acCM {1}:: Eq Char (CDictCan)
doTopReact [WD] $dEq_acCM {1}:: Eq Char (CDictCan)
matchClassInst pred = Eq Char {
matchClass success
  dict Eq Char
  witness GHC.Classes.$fEqChar Eq Char
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for [WD] $dEq_acCM {1}:: Eq Char
updSolvedSetTcs: [WD] $dEq_acCM {1}:: Eq Char
addTcEvBind
  acC4
  [W] $dEq_acCM = GHC.Classes.$fEqChar @[] []
end stage top-level reactions }
Step 45[l:1,d:1] Top react: Dict/Top (solved wanted):
    [WD] $dEq_acCM {1}:: Eq Char
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dShow_acxy {0}:: Show
                                       a0_acxw[tau:1] (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 4}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
  rest of worklist = WL {Non-eqs = [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dShow_acxy {0}:: Show
                                         a0_acxw[tau:1] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1] (CNonCanonical)
canEvNC:cls Show [a0_acxw[tau:1]]
flatten_many { a0_acxw[tau:1]
Following filled tyvar a_acxw[tau:1] = String
flatten } String
canClass
  [WD] $dShow_acxy {0}:: Show a0_acxw[tau:1]
  Show String
  ContinueWith [WD] $dShow_acxy {0}:: Show String
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dShow_acxy {0}:: Show String (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dShow_acxy {0}:: Show String (CDictCan)
doTopReact [WD] $dShow_acxy {0}:: Show String (CDictCan)
matchClassInst pred = Show String {
matchClass success
  dict Show String
  witness GHC.Show.$fShow[] forall a. Show a => Show [a]
} matchClassInst result
  GenInst [Show Char]
          [safe]
doTopReact/found instance for [WD] $dShow_acxy {0}:: Show String
updSolvedSetTcs: [WD] $dShow_acxy {0}:: Show String
Emitting new wanted
  $dShow_acCS :: Show Char
  arising from a use of ‘@?=’ at test-suite-force/Tests.hs:57:35-75
addTcEvBind
  acC4
  [W] $dShow_acxy = GHC.Show.$fShow[] @[Char] [$dShow_acCS]
Emitting fresh work
  [WD] $dShow_acCS {1}:: Show Char (CNonCanonical)
end stage top-level reactions }
Step 46[l:1,d:0] Top react: Dict/Top (solved wanted):
    [WD] $dShow_acxy {0}:: Show String
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dShow_acCS {1}:: Show Char (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 4}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
  rest of worklist = WL {Non-eqs = [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dShow_acCS {1}:: Show Char (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dShow_acCS {1}:: Show Char (CNonCanonical)
canEvNC:cls Show [Char]
flatten_many { Char
flatten } Char
canClass
  [WD] $dShow_acCS {1}:: Show Char
  Show Char
  ContinueWith [WD] $dShow_acCS {1}:: Show Char
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dShow_acCS {1}:: Show Char (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dShow_acCS {1}:: Show Char (CDictCan)
doTopReact [WD] $dShow_acCS {1}:: Show Char (CDictCan)
matchClassInst pred = Show Char {
matchClass success
  dict Show Char
  witness GHC.Show.$fShowChar Show Char
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for [WD] $dShow_acCS {1}:: Show Char
updSolvedSetTcs: [WD] $dShow_acCS {1}:: Show Char
addTcEvBind
  acC4
  [W] $dShow_acCS = GHC.Show.$fShowChar @[] []
end stage top-level reactions }
Step 47[l:1,d:1] Top react: Dict/Top (solved wanted):
    [WD] $dShow_acCS {1}:: Show Char
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 4}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
  rest of worklist = WL {Non-eqs = [WD] $dShow_acA6 {0}:: Show
                                                            a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical)
canEvNC:cls GHC.Classes.IP ["callStack", GHC.Stack.Types.CallStack]
flatten_many {
  "callStack"
  GHC.Stack.Types.CallStack
flatten }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [WD] $dIP_acxE {0}:: HasCallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [WD] $dIP_acxE {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dIP_acxE {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
Emitting new wanted
  $dIP_acD3 :: ?callStack::GHC.Stack.Types.CallStack
  arising from a use of implicit parameter ‘?callStack’
  at test-suite-force/Tests.hs:57:35-75
Emitting fresh work
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CNonCanonical)
addTcEvBind
  acC4
  [W] $dIP_acxE
    = (@?=, test-suite-force/Tests.hs:57:35-75) : $dIP_acD3 `cast` (Sym
                                                                      (GHC.Classes.N:IP[0]
                                                                         <"callStack">_N
                                                                         <GHC.Stack.Types.CallStack>_N))
end stage interact with inerts }
Step 48[l:1,d:0] Wanted CallStack IP:
    [WD] $dIP_acxE {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 4}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
  rest of worklist = WL {Non-eqs = [WD] $dShow_acA6 {0}:: Show
                                                            a0_acA4[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CNonCanonical)
canEvNC:cls GHC.Classes.IP ["callStack", GHC.Stack.Types.CallStack]
flatten_many {
  "callStack"
  GHC.Stack.Types.CallStack
flatten }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
doTopReact
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
matchClassInst pred = ?callStack::GHC.Stack.Types.CallStack {
matchClass not matching dict ?callStack::GHC.Stack.Types.CallStack
} matchClassInst result NoInstance
try_fundeps
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
addInertCan }
Step 49[l:1,d:0] Kept as inert:
    [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (kept as inert) }
  final_item = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] $dShow_acA6 {0}:: Show
                                       a0_acA4[tau:1] (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 5}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
  rest of worklist = WL {Non-eqs = [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acA5[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dShow_acA6 {0}:: Show
                                         a0_acA4[tau:1] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1] (CNonCanonical)
canEvNC:cls Show [a0_acA4[tau:1]]
flatten_many { a0_acA4[tau:1]
Following filled tyvar a_acA4[tau:1] = Double
flatten } Double
canClass
  [WD] $dShow_acA6 {0}:: Show a0_acA4[tau:1]
  Show Double
  ContinueWith [WD] $dShow_acA6 {0}:: Show Double
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dShow_acA6 {0}:: Show Double (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dShow_acA6 {0}:: Show Double (CDictCan)
doTopReact [WD] $dShow_acA6 {0}:: Show Double (CDictCan)
matchClassInst pred = Show Double {
matchClass success
  dict Show Double
  witness GHC.Float.$fShowDouble Show Double
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for [WD] $dShow_acA6 {0}:: Show Double
updSolvedSetTcs: [WD] $dShow_acA6 {0}:: Show Double
addTcEvBind
  acC4
  [W] $dShow_acA6 = GHC.Float.$fShowDouble @[] []
end stage top-level reactions }
Step 50[l:1,d:0] Top react: Dict/Top (solved wanted):
    [WD] $dShow_acA6 {0}:: Show Double
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                            (Unpack u0_acA5[tau:1]) (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 5}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dEq_acAc {0}:: Eq
                                                          a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                              (Unpack u0_acA5[tau:1]) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownUnit_acA7 {0}:: KnownUnit
                                (Unpack u0_acA5[tau:1]) (CNonCanonical)
canEvNC:cls KnownUnit [Unpack u0_acA5[tau:1]]
flatten_many { Unpack u0_acA5[tau:1]
matchFamTcM
  Matching: Unpack u0_acA5[tau:1]
  Match failed
Unfilled tyvar u_acA5[tau:1]
matchFamTcM
  Matching: Unpack u0_acA5[tau:1]
  Match failed
New coercion hole: acD6
Emitting new coercion hole
  {acD6} :: (Unpack
               u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                   GHC.Types.Symbol)
            GHC.Prim.~#
            (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                 GHC.Types.Symbol)
extendFlatCache
  Unpack [u0_acA5[tau:1]]
  [WD]
  s0_acD5[fuv:0]
flatten/flat-cache miss
  Unpack [u0_acA5[tau:1]]
  s_acD5[fuv:0]
  [WD] hole{acD6} {0}:: (Unpack
                           u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
                        GHC.Prim.~#
                        (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                             GHC.Types.Symbol)
flatten } s0_acD5[fuv:0]
Emitting new wanted
  $dKnownUnit_acD7 :: KnownUnit s0_acD5[fuv:0]
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:57:35-53
addTcEvBind
  acC4
  [W] $dKnownUnit_acA7
    = $dKnownUnit_acD7 `cast` (KnownUnit (Sym {acD6}))_R
canClass
  [WD] $dKnownUnit_acA7 {0}:: KnownUnit (Unpack u0_acA5[tau:1])
  KnownUnit s0_acD5[fuv:0]
  ContinueWith [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                              s0_acD5[fuv:0] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                              s0_acD5[fuv:0] (CDictCan)
doTopReact
  [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
matchClassInst pred = KnownUnit s0_acD5[fuv:0] {
matchClass not matching dict KnownUnit s0_acD5[fuv:0]
} matchClassInst result NoInstance
try_fundeps
  [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                        s0_acD5[fuv:0] (CDictCan)
addInertCan }
Step 51[l:1,d:0] Kept as inert:
    [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0]
End solver pipeline (kept as inert) }
  final_item = [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                             s0_acD5[fuv:0] (CDictCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acD6} {0}:: (Unpack
                                       u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                                    GHC.Prim.~#
                                    (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol) (CFunEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 6}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dEq_acAc {0}:: Eq
                                                          a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acD6} {0}:: (Unpack
                                         u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
flatten_many { u0_acA5[tau:1]
Unfilled tyvar u_acA5[tau:1]
flatten } u0_acA5[tau:1]
extendFlatCache
  Unpack [u0_acA5[tau:1]]
  [WD]
  s0_acD5[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acD6} {0}:: (Unpack
                                         u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acD6} {0}:: (Unpack
                                         u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
doTopReact
  [WD] hole{acD6} {0}:: (Unpack
                           u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
                        GHC.Prim.~#
                        (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                             GHC.Types.Symbol) (CFunEqCan)
matchFamTcM
  Matching: Unpack u0_acA5[tau:1]
  Match failed
improveTopFunEqs
  Unpack [u0_acA5[tau:1]] s_acD5[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acD6} {0}:: (Unpack
                                                                   u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                       GHC.Types.Symbol)
                                                                GHC.Prim.~#
                                                                (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                     GHC.Types.Symbol) (CFunEqCan)
addInertCan }
Step 52[l:1,d:0] Kept as inert:
    [WD] hole{acD6} {0}:: (Unpack
                             u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                 GHC.Types.Symbol)
                          GHC.Prim.~#
                          (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acD6} {0}:: (Unpack
                                        u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                                       [WD] hole{acD6} {0}:: (Unpack
                                                                u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 6}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dShow_acAd {0}:: Show
                                                            a0_acAb[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dEq_acAc {0}:: Eq
                                       a0_acAb[tau:1] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1] (CNonCanonical)
canEvNC:cls Eq [a0_acAb[tau:1]]
flatten_many { a0_acAb[tau:1]
Following filled tyvar a_acAb[tau:1] = String
flatten } String
canClass
  [WD] $dEq_acAc {0}:: Eq a0_acAb[tau:1]
  Eq String
  ContinueWith [WD] $dEq_acAc {0}:: Eq String
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dEq_acAc {0}:: Eq String (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dEq_acAc {0}:: Eq String (CDictCan)
doTopReact [WD] $dEq_acAc {0}:: Eq String (CDictCan)
addTcEvBind
  acC4
  [W] $dEq_acAc = $dEq_acxx
end stage top-level reactions }
Step 53[l:1,d:0] Top react: Dict/Top (cached):
    [WD] $dEq_acAc {0}:: Eq String
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dShow_acAd {0}:: Show
                                       a0_acAb[tau:1] (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                                       [WD] hole{acD6} {0}:: (Unpack
                                                                u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 6}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dShow_acAd {0}:: Show
                                         a0_acAb[tau:1] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1] (CNonCanonical)
canEvNC:cls Show [a0_acAb[tau:1]]
flatten_many { a0_acAb[tau:1]
Following filled tyvar a_acAb[tau:1] = String
flatten } String
canClass
  [WD] $dShow_acAd {0}:: Show a0_acAb[tau:1]
  Show String
  ContinueWith [WD] $dShow_acAd {0}:: Show String
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dShow_acAd {0}:: Show String (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dShow_acAd {0}:: Show String (CDictCan)
doTopReact [WD] $dShow_acAd {0}:: Show String (CDictCan)
addTcEvBind
  acC4
  [W] $dShow_acAd = $dShow_acxy
end stage top-level reactions }
Step 54[l:1,d:0] Top react: Dict/Top (cached):
    [WD] $dShow_acAd {0}:: Show String
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                                       [WD] hole{acD6} {0}:: (Unpack
                                                                u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 6}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dShow_acAh {0}:: Show
                                                            a0_acAf[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical)
canEvNC:cls GHC.Classes.IP ["callStack", GHC.Stack.Types.CallStack]
flatten_many {
  "callStack"
  GHC.Stack.Types.CallStack
flatten }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [WD] $dIP_acAe {0}:: HasCallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [WD] $dIP_acAe {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dIP_acAe {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
newWantedEvVar/cache hit
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
addTcEvBind
  acC4
  [W] $dIP_acAe
    = (@?=, test-suite-force/Tests.hs:58:35-81) : $dIP_acD3 `cast` (Sym
                                                                      (GHC.Classes.N:IP[0]
                                                                         <"callStack">_N
                                                                         <GHC.Stack.Types.CallStack>_N))
end stage interact with inerts }
Step 55[l:1,d:0] Wanted CallStack IP:
    [WD] $dIP_acAe {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dShow_acAh {0}:: Show
                                       a0_acAf[tau:1] (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                                       [WD] hole{acD6} {0}:: (Unpack
                                                                u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 6}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAg[tau:1]) (CNonCanonical)
                                   [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dShow_acAh {0}:: Show
                                         a0_acAf[tau:1] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1] (CNonCanonical)
canEvNC:cls Show [a0_acAf[tau:1]]
flatten_many { a0_acAf[tau:1]
Following filled tyvar a_acAf[tau:1] = Double
flatten } Double
canClass
  [WD] $dShow_acAh {0}:: Show a0_acAf[tau:1]
  Show Double
  ContinueWith [WD] $dShow_acAh {0}:: Show Double
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dShow_acAh {0}:: Show Double (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dShow_acAh {0}:: Show Double (CDictCan)
doTopReact [WD] $dShow_acAh {0}:: Show Double (CDictCan)
addTcEvBind
  acC4
  [W] $dShow_acAh = $dShow_acA6
end stage top-level reactions }
Step 56[l:1,d:0] Top react: Dict/Top (cached):
    [WD] $dShow_acAh {0}:: Show Double
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                            (Unpack u0_acAg[tau:1]) (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                                       [WD] hole{acD6} {0}:: (Unpack
                                                                u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 6}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dEq_acAn {0}:: Eq
                                                          a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                              (Unpack u0_acAg[tau:1]) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownUnit_acAi {0}:: KnownUnit
                                (Unpack u0_acAg[tau:1]) (CNonCanonical)
canEvNC:cls KnownUnit [Unpack u0_acAg[tau:1]]
flatten_many { Unpack u0_acAg[tau:1]
matchFamTcM
  Matching: Unpack u0_acAg[tau:1]
  Match failed
Unfilled tyvar u_acAg[tau:1]
matchFamTcM
  Matching: Unpack u0_acAg[tau:1]
  Match failed
New coercion hole: acDc
Emitting new coercion hole
  {acDc} :: (Unpack
               u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                   GHC.Types.Symbol)
            GHC.Prim.~#
            (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                 GHC.Types.Symbol)
extendFlatCache
  Unpack [u0_acAg[tau:1]]
  [WD]
  s0_acDb[fuv:0]
flatten/flat-cache miss
  Unpack [u0_acAg[tau:1]]
  s_acDb[fuv:0]
  [WD] hole{acDc} {0}:: (Unpack
                           u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
                        GHC.Prim.~#
                        (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                             GHC.Types.Symbol)
flatten } s0_acDb[fuv:0]
Emitting new wanted
  $dKnownUnit_acDd :: KnownUnit s0_acDb[fuv:0]
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:58:35-61
addTcEvBind
  acC4
  [W] $dKnownUnit_acAi
    = $dKnownUnit_acDd `cast` (KnownUnit (Sym {acDc}))_R
canClass
  [WD] $dKnownUnit_acAi {0}:: KnownUnit (Unpack u0_acAg[tau:1])
  KnownUnit s0_acDb[fuv:0]
  ContinueWith [WD] $dKnownUnit_acDd {0}:: KnownUnit s0_acDb[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                              s0_acDb[fuv:0] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                              s0_acDb[fuv:0] (CDictCan)
doTopReact
  [WD] $dKnownUnit_acDd {0}:: KnownUnit s0_acDb[fuv:0] (CDictCan)
matchClassInst pred = KnownUnit s0_acDb[fuv:0] {
matchClass not matching dict KnownUnit s0_acDb[fuv:0]
} matchClassInst result NoInstance
try_fundeps
  [WD] $dKnownUnit_acDd {0}:: KnownUnit s0_acDb[fuv:0] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                        s0_acDb[fuv:0] (CDictCan)
addInertCan }
Step 57[l:1,d:0] Kept as inert:
    [WD] $dKnownUnit_acDd {0}:: KnownUnit s0_acDb[fuv:0]
End solver pipeline (kept as inert) }
  final_item = [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                             s0_acDb[fuv:0] (CDictCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acDc} {0}:: (Unpack
                                       u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                                    GHC.Prim.~#
                                    (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol) (CFunEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                                       [WD] hole{acD6} {0}:: (Unpack
                                                                u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
                           [WD] $dKnownUnit_acDd {0}:: KnownUnit s0_acDb[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 7}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dEq_acAn {0}:: Eq
                                                          a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{acDc} {0}:: (Unpack
                                         u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
flatten_many { u0_acAg[tau:1]
Unfilled tyvar u_acAg[tau:1]
flatten } u0_acAg[tau:1]
extendFlatCache
  Unpack [u0_acAg[tau:1]]
  [WD]
  s0_acDb[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acDc} {0}:: (Unpack
                                         u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acDc} {0}:: (Unpack
                                         u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
doTopReact
  [WD] hole{acDc} {0}:: (Unpack
                           u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
                        GHC.Prim.~#
                        (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                             GHC.Types.Symbol) (CFunEqCan)
matchFamTcM
  Matching: Unpack u0_acAg[tau:1]
  Match failed
improveTopFunEqs
  Unpack [u0_acAg[tau:1]] s_acDb[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acDc} {0}:: (Unpack
                                                                   u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                       GHC.Types.Symbol)
                                                                GHC.Prim.~#
                                                                (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                     GHC.Types.Symbol) (CFunEqCan)
addInertCan }
Step 58[l:1,d:0] Kept as inert:
    [WD] hole{acDc} {0}:: (Unpack
                             u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                 GHC.Types.Symbol)
                          GHC.Prim.~#
                          (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acDc} {0}:: (Unpack
                                        u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                                       [WD] hole{acD6} {0}:: (Unpack
                                                                u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
                                       [WD] hole{acDc} {0}:: (Unpack
                                                                u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
                           [WD] $dKnownUnit_acDd {0}:: KnownUnit s0_acDb[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 7}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dShow_acAo {0}:: Show
                                                            a0_acAm[tau:1] (CNonCanonical)
                                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dEq_acAn {0}:: Eq
                                       a0_acAm[tau:1] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1] (CNonCanonical)
canEvNC:cls Eq [a0_acAm[tau:1]]
flatten_many { a0_acAm[tau:1]
Following filled tyvar a_acAm[tau:1] = String
flatten } String
canClass
  [WD] $dEq_acAn {0}:: Eq a0_acAm[tau:1]
  Eq String
  ContinueWith [WD] $dEq_acAn {0}:: Eq String
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dEq_acAn {0}:: Eq String (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dEq_acAn {0}:: Eq String (CDictCan)
doTopReact [WD] $dEq_acAn {0}:: Eq String (CDictCan)
addTcEvBind
  acC4
  [W] $dEq_acAn = $dEq_acxx
end stage top-level reactions }
Step 59[l:1,d:0] Top react: Dict/Top (cached):
    [WD] $dEq_acAn {0}:: Eq String
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dShow_acAo {0}:: Show
                                       a0_acAm[tau:1] (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                                       [WD] hole{acD6} {0}:: (Unpack
                                                                u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
                                       [WD] hole{acDc} {0}:: (Unpack
                                                                u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
                           [WD] $dKnownUnit_acDd {0}:: KnownUnit s0_acDb[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 7}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
                                   [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dShow_acAo {0}:: Show
                                         a0_acAm[tau:1] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1] (CNonCanonical)
canEvNC:cls Show [a0_acAm[tau:1]]
flatten_many { a0_acAm[tau:1]
Following filled tyvar a_acAm[tau:1] = String
flatten } String
canClass
  [WD] $dShow_acAo {0}:: Show a0_acAm[tau:1]
  Show String
  ContinueWith [WD] $dShow_acAo {0}:: Show String
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dShow_acAo {0}:: Show String (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dShow_acAo {0}:: Show String (CDictCan)
doTopReact [WD] $dShow_acAo {0}:: Show String (CDictCan)
addTcEvBind
  acC4
  [W] $dShow_acAo = $dShow_acxy
end stage top-level reactions }
Step 60[l:1,d:0] Top react: Dict/Top (cached):
    [WD] $dShow_acAo {0}:: Show String
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                                       [WD] hole{acD6} {0}:: (Unpack
                                                                u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
                                       [WD] hole{acDc} {0}:: (Unpack
                                                                u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
                           [WD] $dKnownUnit_acDd {0}:: KnownUnit s0_acDb[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 7}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dShow_acAs {0}:: Show
                                                            a0_acAq[tau:1] (CNonCanonical)
                                   [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical)
canEvNC:cls GHC.Classes.IP ["callStack", GHC.Stack.Types.CallStack]
flatten_many {
  "callStack"
  GHC.Stack.Types.CallStack
flatten }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [WD] $dIP_acAp {0}:: HasCallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [WD] $dIP_acAp {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dIP_acAp {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
newWantedEvVar/cache hit
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
addTcEvBind
  acC4
  [W] $dIP_acAp
    = (@?=, test-suite-force/Tests.hs:59:35-85) : $dIP_acD3 `cast` (Sym
                                                                      (GHC.Classes.N:IP[0]
                                                                         <"callStack">_N
                                                                         <GHC.Stack.Types.CallStack>_N))
end stage interact with inerts }
Step 61[l:1,d:0] Wanted CallStack IP:
    [WD] $dIP_acAp {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dShow_acAs {0}:: Show
                                       a0_acAq[tau:1] (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                                       [WD] hole{acD6} {0}:: (Unpack
                                                                u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
                                       [WD] hole{acDc} {0}:: (Unpack
                                                                u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
                           [WD] $dKnownUnit_acDd {0}:: KnownUnit s0_acDb[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 7}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                                                 (Unpack
                                                                    u0_acAr[tau:1]) (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] $dShow_acAs {0}:: Show
                                         a0_acAq[tau:1] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1] (CNonCanonical)
canEvNC:cls Show [a0_acAq[tau:1]]
flatten_many { a0_acAq[tau:1]
Following filled tyvar a_acAq[tau:1] = Double
flatten } Double
canClass
  [WD] $dShow_acAs {0}:: Show a0_acAq[tau:1]
  Show Double
  ContinueWith [WD] $dShow_acAs {0}:: Show Double
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dShow_acAs {0}:: Show Double (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dShow_acAs {0}:: Show Double (CDictCan)
doTopReact [WD] $dShow_acAs {0}:: Show Double (CDictCan)
addTcEvBind
  acC4
  [W] $dShow_acAs = $dShow_acA6
end stage top-level reactions }
Step 62[l:1,d:0] Top react: Dict/Top (cached):
    [WD] $dShow_acAs {0}:: Show Double
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                            (Unpack u0_acAr[tau:1]) (CNonCanonical)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                                       [WD] hole{acD6} {0}:: (Unpack
                                                                u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
                                       [WD] hole{acDc} {0}:: (Unpack
                                                                u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
                           [WD] $dKnownUnit_acDd {0}:: KnownUnit s0_acDb[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 7}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                              (Unpack u0_acAr[tau:1]) (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownUnit_acAt {0}:: KnownUnit
                                (Unpack u0_acAr[tau:1]) (CNonCanonical)
canEvNC:cls KnownUnit [Unpack u0_acAr[tau:1]]
flatten_many { Unpack u0_acAr[tau:1]
matchFamTcM
  Matching: Unpack u0_acAr[tau:1]
  Match failed
Unfilled tyvar u_acAr[tau:1]
matchFamTcM
  Matching: Unpack u0_acAr[tau:1]
  Match failed
New coercion hole: acDf
Emitting new coercion hole
  {acDf} :: (Unpack
               u0_acAr[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                   GHC.Types.Symbol)
            GHC.Prim.~#
            (s0_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                 GHC.Types.Symbol)
extendFlatCache
  Unpack [u0_acAr[tau:1]]
  [WD]
  s0_acDe[fuv:0]
flatten/flat-cache miss
  Unpack [u0_acAr[tau:1]]
  s_acDe[fuv:0]
  [WD] hole{acDf} {0}:: (Unpack
                           u0_acAr[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
                        GHC.Prim.~#
                        (s0_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                             GHC.Types.Symbol)
flatten } s0_acDe[fuv:0]
Emitting new wanted
  $dKnownUnit_acDg :: KnownUnit s0_acDe[fuv:0]
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:59:35-60
addTcEvBind
  acC4
  [W] $dKnownUnit_acAt
    = $dKnownUnit_acDg `cast` (KnownUnit (Sym {acDf}))_R
canClass
  [WD] $dKnownUnit_acAt {0}:: KnownUnit (Unpack u0_acAr[tau:1])
  KnownUnit s0_acDe[fuv:0]
  ContinueWith [WD] $dKnownUnit_acDg {0}:: KnownUnit s0_acDe[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                              s0_acDe[fuv:0] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                              s0_acDe[fuv:0] (CDictCan)
doTopReact
  [WD] $dKnownUnit_acDg {0}:: KnownUnit s0_acDe[fuv:0] (CDictCan)
matchClassInst pred = KnownUnit s0_acDe[fuv:0] {
matchClass not matching dict KnownUnit s0_acDe[fuv:0]
} matchClassInst result NoInstance
try_fundeps
  [WD] $dKnownUnit_acDg {0}:: KnownUnit s0_acDe[fuv:0] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                        s0_acDe[fuv:0] (CDictCan)
addInertCan }
Step 63[l:1,d:0] Kept as inert:
    [WD] $dKnownUnit_acDg {0}:: KnownUnit s0_acDe[fuv:0]
End solver pipeline (kept as inert) }
  final_item = [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                             s0_acDe[fuv:0] (CDictCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acDf} {0}:: (Unpack
                                       u0_acAr[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                                    GHC.Prim.~#
                                    (s0_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol) (CFunEqCan)
  inerts = {Equalities: [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acA5[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAr[tau:1] :: Unit) (CTyEqCan)
                        [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                                    GHC.Prim.~#
                                    (u0_acAg[tau:1] :: Unit) (CTyEqCan)
                        [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                             GHC.Prim.~#
                                             (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            Type-function equalities = [WD] hole{acC6} {2}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0]
                                                               /: s1_acCi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0]
                                                               *: s0_acCg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0]
                                                               *: s1_acC7[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
                                       [D] _ {1}:: ((u0_acA5[tau:1] *: s0_acC7[fuv:0]) :: Unit)
                                                   GHC.Prim.~#
                                                   (s1_acC9[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCE} {0}:: ((u0_acAg[tau:1]
                                                               *: u1_acA5[tau:1]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
                                       [WD] hole{acD6} {0}:: (Unpack
                                                                u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
                                       [WD] hole{acDc} {0}:: (Unpack
                                                                u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol)
                                                             GHC.Prim.~#
                                                             (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                  GHC.Types.Symbol) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                           [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan)
                           [WD] $dKnownUnit_acDd {0}:: KnownUnit s0_acDb[fuv:0] (CDictCan)
                           [WD] $dKnownUnit_acDg {0}:: KnownUnit s0_acDe[fuv:0] (CDictCan)
            Irreds = [WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan)
            Unsolved goals = 8}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] hole{acDf} {0}:: (Unpack
                                         u0_acAr[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s0_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
flatten_many { u0_acAr[tau:1]
Unfilled tyvar u_acAr[tau:1]
flatten } u0_acAr[tau:1]
extendFlatCache
  Unpack [u0_acAr[tau:1]]
  [WD]
  s0_acDe[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acDf} {0}:: (Unpack
                                         u0_acAr[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s0_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acDf} {0}:: (Unpack
                                         u0_acAr[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                             GHC.Types.Symbol)
                                      GHC.Prim.~#
                                      (s0_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol) (CFunEqCan)
doTopReact
  [WD] hole{acDf} {0}:: (Unpack
                           u0_acAr[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
                        GHC.Prim.~#
                        (s0_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                             GHC.Types.Symbol) (CFunEqCan)
matchFamTcM
  Matching: Unpack u0_acAr[tau:1]
  Match failed
improveTopFunEqs
  Unpack [u0_acAr[tau:1]] s_acDe[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acDf} {0}:: (Unpack
                                                                   u0_acAr[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                       GHC.Types.Symbol)
                                                                GHC.Prim.~#
                                                                (s0_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                     GHC.Types.Symbol) (CFunEqCan)
addInertCan }
Step 64[l:1,d:0] Kept as inert:
    [WD] hole{acDf} {0}:: (Unpack
                             u0_acAr[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                 GHC.Types.Symbol)
                          GHC.Prim.~#
                          (s0_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acDf} {0}:: (Unpack
                                        u0_acAr[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (s0_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
getUnsolvedInerts
   tv eqs = {[D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                         GHC.Prim.~#
                         (u0_acA5[tau:1] :: Unit) (CTyEqCan),
             [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                  GHC.Prim.~#
                                  (u0_acA5[tau:1] :: Unit) (CTyEqCan),
             [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                         GHC.Prim.~#
                         (u0_acAr[tau:1] :: Unit) (CTyEqCan),
             [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                  GHC.Prim.~#
                                  (u0_acAr[tau:1] :: Unit) (CTyEqCan),
             [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                         GHC.Prim.~#
                         (u0_acAg[tau:1] :: Unit) (CTyEqCan),
             [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                  GHC.Prim.~#
                                  (u0_acAg[tau:1] :: Unit) (CTyEqCan)}
  fun eqs = {[WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acC5[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acC7[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acCg[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acCo[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acCk[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0] *: s0_acCg[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s1_acCi[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acCw[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acCE} {0}:: ((u0_acAg[tau:1] *: u1_acA5[tau:1]) :: Unit)
                                   GHC.Prim.~#
                                   (s0_acCD[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                     Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                   GHC.Prim.~#
                                   (s1_acCF[fuv:0] :: Constraint) (CFunEqCan),
             [WD] hole{acD6} {0}:: (Unpack
                                      u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                        GHC.Types.Symbol) (CFunEqCan),
             [WD] hole{acDc} {0}:: (Unpack
                                      u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                        GHC.Types.Symbol) (CFunEqCan),
             [WD] hole{acDf} {0}:: (Unpack
                                      u0_acAr[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (s0_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                        GHC.Types.Symbol) (CFunEqCan)}
  insols = {}
  others = {[WD] irred_acCH {0}:: s0_acCF[fuv:0] (CIrredEvCan),
            [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan),
            [WD] $dKnownUnit_acD7 {0}:: KnownUnit s0_acD5[fuv:0] (CDictCan),
            [WD] $dKnownUnit_acDd {0}:: KnownUnit s0_acDb[fuv:0] (CDictCan),
            [WD] $dKnownUnit_acDg {0}:: KnownUnit s0_acDe[fuv:0] (CDictCan)}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{acC6} {2}:: (Base "kg" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acC5[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acC8} {2}:: (Base "m" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acC7[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acCh} {3}:: (Base "s" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acCg[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acCp} {0}:: ((s0_acC7[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acCo[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acCl} {1}:: ((s0_acCw[fuv:0] /: s1_acCi[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acCk[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acCj} {2}:: ((s0_acCg[fuv:0] *: s0_acCg[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s1_acCi[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acCx} {1}:: ((s0_acC5[fuv:0] *: s1_acC7[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acCw[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acCE} {0}:: ((u0_acAg[tau:1] *: u1_acA5[tau:1]) :: Unit)
                                  GHC.Prim.~#
                                  (s0_acCD[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acCG} {0}:: ((u0_acAr[tau:1]
                                    Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]) :: Constraint)
                                  GHC.Prim.~#
                                  (s1_acCF[fuv:0] :: Constraint) (CFunEqCan)
            [WD] hole{acD6} {0}:: (Unpack
                                     u0_acA5[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol)
                                  GHC.Prim.~#
                                  (s0_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                       GHC.Types.Symbol) (CFunEqCan)
            [WD] hole{acDc} {0}:: (Unpack
                                     u0_acAg[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol)
                                  GHC.Prim.~#
                                  (s0_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                       GHC.Types.Symbol) (CFunEqCan)
            [WD] hole{acDf} {0}:: (Unpack
                                     u0_acAr[tau:1] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol)
                                  GHC.Prim.~#
                                  (s0_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                       GHC.Types.Symbol) (CFunEqCan)
   Tv eqs = [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                                 GHC.Prim.~#
                                 (u0_acA5[tau:1] :: Unit) (CTyEqCan)
            [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (u0_acAr[tau:1] :: Unit) (CTyEqCan)
            [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                                 GHC.Prim.~#
                                 (u0_acAr[tau:1] :: Unit) (CTyEqCan)
            [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
                        GHC.Prim.~#
                        (u0_acAg[tau:1] :: Unit) (CTyEqCan)
            [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                                 GHC.Prim.~#
                                 (u0_acAg[tau:1] :: Unit) (CTyEqCan)}
Filling coercion hole acDf := <Unpack u0_acAr[tau:1]>_N
unflattenFmv s_acDe[fuv:0] := Unpack u0_acAr[tau:1]
writeMetaTyVar
  s_acDe[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                     GHC.Types.Symbol := Unpack u0_acAr[tau:1]
Filling coercion hole acDc := <Unpack u0_acAg[tau:1]>_N
unflattenFmv s_acDb[fuv:0] := Unpack u0_acAg[tau:1]
writeMetaTyVar
  s_acDb[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                     GHC.Types.Symbol := Unpack u0_acAg[tau:1]
Filling coercion hole acD6 := <Unpack u0_acA5[tau:1]>_N
unflattenFmv s_acD5[fuv:0] := Unpack u0_acA5[tau:1]
writeMetaTyVar
  s_acD5[fuv:0] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                     GHC.Types.Symbol := Unpack u0_acA5[tau:1]
Filling coercion hole
  acCG := <u0_acAr[tau:1]
           Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]>_N
unflattenFmv
  s_acCF[fuv:0] := u0_acAr[tau:1]
                   Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]
writeMetaTyVar
  s_acCF[fuv:0] :: Constraint := u0_acAr[tau:1]
                                 Data.UnitsOfMeasure.Syntax.~~ s0_acCD[fuv:0]
Filling coercion hole acCE := <u0_acAg[tau:1] *: u1_acA5[tau:1]>_N
unflattenFmv s_acCD[fuv:0] := u0_acAg[tau:1] *: u1_acA5[tau:1]
writeMetaTyVar
  s_acCD[fuv:0] :: Unit := u0_acAg[tau:1] *: u1_acA5[tau:1]
Filling coercion hole acCx := <s0_acC5[fuv:0] *: s1_acC7[fuv:0]>_N
unflattenFmv s_acCw[fuv:0] := s0_acC5[fuv:0] *: s1_acC7[fuv:0]
writeMetaTyVar
  s_acCw[fuv:0] :: Unit := s0_acC5[fuv:0] *: s1_acC7[fuv:0]
Filling coercion hole acCj := <s0_acCg[fuv:0] *: s0_acCg[fuv:0]>_N
unflattenFmv s_acCi[fuv:0] := s0_acCg[fuv:0] *: s0_acCg[fuv:0]
writeMetaTyVar
  s_acCi[fuv:0] :: Unit := s0_acCg[fuv:0] *: s0_acCg[fuv:0]
Filling coercion hole
  acCl := <(s0_acC5[fuv:0] *: s1_acC7[fuv:0])
           /: (s2_acCg[fuv:0] *: s2_acCg[fuv:0])>_N
unflattenFmv
  s_acCk[fuv:0] := (s0_acC5[fuv:0] *: s1_acC7[fuv:0])
                   /: (s2_acCg[fuv:0] *: s2_acCg[fuv:0])
writeMetaTyVar
  s_acCk[fuv:0] :: Unit := (s0_acC5[fuv:0] *: s1_acC7[fuv:0])
                           /: (s2_acCg[fuv:0] *: s2_acCg[fuv:0])
Filling coercion hole
  acCp := <s0_acC7[fuv:0] /: (s1_acCg[fuv:0] *: s1_acCg[fuv:0])>_N
unflattenFmv
  s_acCo[fuv:0] := s0_acC7[fuv:0]
                   /: (s1_acCg[fuv:0] *: s1_acCg[fuv:0])
writeMetaTyVar
  s_acCo[fuv:0] :: Unit := s0_acC7[fuv:0]
                           /: (s1_acCg[fuv:0] *: s1_acCg[fuv:0])
Filling coercion hole acCh := <Base "s">_N
unflattenFmv s_acCg[fuv:0] := Base "s"
writeMetaTyVar s_acCg[fuv:0] :: Unit := Base "s"
Filling coercion hole acC8 := <Base "m">_N
unflattenFmv s_acC7[fuv:0] := Base "m"
writeMetaTyVar s_acC7[fuv:0] :: Unit := Base "m"
Filling coercion hole acC6 := <Base "kg">_N
unflattenFmv s_acC5[fuv:0] := Base "kg"
writeMetaTyVar s_acC5[fuv:0] :: Unit := Base "kg"
Unflattening 1 {}
unflatten_eq 2
  [W] hole{acCv} {1}:: (s0_acCo[fuv:0] :: Unit)
                       GHC.Prim.~#
                       (u0_acAg[tau:1] :: Unit) (CTyEqCan)
Filling coercion hole
  acCv := <Base "m" /: (Base "s" *: Base "s")>_N
unifyTyVar u_acAg[tau:1] := Base "m" /: (Base "s" *: Base "s")
writeMetaTyVar
  u_acAg[tau:1] :: Unit := Base "m" /: (Base "s" *: Base "s")
unflatten_eq 2
  [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acAg[tau:1] :: Unit) (CTyEqCan)
unflatten_eq 2
  [W] hole{acCA} {1}:: (s0_acCk[fuv:0] :: Unit)
                       GHC.Prim.~#
                       (u0_acAr[tau:1] :: Unit) (CTyEqCan)
Filling coercion hole
  acCA := <(Base "kg" *: Base "m") /: (Base "s" *: Base "s")>_N
unifyTyVar
  u_acAr[tau:1] := (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
writeMetaTyVar
  u_acAr[tau:1] :: Unit := (Base "kg" *: Base "m")
                           /: (Base "s" *: Base "s")
unflatten_eq 2
  [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acAr[tau:1] :: Unit) (CTyEqCan)
unflatten_eq 2
  [W] hole{acCu} {1}:: (s0_acC5[fuv:0] :: Unit)
                       GHC.Prim.~#
                       (u0_acA5[tau:1] :: Unit) (CTyEqCan)
Filling coercion hole acCu := <Base "kg">_N
unifyTyVar u_acA5[tau:1] := Base "kg"
writeMetaTyVar u_acA5[tau:1] :: Unit := Base "kg"
unflatten_eq 2
  [D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
              GHC.Prim.~#
              (u0_acA5[tau:1] :: Unit) (CTyEqCan)
Unflattening 2
  {[D] _ {1}:: (s0_acC5[fuv:0] :: Unit)
               GHC.Prim.~#
               (u0_acA5[tau:1] :: Unit) (CTyEqCan)
   [D] _ {2}:: (s0_acCk[fuv:0] :: Unit)
               GHC.Prim.~#
               (u0_acAr[tau:1] :: Unit) (CTyEqCan)
   [D] _ {1}:: (s0_acCo[fuv:0] :: Unit)
               GHC.Prim.~#
               (u0_acAg[tau:1] :: Unit) (CTyEqCan)}
Unflattening 3 {}
Unflattening done {}
zonkSimples done: {}
zonkSimples done:
  {[WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan),
   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                 (Unpack (Base "kg")) (CDictCan),
   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                 (Unpack (Base "m" /: (Base "s" *: Base "s"))) (CDictCan),
   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                 (Unpack
                                    ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))) (CDictCan)}
tcPluginSolve start thoralf-uom-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan),
             [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                           (Unpack (Base "kg")) (CDictCan),
             [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                           (Unpack (Base "m" /: (Base "s" *: Base "s"))) (CDictCan),
             [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                           (Unpack
                                              ((Base "kg" *: Base "m")
                                               /: (Base "s" *: Base "s"))) (CDictCan)]
thoralf-solve gsConvCts Just [ ] [] []
thoralf-solve wsConvCts
  Just [ (= ((_ map (- (Int Int) Int)) ((_ map (+ (Int Int) Int)) (store base "kg" n1) (store base "m" n1)) ((_ map (+ (Int Int) Int)) (store base "s" n1) (store base "s" n1))) ((_ map (+ (Int Int) Int)) ((_ map (- (Int Int) Int)) (store base "m" n1) ((_ map (+ (Int Int) Int)) (store base "s" n1) (store base "s" n1))) (store base "kg" n1))) ] [[WD] irred_acCH {0}:: ((Base
                                                                                                                                                                                                                                                                                                                                                                                    "kg"
                                                                                                                                                                                                                                                                                                                                                                                  *: Base
                                                                                                                                                                                                                                                                                                                                                                                       "m")
                                                                                                                                                                                                                                                                                                                                                                                 /: (Base
                                                                                                                                                                                                                                                                                                                                                                                       "s"
                                                                                                                                                                                                                                                                                                                                                                                     *: Base
                                                                                                                                                                                                                                                                                                                                                                                          "s"))
                                                                                                                                                                                                                                                                                                                                                                                Data.UnitsOfMeasure.Syntax.~~ ((Base
                                                                                                                                                                                                                                                                                                                                                                                                                  "m"
                                                                                                                                                                                                                                                                                                                                                                                                                /: (Base
                                                                                                                                                                                                                                                                                                                                                                                                                      "s"
                                                                                                                                                                                                                                                                                                                                                                                                                    *: Base
                                                                                                                                                                                                                                                                                                                                                                                                                         "s"))
                                                                                                                                                                                                                                                                                                                                                                                                               *: Base
                                                                                                                                                                                                                                                                                                                                                                                                                    "kg") (CNonCanonical)] []
thoralf-solve decls []
thoralf-solve decls filtered []
thoralf-solve givens []
thoralf-solve givens filtered []
thoralf-solve wanteds
  [[WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan),
   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                 (Unpack (Base "kg")) (CDictCan),
   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                 (Unpack (Base "m" /: (Base "s" *: Base "s"))) (CDictCan),
   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                 (Unpack
                                    ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))) (CDictCan)]
thoralf-solve wanteds filtered
  [[WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan),
   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                 (Unpack (Base "kg")) (CDictCan),
   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                 (Unpack (Base "m" /: (Base "s" *: Base "s"))) (CDictCan),
   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                 (Unpack
                                    ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))) (CDictCan)]
thoralf-solve simplified given sexprs []
thoralf-solve simplified wanteds []
tcPluginSolve ok thoralf-uom-plugin
  solved = []
  new    = []
tcPluginSolve start uom-eq-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan),
             [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                           (Unpack (Base "kg")) (CDictCan),
             [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                           (Unpack (Base "m" /: (Base "s" *: Base "s"))) (CDictCan),
             [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                           (Unpack
                                              ((Base "kg" *: Base "m")
                                               /: (Base "s" *: Base "s"))) (CDictCan)]
tcPluginSolve ok uom-eq-plugin
  solved = []
  new    = [[WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                   /: (Base "s" *: Base "s"))
                                  Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                  /: (Base "s" *: Base "s"))
                                                                 *: Base "kg") (CNonCanonical)]
tcPluginSolve start uom-unpack-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan),
             [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                           (Unpack (Base "kg")) (CDictCan),
             [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                           (Unpack (Base "m" /: (Base "s" *: Base "s"))) (CDictCan),
             [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                           (Unpack
                                              ((Base "kg" *: Base "m")
                                               /: (Base "s" *: Base "s"))) (CDictCan)]
addTcEvBind
  acC4
  [G] cobox_acDh
    = CO U(plugin:units, Unpack (Base "kg"), '["kg"]
                                             'Data.UnitsOfMeasure.Syntax.:/ '[])_N
addTcEvBind
  acC4
  [G] cobox_acDi
    = CO U(plugin:units, Unpack
                           (Base "m" /: (Base "s" *: Base "s")), '["m"]
                                                                 'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                                  "s"])_N
addTcEvBind
  acC4
  [G] cobox_acDj
    = CO U(plugin:units, Unpack
                           ((Base "kg" *: Base "m") /: (Base "s" *: Base "s")), '["kg", "m"]
                                                                                'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                                                 "s"])_N
tcPluginSolve ok uom-unpack-plugin
  solved = []
  new    = [[G] cobox_acDh {0}:: (Unpack
                                    (Base "kg") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                     GHC.Types.Symbol)
                                 GHC.Prim.~#
                                 (('["kg"]
                                   'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CNonCanonical),
            [G] cobox_acDi {0}:: (Unpack
                                    (Base "m"
                                     /: (Base "s"
                                         *: Base "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                 GHC.Prim.~#
                                 (('["m"]
                                   'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                    "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol) (CNonCanonical),
            [G] cobox_acDj {0}:: (Unpack
                                    ((Base "kg" *: Base "m")
                                     /: (Base "s"
                                         *: Base "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                 GHC.Prim.~#
                                 (('["kg", "m"]
                                   'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                    "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol) (CNonCanonical)]
solveSimple going round again:
  3
  True
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDh {0}:: (Unpack
                                      (Base "kg") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                       GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (('["kg"]
                                     'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol) (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Funeqs = [G] cobox_acDi {0}:: (Unpack
                                                          (Base "m"
                                                           /: (Base "s"
                                                               *: Base
                                                                    "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (('["m"]
                                                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                     GHC.Types.Symbol) (CNonCanonical)
                                  [G] cobox_acDj {0}:: (Unpack
                                                          ((Base "kg" *: Base "m")
                                                           /: (Base "s"
                                                               *: Base
                                                                    "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (('["kg", "m"]
                                                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                     GHC.Types.Symbol) (CNonCanonical)
                         Non-eqs = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDh {0}:: (Unpack
                                        (Base "kg") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (('["kg"]
                                       'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                GHC.Types.Symbol) (CNonCanonical)
canonicalize (non-canonical)
  [G] cobox_acDh {0}:: (Unpack
                          (Base "kg") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                           GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["kg"]
                         'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol) (CNonCanonical)
canEvNC:eq
  Unpack (Base "kg")
  '["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
can_eq_nc
  False
  [G] cobox_acDh {0}:: (Unpack
                          (Base "kg") :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                           GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["kg"]
                         'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
  nominal equality
  Unpack (Base "kg")
  Unpack (Base "kg")
  '["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
  '["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
flatten { FM_FlattenAll Unpack (Base "kg")
matchFamTcM
  Matching: Unpack (Base "kg")
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
addTcEvBind
  acC4
  [G] cobox_acDl = CO <Base "kg">_N
extendFlatCache
  Base ["kg"]
  [G]
  fsk0_acDk[fsk]
flatten/flat-cache miss
  Base ["kg"]
  fsk_acDk[fsk]
  [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                       GHC.Prim.~#
                       (fsk0_acDk[fsk] :: Unit)
matchFamTcM
  Matching: Unpack fsk0_acDk[fsk]
  Match failed
addTcEvBind
  acC4
  [G] cobox_acDn = CO <Unpack fsk0_acDk[fsk]>_N
extendFlatCache
  Unpack [fsk0_acDk[fsk]]
  [G]
  fsk0_acDm[fsk]
flatten/flat-cache miss
  Unpack [fsk0_acDk[fsk]]
  fsk_acDm[fsk]
  [G] cobox_acDn {0}:: (Unpack
                          fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                       GHC.Prim.~#
                       (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol)
flatten } fsk0_acDm[fsk]
flatten { FM_FlattenAll '["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
flatten } '["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (('["kg"]
                                       'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                GHC.Types.Symbol) (CTyEqCan)
Can't solve tyvar equality
  LHS: fsk_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                          GHC.Types.Symbol
  RHS: '["kg"]
       'Data.UnitsOfMeasure.Syntax.:/ '[] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                               GHC.Types.Symbol
addInertEq {
  Adding new inert equality: [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                       GHC.Types.Symbol)
                                                  GHC.Prim.~#
                                                  (('["kg"]
                                                    'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                             GHC.Types.Symbol) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 65[l:1,d:0] Kept as inert:
    [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                         GHC.Prim.~#
                         (('["kg"]
                           'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                    GHC.Types.Symbol)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                   GHC.Prim.~#
                                   (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
  inerts = {Equalities: [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Funeqs = [G] cobox_acDn {0}:: (Unpack
                                                          fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CFunEqCan)
                                  [G] cobox_acDi {0}:: (Unpack
                                                          (Base "m"
                                                           /: (Base "s"
                                                               *: Base
                                                                    "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (('["m"]
                                                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                     GHC.Types.Symbol) (CNonCanonical)
                                  [G] cobox_acDj {0}:: (Unpack
                                                          ((Base "kg" *: Base "m")
                                                           /: (Base "s"
                                                               *: Base
                                                                    "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (('["kg", "m"]
                                                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                     GHC.Types.Symbol) (CNonCanonical)
                         Non-eqs = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                     GHC.Prim.~#
                                     (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
flatten_many { "kg"
flatten } "kg"
extendFlatCache
  Base ["kg"]
  [G]
  fsk0_acDk[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                     GHC.Prim.~#
                                     (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                     GHC.Prim.~#
                                     (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
doTopReact
  [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                       GHC.Prim.~#
                       (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "kg"
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_acDl {0}:: (Base
                                                                  "kg" :: Unit)
                                                               GHC.Prim.~#
                                                               (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
addInertCan }
Step 66[l:1,d:0] Kept as inert:
    [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                         GHC.Prim.~#
                         (fsk0_acDk[fsk] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                    GHC.Prim.~#
                                    (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDn {0}:: (Unpack
                                      fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                        GHC.Types.Symbol) (CFunEqCan)
  inerts = {Equalities: [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Funeqs = [G] cobox_acDi {0}:: (Unpack
                                                          (Base "m"
                                                           /: (Base "s"
                                                               *: Base
                                                                    "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (('["m"]
                                                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                     GHC.Types.Symbol) (CNonCanonical)
                                  [G] cobox_acDj {0}:: (Unpack
                                                          ((Base "kg" *: Base "m")
                                                           /: (Base "s"
                                                               *: Base
                                                                    "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (('["kg", "m"]
                                                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                     GHC.Types.Symbol) (CNonCanonical)
                         Non-eqs = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDn {0}:: (Unpack
                                        fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
flatten_many { fsk0_acDk[fsk]
Unfilled tyvar fsk_acDk[fsk]
flatten } fsk0_acDk[fsk]
extendFlatCache
  Unpack [fsk0_acDk[fsk]]
  [G]
  fsk0_acDm[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDn {0}:: (Unpack
                                        fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_acDn {0}:: (Unpack
                                        fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
doTopReact
  [G] cobox_acDn {0}:: (Unpack
                          fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                       GHC.Prim.~#
                       (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol) (CFunEqCan)
matchFamTcM
  Matching: Unpack fsk0_acDk[fsk]
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_acDn {0}:: (Unpack
                                                                  fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                      GHC.Types.Symbol)
                                                               GHC.Prim.~#
                                                               (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol) (CFunEqCan)
addInertCan }
Step 67[l:1,d:0] Kept as inert:
    [G] cobox_acDn {0}:: (Unpack
                            fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                GHC.Types.Symbol)
                         GHC.Prim.~#
                         (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_acDn {0}:: (Unpack
                                       fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                                    GHC.Prim.~#
                                    (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDi {0}:: (Unpack
                                      (Base "m"
                                       /: (Base "s"
                                           *: Base "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                              GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (('["m"]
                                     'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                      "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Funeqs = [G] cobox_acDj {0}:: (Unpack
                                                          ((Base "kg" *: Base "m")
                                                           /: (Base "s"
                                                               *: Base
                                                                    "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (('["kg", "m"]
                                                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                     GHC.Types.Symbol) (CNonCanonical)
                         Non-eqs = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDi {0}:: (Unpack
                                        (Base "m"
                                         /: (Base "s"
                                             *: Base "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (('["m"]
                                       'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                        "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol) (CNonCanonical)
canonicalize (non-canonical)
  [G] cobox_acDi {0}:: (Unpack
                          (Base "m"
                           /: (Base "s" *: Base "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["m"]
                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                     GHC.Types.Symbol) (CNonCanonical)
canEvNC:eq
  Unpack (Base "m" /: (Base "s" *: Base "s"))
  '["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
can_eq_nc
  False
  [G] cobox_acDi {0}:: (Unpack
                          (Base "m"
                           /: (Base "s" *: Base "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["m"]
                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                     GHC.Types.Symbol)
  nominal equality
  Unpack (Base "m" /: (Base "s" *: Base "s"))
  Unpack (Base "m" /: (Base "s" *: Base "s"))
  '["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
  '["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
flatten { FM_FlattenAll Unpack (Base "m" /: (Base "s" *: Base "s"))
matchFamTcM
  Matching: Unpack (Base "m" /: (Base "s" *: Base "s"))
  Match failed
matchFamTcM
  Matching: Base "m" /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
addTcEvBind
  acC4
  [G] cobox_acDp = CO <Base "m">_N
extendFlatCache
  Base ["m"]
  [G]
  fsk0_acDo[fsk]
flatten/flat-cache miss
  Base ["m"]
  fsk_acDo[fsk]
  [G] cobox_acDp {0}:: (Base "m" :: Unit)
                       GHC.Prim.~#
                       (fsk0_acDo[fsk] :: Unit)
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
addTcEvBind
  acC4
  [G] cobox_acDr = CO <Base "s">_N
extendFlatCache
  Base ["s"]
  [G]
  fsk0_acDq[fsk]
flatten/flat-cache miss
  Base ["s"]
  fsk_acDq[fsk]
  [G] cobox_acDr {0}:: (Base "s" :: Unit)
                       GHC.Prim.~#
                       (fsk0_acDq[fsk] :: Unit)
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
matchFamTcM
  Matching: fsk0_acDq[fsk] *: fsk0_acDq[fsk]
  Match failed
addTcEvBind
  acC4
  [G] cobox_acDt = CO <fsk0_acDq[fsk] *: fsk0_acDq[fsk]>_N
extendFlatCache
  *: [fsk0_acDq[fsk], fsk0_acDq[fsk]]
  [G]
  fsk0_acDs[fsk]
flatten/flat-cache miss
  *: [fsk0_acDq[fsk], fsk0_acDq[fsk]]
  fsk_acDs[fsk]
  [G] cobox_acDt {0}:: ((fsk0_acDq[fsk] *: fsk0_acDq[fsk]) :: Unit)
                       GHC.Prim.~#
                       (fsk1_acDs[fsk] :: Unit)
matchFamTcM
  Matching: fsk0_acDo[fsk] /: fsk1_acDs[fsk]
  Match failed
addTcEvBind
  acC4
  [G] cobox_acDv = CO <fsk0_acDo[fsk] /: fsk1_acDs[fsk]>_N
extendFlatCache
  /: [fsk0_acDo[fsk], fsk0_acDs[fsk]]
  [G]
  fsk0_acDu[fsk]
flatten/flat-cache miss
  /: [fsk0_acDo[fsk], fsk0_acDs[fsk]]
  fsk_acDu[fsk]
  [G] cobox_acDv {0}:: ((fsk0_acDo[fsk] /: fsk1_acDs[fsk]) :: Unit)
                       GHC.Prim.~#
                       (fsk2_acDu[fsk] :: Unit)
matchFamTcM
  Matching: Unpack fsk0_acDu[fsk]
  Match failed
addTcEvBind
  acC4
  [G] cobox_acDx = CO <Unpack fsk0_acDu[fsk]>_N
extendFlatCache
  Unpack [fsk0_acDu[fsk]]
  [G]
  fsk0_acDw[fsk]
flatten/flat-cache miss
  Unpack [fsk0_acDu[fsk]]
  fsk_acDw[fsk]
  [G] cobox_acDx {0}:: (Unpack
                          fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                       GHC.Prim.~#
                       (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol)
flatten } fsk0_acDw[fsk]
flatten {
  FM_FlattenAll '["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
flatten } '["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (('["m"]
                                       'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                        "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol) (CTyEqCan)
Can't solve tyvar equality
  LHS: fsk_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                          GHC.Types.Symbol
  RHS: '["m"]
       'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                        "s"] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                  GHC.Types.Symbol
addInertEq {
  Adding new inert equality: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                       GHC.Types.Symbol)
                                                  GHC.Prim.~#
                                                  (('["m"]
                                                    'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                     "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                GHC.Types.Symbol) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 68[l:1,d:0] Kept as inert:
    [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                         GHC.Prim.~#
                         (('["m"]
                           'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                            "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                       GHC.Types.Symbol)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                   GHC.Prim.~#
                                   (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
  inerts = {Equalities: [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Funeqs = [G] cobox_acDr {0}:: (Base
                                                          "s" :: Unit)
                                                       GHC.Prim.~#
                                                       (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                  [G] cobox_acDt {0}:: ((fsk0_acDq[fsk] *: fsk0_acDq[fsk]) :: Unit)
                                                       GHC.Prim.~#
                                                       (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                  [G] cobox_acDv {0}:: ((fsk0_acDo[fsk] /: fsk1_acDs[fsk]) :: Unit)
                                                       GHC.Prim.~#
                                                       (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                  [G] cobox_acDx {0}:: (Unpack
                                                          fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CFunEqCan)
                                  [G] cobox_acDj {0}:: (Unpack
                                                          ((Base "kg" *: Base "m")
                                                           /: (Base "s"
                                                               *: Base
                                                                    "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (('["kg", "m"]
                                                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                     GHC.Types.Symbol) (CNonCanonical)
                         Non-eqs = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                     GHC.Prim.~#
                                     (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
flatten_many { "m"
flatten } "m"
extendFlatCache
  Base ["m"]
  [G]
  fsk0_acDo[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                     GHC.Prim.~#
                                     (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                     GHC.Prim.~#
                                     (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
doTopReact
  [G] cobox_acDp {0}:: (Base "m" :: Unit)
                       GHC.Prim.~#
                       (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "m"
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_acDp {0}:: (Base
                                                                  "m" :: Unit)
                                                               GHC.Prim.~#
                                                               (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
addInertCan }
Step 69[l:1,d:0] Kept as inert:
    [G] cobox_acDp {0}:: (Base "m" :: Unit)
                         GHC.Prim.~#
                         (fsk0_acDo[fsk] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                    GHC.Prim.~#
                                    (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                   GHC.Prim.~#
                                   (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
  inerts = {Equalities: [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Funeqs = [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                         *: fsk0_acDq[fsk]) :: Unit)
                                                       GHC.Prim.~#
                                                       (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                  [G] cobox_acDv {0}:: ((fsk0_acDo[fsk] /: fsk1_acDs[fsk]) :: Unit)
                                                       GHC.Prim.~#
                                                       (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                  [G] cobox_acDx {0}:: (Unpack
                                                          fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CFunEqCan)
                                  [G] cobox_acDj {0}:: (Unpack
                                                          ((Base "kg" *: Base "m")
                                                           /: (Base "s"
                                                               *: Base
                                                                    "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (('["kg", "m"]
                                                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                     GHC.Types.Symbol) (CNonCanonical)
                         Non-eqs = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                     GHC.Prim.~#
                                     (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
flatten_many { "s"
flatten } "s"
extendFlatCache
  Base ["s"]
  [G]
  fsk0_acDq[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                     GHC.Prim.~#
                                     (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                     GHC.Prim.~#
                                     (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
doTopReact
  [G] cobox_acDr {0}:: (Base "s" :: Unit)
                       GHC.Prim.~#
                       (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "s"
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_acDr {0}:: (Base
                                                                  "s" :: Unit)
                                                               GHC.Prim.~#
                                                               (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
addInertCan }
Step 70[l:1,d:0] Kept as inert:
    [G] cobox_acDr {0}:: (Base "s" :: Unit)
                         GHC.Prim.~#
                         (fsk0_acDq[fsk] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                    GHC.Prim.~#
                                    (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                     *: fsk0_acDq[fsk]) :: Unit)
                                   GHC.Prim.~#
                                   (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
  inerts = {Equalities: [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Funeqs = [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                         /: fsk1_acDs[fsk]) :: Unit)
                                                       GHC.Prim.~#
                                                       (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                  [G] cobox_acDx {0}:: (Unpack
                                                          fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CFunEqCan)
                                  [G] cobox_acDj {0}:: (Unpack
                                                          ((Base "kg" *: Base "m")
                                                           /: (Base "s"
                                                               *: Base
                                                                    "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (('["kg", "m"]
                                                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                     GHC.Types.Symbol) (CNonCanonical)
                         Non-eqs = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                       *: fsk0_acDq[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
flatten_many {
  fsk0_acDq[fsk]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
flatten }
  fsk0_acDq[fsk]
  fsk0_acDq[fsk]
extendFlatCache
  *: [fsk0_acDq[fsk], fsk0_acDq[fsk]]
  [G]
  fsk0_acDs[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                       *: fsk0_acDq[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                       *: fsk0_acDq[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
doTopReact
  [G] cobox_acDt {0}:: ((fsk0_acDq[fsk] *: fsk0_acDq[fsk]) :: Unit)
                       GHC.Prim.~#
                       (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: fsk0_acDq[fsk] *: fsk0_acDq[fsk]
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                                 *: fsk0_acDq[fsk]) :: Unit)
                                                               GHC.Prim.~#
                                                               (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
addInertCan }
Step 71[l:1,d:0] Kept as inert:
    [G] cobox_acDt {0}:: ((fsk0_acDq[fsk] *: fsk0_acDq[fsk]) :: Unit)
                         GHC.Prim.~#
                         (fsk1_acDs[fsk] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                      *: fsk0_acDq[fsk]) :: Unit)
                                    GHC.Prim.~#
                                    (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                     /: fsk1_acDs[fsk]) :: Unit)
                                   GHC.Prim.~#
                                   (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
  inerts = {Equalities: [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Funeqs = [G] cobox_acDx {0}:: (Unpack
                                                          fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CFunEqCan)
                                  [G] cobox_acDj {0}:: (Unpack
                                                          ((Base "kg" *: Base "m")
                                                           /: (Base "s"
                                                               *: Base
                                                                    "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (('["kg", "m"]
                                                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                     GHC.Types.Symbol) (CNonCanonical)
                         Non-eqs = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                       /: fsk1_acDs[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
flatten_many {
  fsk0_acDo[fsk]
  fsk0_acDs[fsk]
Unfilled tyvar fsk_acDo[fsk]
Unfilled tyvar fsk_acDs[fsk]
flatten }
  fsk0_acDo[fsk]
  fsk0_acDs[fsk]
extendFlatCache
  /: [fsk0_acDo[fsk], fsk0_acDs[fsk]]
  [G]
  fsk0_acDu[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                       /: fsk1_acDs[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                       /: fsk1_acDs[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
doTopReact
  [G] cobox_acDv {0}:: ((fsk0_acDo[fsk] /: fsk1_acDs[fsk]) :: Unit)
                       GHC.Prim.~#
                       (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: fsk0_acDo[fsk] /: fsk1_acDs[fsk]
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                                 /: fsk1_acDs[fsk]) :: Unit)
                                                               GHC.Prim.~#
                                                               (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
addInertCan }
Step 72[l:1,d:0] Kept as inert:
    [G] cobox_acDv {0}:: ((fsk0_acDo[fsk] /: fsk1_acDs[fsk]) :: Unit)
                         GHC.Prim.~#
                         (fsk2_acDu[fsk] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                      /: fsk1_acDs[fsk]) :: Unit)
                                    GHC.Prim.~#
                                    (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDx {0}:: (Unpack
                                      fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                        GHC.Types.Symbol) (CFunEqCan)
  inerts = {Equalities: [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Funeqs = [G] cobox_acDj {0}:: (Unpack
                                                          ((Base "kg" *: Base "m")
                                                           /: (Base "s"
                                                               *: Base
                                                                    "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                               GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (('["kg", "m"]
                                                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                     GHC.Types.Symbol) (CNonCanonical)
                         Non-eqs = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDx {0}:: (Unpack
                                        fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
flatten_many { fsk0_acDu[fsk]
Unfilled tyvar fsk_acDu[fsk]
flatten } fsk0_acDu[fsk]
extendFlatCache
  Unpack [fsk0_acDu[fsk]]
  [G]
  fsk0_acDw[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDx {0}:: (Unpack
                                        fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_acDx {0}:: (Unpack
                                        fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
doTopReact
  [G] cobox_acDx {0}:: (Unpack
                          fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                       GHC.Prim.~#
                       (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol) (CFunEqCan)
matchFamTcM
  Matching: Unpack fsk0_acDu[fsk]
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_acDx {0}:: (Unpack
                                                                  fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                      GHC.Types.Symbol)
                                                               GHC.Prim.~#
                                                               (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol) (CFunEqCan)
addInertCan }
Step 73[l:1,d:0] Kept as inert:
    [G] cobox_acDx {0}:: (Unpack
                            fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                GHC.Types.Symbol)
                         GHC.Prim.~#
                         (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_acDx {0}:: (Unpack
                                       fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                                    GHC.Prim.~#
                                    (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDj {0}:: (Unpack
                                      ((Base "kg" *: Base "m")
                                       /: (Base "s"
                                           *: Base "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                              GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (('["kg", "m"]
                                     'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                      "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] irred_acCH {0}:: ((Base "kg"
                                                           *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDj {0}:: (Unpack
                                        ((Base "kg" *: Base "m")
                                         /: (Base "s"
                                             *: Base "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (('["kg", "m"]
                                       'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                        "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol) (CNonCanonical)
canonicalize (non-canonical)
  [G] cobox_acDj {0}:: (Unpack
                          ((Base "kg" *: Base "m")
                           /: (Base "s" *: Base "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["kg", "m"]
                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                     GHC.Types.Symbol) (CNonCanonical)
canEvNC:eq
  Unpack ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  '["kg", "m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
can_eq_nc
  False
  [G] cobox_acDj {0}:: (Unpack
                          ((Base "kg" *: Base "m")
                           /: (Base "s" *: Base "s")) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["kg", "m"]
                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                     GHC.Types.Symbol)
  nominal equality
  Unpack ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Unpack ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  '["kg", "m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
  '["kg", "m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
flatten {
  FM_FlattenAll Unpack
                  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
matchFamTcM
  Matching: Unpack
              ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Match failed
matchFamTcM
  Matching: (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "kg" *: Base "m"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  fsk0_acDk[fsk]
Unfilled tyvar fsk_acDk[fsk]
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  fsk0_acDo[fsk]
Unfilled tyvar fsk_acDo[fsk]
matchFamTcM
  Matching: fsk0_acDk[fsk] *: fsk1_acDo[fsk]
  Match failed
addTcEvBind
  acC4
  [G] cobox_acDz = CO <fsk0_acDk[fsk] *: fsk1_acDo[fsk]>_N
extendFlatCache
  *: [fsk0_acDk[fsk], fsk0_acDo[fsk]]
  [G]
  fsk0_acDy[fsk]
flatten/flat-cache miss
  *: [fsk0_acDk[fsk], fsk0_acDo[fsk]]
  fsk_acDy[fsk]
  [G] cobox_acDz {0}:: ((fsk0_acDk[fsk] *: fsk1_acDo[fsk]) :: Unit)
                       GHC.Prim.~#
                       (fsk2_acDy[fsk] :: Unit)
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
flatten/flat-cache hit
  *: [fsk0_acDq[fsk], fsk0_acDq[fsk]]
  fsk0_acDs[fsk]
Unfilled tyvar fsk_acDs[fsk]
matchFamTcM
  Matching: fsk0_acDy[fsk] /: fsk1_acDs[fsk]
  Match failed
addTcEvBind
  acC4
  [G] cobox_acDB = CO <fsk0_acDy[fsk] /: fsk1_acDs[fsk]>_N
extendFlatCache
  /: [fsk0_acDy[fsk], fsk0_acDs[fsk]]
  [G]
  fsk0_acDA[fsk]
flatten/flat-cache miss
  /: [fsk0_acDy[fsk], fsk0_acDs[fsk]]
  fsk_acDA[fsk]
  [G] cobox_acDB {0}:: ((fsk0_acDy[fsk] /: fsk1_acDs[fsk]) :: Unit)
                       GHC.Prim.~#
                       (fsk2_acDA[fsk] :: Unit)
matchFamTcM
  Matching: Unpack fsk0_acDA[fsk]
  Match failed
addTcEvBind
  acC4
  [G] cobox_acDD = CO <Unpack fsk0_acDA[fsk]>_N
extendFlatCache
  Unpack [fsk0_acDA[fsk]]
  [G]
  fsk0_acDC[fsk]
flatten/flat-cache miss
  Unpack [fsk0_acDA[fsk]]
  fsk_acDC[fsk]
  [G] cobox_acDD {0}:: (Unpack
                          fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                       GHC.Prim.~#
                       (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol)
flatten } fsk0_acDC[fsk]
flatten {
  FM_FlattenAll '["kg", "m"]
                'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
flatten } '["kg", "m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
addTcEvBind
  acC4
  [G] cobox_acDE
    = CO (Unpack
            ((Sym cobox *: Sym cobox)_N
             /: Trans (Sym cobox) (Sym cobox *: Sym cobox)_N)_N)_N
         ; cobox_acDj
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (('["kg", "m"]
                                       'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                        "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol) (CTyEqCan)
Can't solve tyvar equality
  LHS: fsk_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                          GHC.Types.Symbol
  RHS: '["kg", "m"]
       'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                        "s"] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                  GHC.Types.Symbol
addInertEq {
  Adding new inert equality: [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                       GHC.Types.Symbol)
                                                  GHC.Prim.~#
                                                  (('["kg", "m"]
                                                    'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                     "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                                GHC.Types.Symbol) (CTyEqCan)
addInertEq }
end stage interact with inerts }
Step 74[l:1,d:1] Kept as inert:
    [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                         GHC.Prim.~#
                         (('["kg", "m"]
                           'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                            "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                       GHC.Types.Symbol)
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                     *: fsk1_acDo[fsk]) :: Unit)
                                   GHC.Prim.~#
                                   (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Funeqs = [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                         /: fsk1_acDs[fsk]) :: Unit)
                                                       GHC.Prim.~#
                                                       (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                  [G] cobox_acDD {0}:: (Unpack
                                                          fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CFunEqCan)
                         Non-eqs = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                       *: fsk1_acDo[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
flatten_many {
  fsk0_acDk[fsk]
  fsk0_acDo[fsk]
Unfilled tyvar fsk_acDk[fsk]
Unfilled tyvar fsk_acDo[fsk]
flatten }
  fsk0_acDk[fsk]
  fsk0_acDo[fsk]
extendFlatCache
  *: [fsk0_acDk[fsk], fsk0_acDo[fsk]]
  [G]
  fsk0_acDy[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                       *: fsk1_acDo[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                       *: fsk1_acDo[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
doTopReact
  [G] cobox_acDz {0}:: ((fsk0_acDk[fsk] *: fsk1_acDo[fsk]) :: Unit)
                       GHC.Prim.~#
                       (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: fsk0_acDk[fsk] *: fsk1_acDo[fsk]
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                                 *: fsk1_acDo[fsk]) :: Unit)
                                                               GHC.Prim.~#
                                                               (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
addInertCan }
Step 75[l:1,d:0] Kept as inert:
    [G] cobox_acDz {0}:: ((fsk0_acDk[fsk] *: fsk1_acDo[fsk]) :: Unit)
                         GHC.Prim.~#
                         (fsk2_acDy[fsk] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                      *: fsk1_acDo[fsk]) :: Unit)
                                    GHC.Prim.~#
                                    (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                     /: fsk1_acDs[fsk]) :: Unit)
                                   GHC.Prim.~#
                                   (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Funeqs = [G] cobox_acDD {0}:: (Unpack
                                                          fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                              GHC.Types.Symbol)
                                                       GHC.Prim.~#
                                                       (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                            GHC.Types.Symbol) (CFunEqCan)
                         Non-eqs = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                       /: fsk1_acDs[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
flatten_many {
  fsk0_acDy[fsk]
  fsk0_acDs[fsk]
Unfilled tyvar fsk_acDy[fsk]
Unfilled tyvar fsk_acDs[fsk]
flatten }
  fsk0_acDy[fsk]
  fsk0_acDs[fsk]
extendFlatCache
  /: [fsk0_acDy[fsk], fsk0_acDs[fsk]]
  [G]
  fsk0_acDA[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                       /: fsk1_acDs[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                       /: fsk1_acDs[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
doTopReact
  [G] cobox_acDB {0}:: ((fsk0_acDy[fsk] /: fsk1_acDs[fsk]) :: Unit)
                       GHC.Prim.~#
                       (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: fsk0_acDy[fsk] /: fsk1_acDs[fsk]
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                                 /: fsk1_acDs[fsk]) :: Unit)
                                                               GHC.Prim.~#
                                                               (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
addInertCan }
Step 76[l:1,d:0] Kept as inert:
    [G] cobox_acDB {0}:: ((fsk0_acDy[fsk] /: fsk1_acDs[fsk]) :: Unit)
                         GHC.Prim.~#
                         (fsk2_acDA[fsk] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                      /: fsk1_acDs[fsk]) :: Unit)
                                    GHC.Prim.~#
                                    (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [G] cobox_acDD {0}:: (Unpack
                                      fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol)
                                   GHC.Prim.~#
                                   (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                        GHC.Types.Symbol) (CFunEqCan)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] irred_acCH {0}:: ((Base "kg"
                                                           *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [G] cobox_acDD {0}:: (Unpack
                                        fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
flatten_many { fsk0_acDA[fsk]
Unfilled tyvar fsk_acDA[fsk]
flatten } fsk0_acDA[fsk]
extendFlatCache
  Unpack [fsk0_acDA[fsk]]
  [G]
  fsk0_acDC[fsk]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] cobox_acDD {0}:: (Unpack
                                        fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] cobox_acDD {0}:: (Unpack
                                        fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                            GHC.Types.Symbol)
                                     GHC.Prim.~#
                                     (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                          GHC.Types.Symbol) (CFunEqCan)
doTopReact
  [G] cobox_acDD {0}:: (Unpack
                          fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
                       GHC.Prim.~#
                       (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol) (CFunEqCan)
matchFamTcM
  Matching: Unpack fsk0_acDA[fsk]
  Match failed
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [G] cobox_acDD {0}:: (Unpack
                                                                  fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                      GHC.Types.Symbol)
                                                               GHC.Prim.~#
                                                               (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                    GHC.Types.Symbol) (CFunEqCan)
addInertCan }
Step 77[l:1,d:0] Kept as inert:
    [G] cobox_acDD {0}:: (Unpack
                            fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                GHC.Types.Symbol)
                         GHC.Prim.~#
                         (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                              GHC.Types.Symbol)
End solver pipeline (kept as inert) }
  final_item = [G] cobox_acDD {0}:: (Unpack
                                       fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                           GHC.Types.Symbol)
                                    GHC.Prim.~#
                                    (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                         GHC.Types.Symbol) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                     /: (Base "s" *: Base "s"))
                                    Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                    /: (Base "s" *: Base "s"))
                                                                   *: Base "kg") (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] irred_acCH {0}:: ((Base "kg"
                                                           *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                       /: (Base "s" *: Base "s"))
                                      Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                      /: (Base "s" *: Base "s"))
                                                                     *: Base "kg") (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                         /: (Base "s" *: Base "s"))
                        Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                       *: Base "kg") (CNonCanonical)
canEvNC:irred
  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                 *: Base "kg")
can_pred
  IrredPred =  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
               Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                              *: Base "kg")
flatten {
  FM_FlattenAll ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                               *: Base "kg")
matchFamTcM
  Matching: ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
            Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                           *: Base "kg")
  Match failed
matchFamTcM
  Matching: (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "kg" *: Base "m"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  fsk0_acDk[fsk]
Unfilled tyvar fsk_acDk[fsk]
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  fsk0_acDo[fsk]
Unfilled tyvar fsk_acDo[fsk]
flatten/flat-cache hit
  *: [fsk0_acDk[fsk], fsk0_acDo[fsk]]
  fsk0_acDy[fsk]
Unfilled tyvar fsk_acDy[fsk]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
flatten/flat-cache hit
  *: [fsk0_acDq[fsk], fsk0_acDq[fsk]]
  fsk0_acDs[fsk]
Unfilled tyvar fsk_acDs[fsk]
flatten/flat-cache hit
  /: [fsk0_acDy[fsk], fsk0_acDs[fsk]]
  fsk0_acDA[fsk]
Unfilled tyvar fsk_acDA[fsk]
matchFamTcM
  Matching: (Base "m" /: (Base "s" *: Base "s")) *: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "m" /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  fsk0_acDo[fsk]
Unfilled tyvar fsk_acDo[fsk]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
flatten/flat-cache hit
  *: [fsk0_acDq[fsk], fsk0_acDq[fsk]]
  fsk0_acDs[fsk]
Unfilled tyvar fsk_acDs[fsk]
flatten/flat-cache hit
  /: [fsk0_acDo[fsk], fsk0_acDs[fsk]]
  fsk0_acDu[fsk]
Unfilled tyvar fsk_acDu[fsk]
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  fsk0_acDk[fsk]
Unfilled tyvar fsk_acDk[fsk]
matchFamTcM
  Matching: fsk0_acDu[fsk] *: fsk1_acDk[fsk]
  Match failed
New coercion hole: acDG
Emitting new coercion hole
  {acDG} :: ((fsk0_acDu[fsk] *: fsk1_acDk[fsk]) :: Unit)
            GHC.Prim.~#
            (s0_acDF[fuv:0] :: Unit)
extendFlatCache
  *: [fsk0_acDu[fsk], fsk0_acDk[fsk]]
  [WD]
  s0_acDF[fuv:0]
flatten/flat-cache miss
  *: [fsk0_acDu[fsk], fsk0_acDk[fsk]]
  s_acDF[fuv:0]
  [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk] *: fsk1_acDk[fsk]) :: Unit)
                        GHC.Prim.~#
                        (s0_acDF[fuv:0] :: Unit)
matchFamTcM
  Matching: fsk0_acDA[fsk]
            Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]
  Match failed
New coercion hole: acDI
Emitting new coercion hole
  {acDI} :: ((fsk0_acDA[fsk]
              Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
            GHC.Prim.~#
            (s1_acDH[fuv:0] :: Constraint)
extendFlatCache
  Data.UnitsOfMeasure.Syntax.~~ [fsk0_acDA[fsk], s0_acDF[fuv:0]]
  [WD]
  s0_acDH[fuv:0]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Syntax.~~ [fsk0_acDA[fsk], s0_acDF[fuv:0]]
  s_acDH[fuv:0]
  [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                          Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                        GHC.Prim.~#
                        (s1_acDH[fuv:0] :: Constraint)
flatten } s0_acDH[fuv:0]
Emitting new wanted
  irred_acDJ :: s0_acDH[fuv:0]
  arising from a use of ‘*:’ at test-suite-force/Tests.hs:49:17-40
addTcEvBind
  acC4
  [W] irred_acCH
    = irred_acDJ `cast` (Sub
                           (Sym
                              U(hole:{acDI}, fsk0_acDA[fsk]
                                             Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0], s0_acDH[fuv:0])_N
                            ; (Trans
                                   (Sym cobox)
                                   (Trans (Sym cobox) (Sym cobox *: Sym cobox)_N
                                    /: Trans (Sym cobox) (Sym cobox *: Sym cobox)_N)_N
                               Data.UnitsOfMeasure.Syntax.~~ Trans
                                                                 (Sym {acDG})
                                                                 (Trans
                                                                      (Sym cobox)
                                                                      (Sym cobox
                                                                       /: Trans
                                                                              (Sym cobox)
                                                                              (Sym cobox
                                                                               *: Sym cobox)_N)_N
                                                                  *: Sym cobox)_N)_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
doTopReact [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
addInertCan }
Step 78[l:1,d:0] Kept as inert:
    [WD] irred_acDJ {0}:: s0_acDH[fuv:0]
End solver pipeline (kept as inert) }
  final_item = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                      *: fsk1_acDk[fsk]) :: Unit)
                                    GHC.Prim.~#
                                    (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Funeqs = [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                          Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                        *: fsk1_acDk[fsk]) :: Unit)
                                      GHC.Prim.~#
                                      (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  fsk0_acDu[fsk]
  fsk0_acDk[fsk]
Unfilled tyvar fsk_acDu[fsk]
Unfilled tyvar fsk_acDk[fsk]
flatten }
  fsk0_acDu[fsk]
  fsk0_acDk[fsk]
extendFlatCache
  *: [fsk0_acDu[fsk], fsk0_acDk[fsk]]
  [WD]
  s0_acDF[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                        *: fsk1_acDk[fsk]) :: Unit)
                                      GHC.Prim.~#
                                      (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                        *: fsk1_acDk[fsk]) :: Unit)
                                      GHC.Prim.~#
                                      (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk] *: fsk1_acDk[fsk]) :: Unit)
                        GHC.Prim.~#
                        (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: fsk0_acDu[fsk] *: fsk1_acDk[fsk]
  Match failed
improveTopFunEqs
  *: [fsk0_acDu[fsk], fsk0_acDk[fsk]] s_acDF[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                                  *: fsk1_acDk[fsk]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 79[l:1,d:0] Kept as inert:
    [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk] *: fsk1_acDk[fsk]) :: Unit)
                          GHC.Prim.~#
                          (s0_acDF[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                       *: fsk1_acDk[fsk]) :: Unit)
                                     GHC.Prim.~#
                                     (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                      Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                    GHC.Prim.~#
                                    (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] irred_acCH {0}:: ((Base "kg"
                                                           *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                        Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
flatten_many {
  fsk0_acDA[fsk]
  s0_acDF[fuv:0]
Unfilled tyvar fsk_acDA[fsk]
Unfilled tyvar s_acDF[fuv:0]
flatten }
  fsk0_acDA[fsk]
  s0_acDF[fuv:0]
extendFlatCache
  Data.UnitsOfMeasure.Syntax.~~ [fsk0_acDA[fsk], s0_acDF[fuv:0]]
  [WD]
  s0_acDH[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                        Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                        Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
doTopReact
  [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                          Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                        GHC.Prim.~#
                        (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
matchFamTcM
  Matching: fsk0_acDA[fsk]
            Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]
  Match failed
improveTopFunEqs
  Data.UnitsOfMeasure.Syntax.~~ [fsk0_acDA[fsk],
                                 s0_acDF[fuv:0]] s_acDH[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                                  Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                                GHC.Prim.~#
                                                                (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
addInertCan }
Step 80[l:1,d:0] Kept as inert:
    [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                            Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                          GHC.Prim.~#
                          (s1_acDH[fuv:0] :: Constraint)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                       Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                     GHC.Prim.~#
                                     (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                     /: (Base "s" *: Base "s"))
                                    Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                    /: (Base "s" *: Base "s"))
                                                                   *: Base "kg") (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
                                   [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                                       /: (Base "s" *: Base "s"))
                                      Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                      /: (Base "s" *: Base "s"))
                                                                     *: Base "kg") (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_acCH {0}:: ((Base "kg" *: Base "m")
                         /: (Base "s" *: Base "s"))
                        Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                       *: Base "kg") (CNonCanonical)
canEvNC:irred
  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                 *: Base "kg")
can_pred
  IrredPred =  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
               Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                              *: Base "kg")
flatten {
  FM_FlattenAll ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                               *: Base "kg")
matchFamTcM
  Matching: ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
            Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                           *: Base "kg")
  Match failed
matchFamTcM
  Matching: (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "kg" *: Base "m"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  fsk0_acDk[fsk]
Unfilled tyvar fsk_acDk[fsk]
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  fsk0_acDo[fsk]
Unfilled tyvar fsk_acDo[fsk]
flatten/flat-cache hit
  *: [fsk0_acDk[fsk], fsk0_acDo[fsk]]
  fsk0_acDy[fsk]
Unfilled tyvar fsk_acDy[fsk]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
flatten/flat-cache hit
  *: [fsk0_acDq[fsk], fsk0_acDq[fsk]]
  fsk0_acDs[fsk]
Unfilled tyvar fsk_acDs[fsk]
flatten/flat-cache hit
  /: [fsk0_acDy[fsk], fsk0_acDs[fsk]]
  fsk0_acDA[fsk]
Unfilled tyvar fsk_acDA[fsk]
matchFamTcM
  Matching: (Base "m" /: (Base "s" *: Base "s")) *: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "m" /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  fsk0_acDo[fsk]
Unfilled tyvar fsk_acDo[fsk]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
flatten/flat-cache hit
  *: [fsk0_acDq[fsk], fsk0_acDq[fsk]]
  fsk0_acDs[fsk]
Unfilled tyvar fsk_acDs[fsk]
flatten/flat-cache hit
  /: [fsk0_acDo[fsk], fsk0_acDs[fsk]]
  fsk0_acDu[fsk]
Unfilled tyvar fsk_acDu[fsk]
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  fsk0_acDk[fsk]
Unfilled tyvar fsk_acDk[fsk]
flatten/flat-cache hit
  *: [fsk0_acDu[fsk], fsk0_acDk[fsk]]
  s0_acDF[fuv:0]
Unfilled tyvar s_acDF[fuv:0]
flatten/flat-cache hit
  Data.UnitsOfMeasure.Syntax.~~ [fsk0_acDA[fsk], s0_acDF[fuv:0]]
  s0_acDH[fuv:0]
Unfilled tyvar s_acDH[fuv:0]
flatten } s0_acDH[fuv:0]
Emitting new wanted
  irred_acDK :: s0_acDH[fuv:0]
  arising from a use of ‘*:’ at test-suite-force/Tests.hs:49:17-40
addTcEvBind
  acC4
  [W] irred_acCH
    = irred_acDK `cast` (Sub
                           (Sym
                              U(hole:{acDI}, fsk0_acDA[fsk]
                                             Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0], s0_acDH[fuv:0])_N
                            ; (Trans
                                   (Sym cobox)
                                   (Trans (Sym cobox) (Sym cobox *: Sym cobox)_N
                                    /: Trans (Sym cobox) (Sym cobox *: Sym cobox)_N)_N
                               Data.UnitsOfMeasure.Syntax.~~ Trans
                                                                 (Sym {acDG})
                                                                 (Trans
                                                                      (Sym cobox)
                                                                      (Sym cobox
                                                                       /: Trans
                                                                              (Sym cobox)
                                                                              (Sym cobox
                                                                               *: Sym cobox)_N)_N
                                                                  *: Sym cobox)_N)_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_acDK {0}:: s0_acDH[fuv:0] (CIrredEvCan)
addTcEvBind
  acC4
  [W] irred_acDK = irred_acDJ
end stage interact with inerts }
Step 81[l:1,d:0] Irred equal (keep):
    [WD] irred_acDK {0}:: s0_acDH[fuv:0]
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                                                 (Unpack (Base "kg")) (CDictCan)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
flatten_many {
  "callStack"
  GHC.Stack.Types.CallStack
flatten }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
doTopReact
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
matchClassInst pred = ?callStack::GHC.Stack.Types.CallStack {
matchClass not matching dict ?callStack::GHC.Stack.Types.CallStack
} matchClassInst result NoInstance
try_fundeps
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
addInertCan }
Step 82[l:1,d:0] Kept as inert:
    [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (kept as inert) }
  final_item = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                            (Unpack (Base "kg")) (CDictCan)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
  rest of worklist = WL {Non-eqs = [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] $dKnownUnit_acD7 {0}:: KnownUnit
                                              (Unpack (Base "kg")) (CDictCan)
flatten_many { Unpack (Base "kg")
matchFamTcM
  Matching: Unpack (Base "kg")
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  fsk0_acDk[fsk]
Unfilled tyvar fsk_acDk[fsk]
flatten/flat-cache hit
  Unpack [fsk0_acDk[fsk]]
  fsk0_acDm[fsk]
Unfilled tyvar fsk_acDm[fsk]
Following inert tyvar
  FM_FlattenAll fsk_acDm[fsk] = '["kg"]
                                'Data.UnitsOfMeasure.Syntax.:/ '[]
  [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["kg"]
                         'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
flatten } '["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]
Emitting new wanted
  $dKnownUnit_acDL :: KnownUnit
                        ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:57:35-53
addTcEvBind
  acC4
  [W] $dKnownUnit_acD7
    = $dKnownUnit_acDL `cast` (KnownUnit
                                 (Trans (Trans (Sym cobox) (Sym cobox)) (Unpack (Sym cobox))_N))_R
canClass
  [WD] $dKnownUnit_acD7 {0}:: KnownUnit (Unpack (Base "kg"))
  KnownUnit ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
  ContinueWith [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                             ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                              ('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                              ('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) (CDictCan)
doTopReact
  [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]) (CDictCan)
matchClassInst
  pred = KnownUnit ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[]) {
matchClass success
  dict KnownUnit ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
  witness Data.UnitsOfMeasure.Singleton.$fKnownUnit:/ forall (xs :: [GHC.Types.Symbol]) (ys :: [GHC.Types.Symbol]).
                                                      (Data.UnitsOfMeasure.Singleton.KnownList xs,
                                                       Data.UnitsOfMeasure.Singleton.KnownList
                                                         ys) =>
                                                      KnownUnit
                                                        (xs 'Data.UnitsOfMeasure.Syntax.:/ ys)
} matchClassInst result
  GenInst [Data.UnitsOfMeasure.Singleton.KnownList '["kg"],
           Data.UnitsOfMeasure.Singleton.KnownList '[]]
          [safe]
doTopReact/found instance for
  [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
updSolvedSetTcs:
  [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
Emitting new wanted
  $dKnownList_acDQ :: Data.UnitsOfMeasure.Singleton.KnownList '["kg"]
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:57:35-53
Emitting new wanted
  $dKnownList_acDR :: Data.UnitsOfMeasure.Singleton.KnownList '[]
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:57:35-53
addTcEvBind
  acC4
  [W] $dKnownUnit_acDL
    = Data.UnitsOfMeasure.Singleton.$fKnownUnit:/ @['["kg"], '[]]
                                                  [$dKnownList_acDQ, $dKnownList_acDR]
Emitting fresh work
  [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["kg"] (CNonCanonical)
  [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '[] (CNonCanonical)
end stage top-level reactions }
Step 83[l:1,d:0] Top react: Dict/Top (solved wanted):
    [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                  ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                            '["kg"] (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
  rest of worklist = WL {Non-eqs = [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                                 '[] (CNonCanonical)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["kg"] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["kg"] (CNonCanonical)
canEvNC:cls Data.UnitsOfMeasure.Singleton.KnownList ['["kg"]]
flatten_many { '["kg"]
flatten } '["kg"]
canClass
  [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["kg"]
  Data.UnitsOfMeasure.Singleton.KnownList '["kg"]
  ContinueWith [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                             '["kg"]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["kg"] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["kg"] (CDictCan)
doTopReact
  [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["kg"] (CDictCan)
matchClassInst
  pred = Data.UnitsOfMeasure.Singleton.KnownList '["kg"] {
matchClass success
  dict Data.UnitsOfMeasure.Singleton.KnownList '["kg"]
  witness Data.UnitsOfMeasure.Singleton.$fKnownList: forall (x :: GHC.Types.Symbol) (xs :: [GHC.Types.Symbol]).
                                                     (GHC.TypeLits.KnownSymbol x,
                                                      Data.UnitsOfMeasure.Singleton.KnownList xs) =>
                                                     Data.UnitsOfMeasure.Singleton.KnownList
                                                       (x : xs)
} matchClassInst result
  GenInst [GHC.TypeLits.KnownSymbol "kg",
           Data.UnitsOfMeasure.Singleton.KnownList '[]]
          [safe]
doTopReact/found instance for
  [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["kg"]
updSolvedSetTcs:
  [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["kg"]
Emitting new wanted
  $dKnownSymbol_acDZ :: GHC.TypeLits.KnownSymbol "kg"
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:57:35-53
Emitting new wanted
  $dKnownList_acE0 :: Data.UnitsOfMeasure.Singleton.KnownList '[]
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:57:35-53
addTcEvBind
  acC4
  [W] $dKnownList_acDQ
    = Data.UnitsOfMeasure.Singleton.$fKnownList: @["kg", '[]]
                                                 [$dKnownSymbol_acDZ, $dKnownList_acE0]
Emitting fresh work
  [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol
                                  "kg" (CNonCanonical)
  [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '[] (CNonCanonical)
end stage top-level reactions }
Step 84[l:1,d:1] Top react: Dict/Top (solved wanted):
    [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                  '["kg"]
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol
                                              "kg" (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
  rest of worklist = WL {Non-eqs = [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                                 '[] (CNonCanonical)
                                   [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                                 '[] (CNonCanonical)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol
                                                "kg" (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol
                                  "kg" (CNonCanonical)
canEvNC:cls GHC.TypeLits.KnownSymbol ["kg"]
flatten_many { "kg"
flatten } "kg"
canClass
  [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
  GHC.TypeLits.KnownSymbol "kg"
  ContinueWith [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol
                                               "kg"
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol
                                                "kg" (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol
                                                "kg" (CDictCan)
doTopReact
  [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol
                                  "kg" (CDictCan)
matchClassInst pred = GHC.TypeLits.KnownSymbol "kg" {
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for
  [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
updSolvedSetTcs:
  [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
addTcEvBind
  acC4
  [W] $dKnownSymbol_acDZ
    = "kg" `cast` (Sym
                     (GHC.TypeLits.N:KnownSymbol[0] <"kg">_N
                      ; GHC.TypeLits.N:SSymbol[0] <"kg">_P))
end stage top-level reactions }
Step 85[l:1,d:2] Top react: Dict/Top (solved wanted):
    [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                            '[] (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
  rest of worklist = WL {Non-eqs = [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                                 '[] (CNonCanonical)
                                   [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '[] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '[] (CNonCanonical)
canEvNC:cls Data.UnitsOfMeasure.Singleton.KnownList ['[]]
flatten_many { '[]
flatten } '[]
canClass
  [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '[]
  Data.UnitsOfMeasure.Singleton.KnownList '[]
  ContinueWith [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                             '[]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '[] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '[] (CDictCan)
doTopReact
  [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '[] (CDictCan)
matchClassInst pred = Data.UnitsOfMeasure.Singleton.KnownList '[] {
matchClass success
  dict Data.UnitsOfMeasure.Singleton.KnownList '[]
  witness Data.UnitsOfMeasure.Singleton.$fKnownList[] Data.UnitsOfMeasure.Singleton.KnownList
                                                        '[]
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for
  [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '[]
updSolvedSetTcs:
  [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '[]
addTcEvBind
  acC4
  [W] $dKnownList_acE0
    = Data.UnitsOfMeasure.Singleton.$fKnownList[] @[] []
end stage top-level reactions }
Step 86[l:1,d:2] Top react: Dict/Top (solved wanted):
    [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                  '[]
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                            '[] (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                                                 (Unpack
                                                                    (Base "m"
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '[] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '[] (CNonCanonical)
canEvNC:cls Data.UnitsOfMeasure.Singleton.KnownList ['[]]
flatten_many { '[]
flatten } '[]
canClass
  [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '[]
  Data.UnitsOfMeasure.Singleton.KnownList '[]
  ContinueWith [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                             '[]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '[] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '[] (CDictCan)
doTopReact
  [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '[] (CDictCan)
addTcEvBind
  acC4
  [W] $dKnownList_acDR = $dKnownList_acE0
end stage top-level reactions }
Step 87[l:1,d:1] Top react: Dict/Top (cached):
    [WD] $dKnownList_acDR {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                  '[]
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                            (Unpack (Base "m" /: (Base "s" *: Base "s"))) (CDictCan)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                              (Unpack
                                                 (Base "m" /: (Base "s" *: Base "s"))) (CDictCan)
flatten_many { Unpack (Base "m" /: (Base "s" *: Base "s"))
matchFamTcM
  Matching: Unpack (Base "m" /: (Base "s" *: Base "s"))
  Match failed
matchFamTcM
  Matching: Base "m" /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  fsk0_acDo[fsk]
Unfilled tyvar fsk_acDo[fsk]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
flatten/flat-cache hit
  *: [fsk0_acDq[fsk], fsk0_acDq[fsk]]
  fsk0_acDs[fsk]
Unfilled tyvar fsk_acDs[fsk]
flatten/flat-cache hit
  /: [fsk0_acDo[fsk], fsk0_acDs[fsk]]
  fsk0_acDu[fsk]
Unfilled tyvar fsk_acDu[fsk]
flatten/flat-cache hit
  Unpack [fsk0_acDu[fsk]]
  fsk0_acDw[fsk]
Unfilled tyvar fsk_acDw[fsk]
Following inert tyvar
  FM_FlattenAll fsk_acDw[fsk] = '["m"]
                                'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
  [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["m"]
                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                     GHC.Types.Symbol)
flatten } '["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
Emitting new wanted
  $dKnownUnit_acE6 :: KnownUnit
                        ('["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:58:35-61
addTcEvBind
  acC4
  [W] $dKnownUnit_acDd
    = $dKnownUnit_acE6 `cast` (KnownUnit
                                 (Trans
                                      (Trans (Sym cobox) (Sym cobox))
                                      (Unpack
                                         (Trans
                                              (Sym cobox)
                                              (Sym cobox
                                               /: Trans
                                                      (Sym cobox)
                                                      (Sym cobox *: Sym cobox)_N)_N))_N))_R
canClass
  [WD] $dKnownUnit_acDd {0}:: KnownUnit
                                (Unpack (Base "m" /: (Base "s" *: Base "s")))
  KnownUnit ('["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
  ContinueWith [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                             ('["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                              ('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                              ('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) (CDictCan)
doTopReact
  [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                ('["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]) (CDictCan)
matchClassInst
  pred = KnownUnit
           ('["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]) {
matchClass success
  dict KnownUnit ('["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
  witness Data.UnitsOfMeasure.Singleton.$fKnownUnit:/ forall (xs :: [GHC.Types.Symbol]) (ys :: [GHC.Types.Symbol]).
                                                      (Data.UnitsOfMeasure.Singleton.KnownList xs,
                                                       Data.UnitsOfMeasure.Singleton.KnownList
                                                         ys) =>
                                                      KnownUnit
                                                        (xs 'Data.UnitsOfMeasure.Syntax.:/ ys)
} matchClassInst result
  GenInst [Data.UnitsOfMeasure.Singleton.KnownList '["m"],
           Data.UnitsOfMeasure.Singleton.KnownList '["s", "s"]]
          [safe]
doTopReact/found instance for
  [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                ('["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
updSolvedSetTcs:
  [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                ('["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
Emitting new wanted
  $dKnownList_acE7 :: Data.UnitsOfMeasure.Singleton.KnownList '["m"]
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:58:35-61
Emitting new wanted
  $dKnownList_acE8 :: Data.UnitsOfMeasure.Singleton.KnownList
                        '["s", "s"]
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:58:35-61
addTcEvBind
  acC4
  [W] $dKnownUnit_acE6
    = Data.UnitsOfMeasure.Singleton.$fKnownUnit:/ @['["m"],
                                                    '["s", "s"]]
                                                  [$dKnownList_acE7, $dKnownList_acE8]
Emitting fresh work
  [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["m"] (CNonCanonical)
  [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s", "s"] (CNonCanonical)
end stage top-level reactions }
Step 88[l:1,d:0] Top react: Dict/Top (solved wanted):
    [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                  ('["m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                            '["m"] (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
  rest of worklist = WL {Non-eqs = [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                                 '["s", "s"] (CNonCanonical)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["m"] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["m"] (CNonCanonical)
canEvNC:cls Data.UnitsOfMeasure.Singleton.KnownList ['["m"]]
flatten_many { '["m"]
flatten } '["m"]
canClass
  [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["m"]
  Data.UnitsOfMeasure.Singleton.KnownList '["m"]
  ContinueWith [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                             '["m"]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["m"] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["m"] (CDictCan)
doTopReact
  [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["m"] (CDictCan)
matchClassInst
  pred = Data.UnitsOfMeasure.Singleton.KnownList '["m"] {
matchClass success
  dict Data.UnitsOfMeasure.Singleton.KnownList '["m"]
  witness Data.UnitsOfMeasure.Singleton.$fKnownList: forall (x :: GHC.Types.Symbol) (xs :: [GHC.Types.Symbol]).
                                                     (GHC.TypeLits.KnownSymbol x,
                                                      Data.UnitsOfMeasure.Singleton.KnownList xs) =>
                                                     Data.UnitsOfMeasure.Singleton.KnownList
                                                       (x : xs)
} matchClassInst result
  GenInst [GHC.TypeLits.KnownSymbol "m",
           Data.UnitsOfMeasure.Singleton.KnownList '[]]
          [safe]
doTopReact/found instance for
  [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["m"]
updSolvedSetTcs:
  [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["m"]
Emitting new wanted
  $dKnownSymbol_acE9 :: GHC.TypeLits.KnownSymbol "m"
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:58:35-61
newWantedEvVar/cache hit
  [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '[]
addTcEvBind
  acC4
  [W] $dKnownList_acE7
    = Data.UnitsOfMeasure.Singleton.$fKnownList: @["m", '[]]
                                                 [$dKnownSymbol_acE9, $dKnownList_acE0]
Emitting fresh work
  [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol
                                  "m" (CNonCanonical)
end stage top-level reactions }
Step 89[l:1,d:1] Top react: Dict/Top (solved wanted):
    [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                  '["m"]
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol
                                              "m" (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                                 '["s", "s"] (CNonCanonical)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol
                                                "m" (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol
                                  "m" (CNonCanonical)
canEvNC:cls GHC.TypeLits.KnownSymbol ["m"]
flatten_many { "m"
flatten } "m"
canClass
  [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
  GHC.TypeLits.KnownSymbol "m"
  ContinueWith [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol
                                               "m"
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol
                                                "m" (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol
                                                "m" (CDictCan)
doTopReact
  [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol
                                  "m" (CDictCan)
matchClassInst pred = GHC.TypeLits.KnownSymbol "m" {
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for
  [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
updSolvedSetTcs:
  [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
addTcEvBind
  acC4
  [W] $dKnownSymbol_acE9
    = "m" `cast` (Sym
                    (GHC.TypeLits.N:KnownSymbol[0] <"m">_N
                     ; GHC.TypeLits.N:SSymbol[0] <"m">_P))
end stage top-level reactions }
Step 90[l:1,d:2] Top react: Dict/Top (solved wanted):
    [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                            '["s", "s"] (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
  rest of worklist = WL {Non-eqs = [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["s", "s"] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s", "s"] (CNonCanonical)
canEvNC:cls Data.UnitsOfMeasure.Singleton.KnownList ['["s", "s"]]
flatten_many { '["s", "s"]
flatten } '["s", "s"]
canClass
  [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s", "s"]
  Data.UnitsOfMeasure.Singleton.KnownList '["s", "s"]
  ContinueWith [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                             '["s", "s"]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["s", "s"] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["s", "s"] (CDictCan)
doTopReact
  [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s", "s"] (CDictCan)
matchClassInst
  pred = Data.UnitsOfMeasure.Singleton.KnownList '["s", "s"] {
matchClass success
  dict Data.UnitsOfMeasure.Singleton.KnownList '["s", "s"]
  witness Data.UnitsOfMeasure.Singleton.$fKnownList: forall (x :: GHC.Types.Symbol) (xs :: [GHC.Types.Symbol]).
                                                     (GHC.TypeLits.KnownSymbol x,
                                                      Data.UnitsOfMeasure.Singleton.KnownList xs) =>
                                                     Data.UnitsOfMeasure.Singleton.KnownList
                                                       (x : xs)
} matchClassInst result
  GenInst [GHC.TypeLits.KnownSymbol "s",
           Data.UnitsOfMeasure.Singleton.KnownList '["s"]]
          [safe]
doTopReact/found instance for
  [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s", "s"]
updSolvedSetTcs:
  [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s", "s"]
Emitting new wanted
  $dKnownSymbol_acEa :: GHC.TypeLits.KnownSymbol "s"
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:58:35-61
Emitting new wanted
  $dKnownList_acEb :: Data.UnitsOfMeasure.Singleton.KnownList '["s"]
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:58:35-61
addTcEvBind
  acC4
  [W] $dKnownList_acE8
    = Data.UnitsOfMeasure.Singleton.$fKnownList: @["s", '["s"]]
                                                 [$dKnownSymbol_acEa, $dKnownList_acEb]
Emitting fresh work
  [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol
                                  "s" (CNonCanonical)
  [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s"] (CNonCanonical)
end stage top-level reactions }
Step 91[l:1,d:1] Top react: Dict/Top (solved wanted):
    [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                  '["s", "s"]
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol
                                              "s" (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                                 '["s"] (CNonCanonical)
                                   [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol
                                                "s" (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol
                                  "s" (CNonCanonical)
canEvNC:cls GHC.TypeLits.KnownSymbol ["s"]
flatten_many { "s"
flatten } "s"
canClass
  [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
  GHC.TypeLits.KnownSymbol "s"
  ContinueWith [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol
                                               "s"
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol
                                                "s" (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol
                                                "s" (CDictCan)
doTopReact
  [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol
                                  "s" (CDictCan)
matchClassInst pred = GHC.TypeLits.KnownSymbol "s" {
} matchClassInst result
  GenInst []
          [safe]
doTopReact/found instance for
  [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
updSolvedSetTcs:
  [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
addTcEvBind
  acC4
  [W] $dKnownSymbol_acEa
    = "s" `cast` (Sym
                    (GHC.TypeLits.N:KnownSymbol[0] <"s">_N
                     ; GHC.TypeLits.N:SSymbol[0] <"s">_P))
end stage top-level reactions }
Step 92[l:1,d:2] Top react: Dict/Top (solved wanted):
    [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                            '["s"] (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
  rest of worklist = WL {Non-eqs = [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                                                 (Unpack
                                                                    ((Base "kg" *: Base "m")
                                                                     /: (Base "s"
                                                                         *: Base "s"))) (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["s"] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s"] (CNonCanonical)
canEvNC:cls Data.UnitsOfMeasure.Singleton.KnownList ['["s"]]
flatten_many { '["s"]
flatten } '["s"]
canClass
  [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s"]
  Data.UnitsOfMeasure.Singleton.KnownList '["s"]
  ContinueWith [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                             '["s"]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["s"] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["s"] (CDictCan)
doTopReact
  [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s"] (CDictCan)
matchClassInst
  pred = Data.UnitsOfMeasure.Singleton.KnownList '["s"] {
matchClass success
  dict Data.UnitsOfMeasure.Singleton.KnownList '["s"]
  witness Data.UnitsOfMeasure.Singleton.$fKnownList: forall (x :: GHC.Types.Symbol) (xs :: [GHC.Types.Symbol]).
                                                     (GHC.TypeLits.KnownSymbol x,
                                                      Data.UnitsOfMeasure.Singleton.KnownList xs) =>
                                                     Data.UnitsOfMeasure.Singleton.KnownList
                                                       (x : xs)
} matchClassInst result
  GenInst [GHC.TypeLits.KnownSymbol "s",
           Data.UnitsOfMeasure.Singleton.KnownList '[]]
          [safe]
doTopReact/found instance for
  [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s"]
updSolvedSetTcs:
  [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s"]
newWantedEvVar/cache hit
  [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
newWantedEvVar/cache hit
  [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '[]
addTcEvBind
  acC4
  [W] $dKnownList_acEb
    = Data.UnitsOfMeasure.Singleton.$fKnownList: @["s", '[]]
                                                 [$dKnownSymbol_acEa, $dKnownList_acE0]
end stage top-level reactions }
Step 93[l:1,d:2] Top react: Dict/Top (solved wanted):
    [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                  '["s"]
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                            (Unpack
                                               ((Base "kg" *: Base "m")
                                                /: (Base "s" *: Base "s"))) (CDictCan)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                              (Unpack
                                                 ((Base "kg" *: Base "m")
                                                  /: (Base "s" *: Base "s"))) (CDictCan)
flatten_many {
  Unpack ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
matchFamTcM
  Matching: Unpack
              ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Match failed
matchFamTcM
  Matching: (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "kg" *: Base "m"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  fsk0_acDk[fsk]
Unfilled tyvar fsk_acDk[fsk]
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  fsk0_acDo[fsk]
Unfilled tyvar fsk_acDo[fsk]
flatten/flat-cache hit
  *: [fsk0_acDk[fsk], fsk0_acDo[fsk]]
  fsk0_acDy[fsk]
Unfilled tyvar fsk_acDy[fsk]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  fsk0_acDq[fsk]
Unfilled tyvar fsk_acDq[fsk]
flatten/flat-cache hit
  *: [fsk0_acDq[fsk], fsk0_acDq[fsk]]
  fsk0_acDs[fsk]
Unfilled tyvar fsk_acDs[fsk]
flatten/flat-cache hit
  /: [fsk0_acDy[fsk], fsk0_acDs[fsk]]
  fsk0_acDA[fsk]
Unfilled tyvar fsk_acDA[fsk]
flatten/flat-cache hit
  Unpack [fsk0_acDA[fsk]]
  fsk0_acDC[fsk]
Unfilled tyvar fsk_acDC[fsk]
Following inert tyvar
  FM_FlattenAll fsk_acDC[fsk] = '["kg", "m"]
                                'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
  [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                            GHC.Types.Symbol)
                       GHC.Prim.~#
                       (('["kg", "m"]
                         'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                          "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                     GHC.Types.Symbol)
flatten } '["kg", "m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]
Emitting new wanted
  $dKnownUnit_acEc :: KnownUnit
                        ('["kg", "m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:59:35-60
addTcEvBind
  acC4
  [W] $dKnownUnit_acDg
    = $dKnownUnit_acEc `cast` (KnownUnit
                                 (Trans
                                      (Trans (Sym cobox) (Sym cobox))
                                      (Unpack
                                         (Trans
                                              (Sym cobox)
                                              (Trans (Sym cobox) (Sym cobox *: Sym cobox)_N
                                               /: Trans
                                                      (Sym cobox)
                                                      (Sym cobox *: Sym cobox)_N)_N))_N))_R
canClass
  [WD] $dKnownUnit_acDg {0}:: KnownUnit
                                (Unpack ((Base "kg" *: Base "m") /: (Base "s" *: Base "s")))
  KnownUnit ('["kg", "m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
  ContinueWith [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                             ('["kg", "m"]
                                              'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                              ('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                              ('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) (CDictCan)
doTopReact
  [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                ('["kg", "m"]
                                 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]) (CDictCan)
matchClassInst
  pred = KnownUnit
           ('["kg", "m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"]) {
matchClass success
  dict KnownUnit
         ('["kg", "m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
  witness Data.UnitsOfMeasure.Singleton.$fKnownUnit:/ forall (xs :: [GHC.Types.Symbol]) (ys :: [GHC.Types.Symbol]).
                                                      (Data.UnitsOfMeasure.Singleton.KnownList xs,
                                                       Data.UnitsOfMeasure.Singleton.KnownList
                                                         ys) =>
                                                      KnownUnit
                                                        (xs 'Data.UnitsOfMeasure.Syntax.:/ ys)
} matchClassInst result
  GenInst [Data.UnitsOfMeasure.Singleton.KnownList '["kg", "m"],
           Data.UnitsOfMeasure.Singleton.KnownList '["s", "s"]]
          [safe]
doTopReact/found instance for
  [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                ('["kg", "m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
updSolvedSetTcs:
  [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                ('["kg", "m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
Emitting new wanted
  $dKnownList_acEd :: Data.UnitsOfMeasure.Singleton.KnownList
                        '["kg", "m"]
  arising from a use of ‘showQuantity’
  at test-suite-force/Tests.hs:59:35-60
newWantedEvVar/cache hit
  [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["s", "s"]
addTcEvBind
  acC4
  [W] $dKnownUnit_acEc
    = Data.UnitsOfMeasure.Singleton.$fKnownUnit:/ @['["kg", "m"],
                                                    '["s", "s"]]
                                                  [$dKnownList_acEd, $dKnownList_acE8]
Emitting fresh work
  [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["kg", "m"] (CNonCanonical)
end stage top-level reactions }
Step 94[l:1,d:0] Top react: Dict/Top (solved wanted):
    [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                  ('["kg", "m"] 'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                            '["kg", "m"] (CNonCanonical)
  inerts = {Equalities: [G] cobox_acDi {0}:: (fsk0_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDh {0}:: (fsk0_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '[]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                        GHC.Types.Symbol) (CTyEqCan)
                        [G] cobox_acDE {1}:: (fsk0_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                  GHC.Types.Symbol)
                                             GHC.Prim.~#
                                             (('["kg", "m"]
                                               'Data.UnitsOfMeasure.Syntax.:/ '["s",
                                                                                "s"]) :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                           GHC.Types.Symbol) (CTyEqCan)
            Type-function equalities = [G] cobox_acDl {0}:: (Base "kg" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDk[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDp {0}:: (Base "m" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDo[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDr {0}:: (Base "s" :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk0_acDq[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDv {0}:: ((fsk0_acDo[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDu[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDB {0}:: ((fsk0_acDy[fsk]
                                                              /: fsk1_acDs[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDA[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDn {0}:: (Unpack
                                                               fsk0_acDk[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDm[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDx {0}:: (Unpack
                                                               fsk0_acDu[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDw[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDD {0}:: (Unpack
                                                               fsk0_acDA[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                   GHC.Types.Symbol)
                                                            GHC.Prim.~#
                                                            (fsk1_acDC[fsk] :: Data.UnitsOfMeasure.Syntax.UnitSyntax
                                                                                 GHC.Types.Symbol) (CFunEqCan)
                                       [G] cobox_acDt {0}:: ((fsk0_acDq[fsk]
                                                              *: fsk0_acDq[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk1_acDs[fsk] :: Unit) (CFunEqCan)
                                       [G] cobox_acDz {0}:: ((fsk0_acDk[fsk]
                                                              *: fsk1_acDo[fsk]) :: Unit)
                                                            GHC.Prim.~#
                                                            (fsk2_acDy[fsk] :: Unit) (CFunEqCan)
                                       [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                                               *: fsk1_acDk[fsk]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                                               Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
            Dictionaries = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
            Irreds = [WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan)
            Unsolved goals = 2}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["kg", "m"] (CNonCanonical)
canonicalize (non-canonical)
  [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["kg", "m"] (CNonCanonical)
canEvNC:cls Data.UnitsOfMeasure.Singleton.KnownList ['["kg", "m"]]
flatten_many { '["kg", "m"]
flatten } '["kg", "m"]
canClass
  [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["kg", "m"]
  Data.UnitsOfMeasure.Singleton.KnownList '["kg", "m"]
  ContinueWith [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                             '["kg", "m"]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["kg", "m"] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                              '["kg", "m"] (CDictCan)
doTopReact
  [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["kg", "m"] (CDictCan)
matchClassInst
  pred = Data.UnitsOfMeasure.Singleton.KnownList '["kg", "m"] {
matchClass success
  dict Data.UnitsOfMeasure.Singleton.KnownList '["kg", "m"]
  witness Data.UnitsOfMeasure.Singleton.$fKnownList: forall (x :: GHC.Types.Symbol) (xs :: [GHC.Types.Symbol]).
                                                     (GHC.TypeLits.KnownSymbol x,
                                                      Data.UnitsOfMeasure.Singleton.KnownList xs) =>
                                                     Data.UnitsOfMeasure.Singleton.KnownList
                                                       (x : xs)
} matchClassInst result
  GenInst [GHC.TypeLits.KnownSymbol "kg",
           Data.UnitsOfMeasure.Singleton.KnownList '["m"]]
          [safe]
doTopReact/found instance for
  [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["kg", "m"]
updSolvedSetTcs:
  [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["kg", "m"]
newWantedEvVar/cache hit
  [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
newWantedEvVar/cache hit
  [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                '["m"]
addTcEvBind
  acC4
  [W] $dKnownList_acEd
    = Data.UnitsOfMeasure.Singleton.$fKnownList: @["kg", '["m"]]
                                                 [$dKnownSymbol_acDZ, $dKnownList_acE7]
end stage top-level reactions }
Step 95[l:1,d:1] Top react: Dict/Top (solved wanted):
    [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                  '["kg", "m"]
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {[WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                     *: fsk1_acDk[fsk]) :: Unit)
                                   GHC.Prim.~#
                                   (s0_acDF[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                     Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                   GHC.Prim.~#
                                   (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)}
  insols = {}
  others = {[WD] irred_acDJ {0}:: s0_acDH[fuv:0] (CIrredEvCan),
            [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{acDG} {0}:: ((fsk0_acDu[fsk]
                                    *: fsk1_acDk[fsk]) :: Unit)
                                  GHC.Prim.~#
                                  (s0_acDF[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acDI} {0}:: ((fsk0_acDA[fsk]
                                    Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]) :: Constraint)
                                  GHC.Prim.~#
                                  (s1_acDH[fuv:0] :: Constraint) (CFunEqCan)
   Tv eqs =}
Filling coercion hole
  acDI := <((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
           Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]>_N
unflattenFmv
  s_acDH[fuv:0] := ((Base "kg" *: Base "m")
                    /: (Base "s" *: Base "s"))
                   Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]
writeMetaTyVar
  s_acDH[fuv:0] :: Constraint := ((Base "kg" *: Base "m")
                                  /: (Base "s" *: Base "s"))
                                 Data.UnitsOfMeasure.Syntax.~~ s0_acDF[fuv:0]
Filling coercion hole
  acDG := <(Base "m" /: (Base "s" *: Base "s")) *: Base "kg">_N
unflattenFmv
  s_acDF[fuv:0] := (Base "m" /: (Base "s" *: Base "s")) *: Base "kg"
writeMetaTyVar
  s_acDF[fuv:0] :: Unit := (Base "m" /: (Base "s" *: Base "s"))
                           *: Base "kg"
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
zonkSimples done: {}
zonkSimples done:
  {[WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
tcPluginSolve start thoralf-uom-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve gsConvCts Just [ ] [] []
thoralf-solve wsConvCts
  Just [ (= ((_ map (- (Int Int) Int)) ((_ map (+ (Int Int) Int)) (store base "kg" n1) (store base "m" n1)) ((_ map (+ (Int Int) Int)) (store base "s" n1) (store base "s" n1))) ((_ map (+ (Int Int) Int)) ((_ map (- (Int Int) Int)) (store base "m" n1) ((_ map (+ (Int Int) Int)) (store base "s" n1) (store base "s" n1))) (store base "kg" n1))) ] [[WD] irred_acDJ {0}:: ((Base
                                                                                                                                                                                                                                                                                                                                                                                    "kg"
                                                                                                                                                                                                                                                                                                                                                                                  *: Base
                                                                                                                                                                                                                                                                                                                                                                                       "m")
                                                                                                                                                                                                                                                                                                                                                                                 /: (Base
                                                                                                                                                                                                                                                                                                                                                                                       "s"
                                                                                                                                                                                                                                                                                                                                                                                     *: Base
                                                                                                                                                                                                                                                                                                                                                                                          "s"))
                                                                                                                                                                                                                                                                                                                                                                                Data.UnitsOfMeasure.Syntax.~~ ((Base
                                                                                                                                                                                                                                                                                                                                                                                                                  "m"
                                                                                                                                                                                                                                                                                                                                                                                                                /: (Base
                                                                                                                                                                                                                                                                                                                                                                                                                      "s"
                                                                                                                                                                                                                                                                                                                                                                                                                    *: Base
                                                                                                                                                                                                                                                                                                                                                                                                                         "s"))
                                                                                                                                                                                                                                                                                                                                                                                                               *: Base
                                                                                                                                                                                                                                                                                                                                                                                                                    "kg") (CNonCanonical)] []
thoralf-solve decls []
thoralf-solve decls filtered []
thoralf-solve givens []
thoralf-solve givens filtered []
thoralf-solve wanteds
  [[WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve wanteds filtered
  [[WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve simplified given sexprs []
thoralf-solve simplified wanteds []
tcPluginSolve ok thoralf-uom-plugin
  solved = []
  new    = []
tcPluginSolve start uom-eq-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok uom-eq-plugin
  solved = []
  new    = [[WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                   /: (Base "s" *: Base "s"))
                                  Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                  /: (Base "s" *: Base "s"))
                                                                 *: Base "kg") (CNonCanonical)]
tcPluginSolve start uom-unpack-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok uom-unpack-plugin
  solved = []
  new    = []
solveSimple going round again:
  0
  True
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                     /: (Base "s" *: Base "s"))
                                    Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                    /: (Base "s" *: Base "s"))
                                                                   *: Base "kg") (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] irred_acDJ {0}:: ((Base "kg"
                                                           *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                       /: (Base "s" *: Base "s"))
                                      Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                      /: (Base "s" *: Base "s"))
                                                                     *: Base "kg") (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                         /: (Base "s" *: Base "s"))
                        Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                       *: Base "kg") (CNonCanonical)
canEvNC:irred
  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                 *: Base "kg")
can_pred
  IrredPred =  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
               Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                              *: Base "kg")
flatten {
  FM_FlattenAll ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                               *: Base "kg")
matchFamTcM
  Matching: ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
            Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                           *: Base "kg")
  Match failed
matchFamTcM
  Matching: (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "kg" *: Base "m"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
New coercion hole: acEf
Emitting new coercion hole
  {acEf} :: (Base "kg" :: Unit) GHC.Prim.~# (s0_acEe[fuv:0] :: Unit)
extendFlatCache
  Base ["kg"]
  [WD]
  s0_acEe[fuv:0]
flatten/flat-cache miss
  Base ["kg"]
  s_acEe[fuv:0]
  [WD] hole{acEf} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (s0_acEe[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "m"
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
New coercion hole: acEh
Emitting new coercion hole
  {acEh} :: (Base "m" :: Unit) GHC.Prim.~# (s0_acEg[fuv:0] :: Unit)
extendFlatCache
  Base ["m"]
  [WD]
  s0_acEg[fuv:0]
flatten/flat-cache miss
  Base ["m"]
  s_acEg[fuv:0]
  [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                        GHC.Prim.~#
                        (s0_acEg[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acEe[fuv:0] *: s1_acEg[fuv:0]
  Match failed
New coercion hole: acEj
Emitting new coercion hole
  {acEj} :: ((s0_acEe[fuv:0] *: s1_acEg[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acEi[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acEe[fuv:0], s0_acEg[fuv:0]]
  [WD]
  s0_acEi[fuv:0]
flatten/flat-cache miss
  *: [s0_acEe[fuv:0], s0_acEg[fuv:0]]
  s_acEi[fuv:0]
  [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0] *: s1_acEg[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEi[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
New coercion hole: acEl
Emitting new coercion hole
  {acEl} :: (Base "s" :: Unit) GHC.Prim.~# (s0_acEk[fuv:0] :: Unit)
extendFlatCache
  Base ["s"]
  [WD]
  s0_acEk[fuv:0]
flatten/flat-cache miss
  Base ["s"]
  s_acEk[fuv:0]
  [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                        GHC.Prim.~#
                        (s0_acEk[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEk[fuv:0]
Unfilled tyvar s_acEk[fuv:0]
matchFamTcM
  Matching: s0_acEk[fuv:0] *: s0_acEk[fuv:0]
  Match failed
New coercion hole: acEn
Emitting new coercion hole
  {acEn} :: ((s0_acEk[fuv:0] *: s0_acEk[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s1_acEm[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acEk[fuv:0], s0_acEk[fuv:0]]
  [WD]
  s0_acEm[fuv:0]
flatten/flat-cache miss
  *: [s0_acEk[fuv:0], s0_acEk[fuv:0]]
  s_acEm[fuv:0]
  [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0] *: s0_acEk[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s1_acEm[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acEi[fuv:0] /: s1_acEm[fuv:0]
  Match failed
New coercion hole: acEp
Emitting new coercion hole
  {acEp} :: ((s0_acEi[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acEo[fuv:0] :: Unit)
extendFlatCache
  /: [s0_acEi[fuv:0], s0_acEm[fuv:0]]
  [WD]
  s0_acEo[fuv:0]
flatten/flat-cache miss
  /: [s0_acEi[fuv:0], s0_acEm[fuv:0]]
  s_acEo[fuv:0]
  [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEo[fuv:0] :: Unit)
matchFamTcM
  Matching: (Base "m" /: (Base "s" *: Base "s")) *: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "m" /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acEg[fuv:0]
Unfilled tyvar s_acEg[fuv:0]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEk[fuv:0]
Unfilled tyvar s_acEk[fuv:0]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEk[fuv:0]
Unfilled tyvar s_acEk[fuv:0]
flatten/flat-cache hit
  *: [s0_acEk[fuv:0], s0_acEk[fuv:0]]
  s0_acEm[fuv:0]
Unfilled tyvar s_acEm[fuv:0]
matchFamTcM
  Matching: s0_acEg[fuv:0] /: s1_acEm[fuv:0]
  Match failed
New coercion hole: acEr
Emitting new coercion hole
  {acEr} :: ((s0_acEg[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acEq[fuv:0] :: Unit)
extendFlatCache
  /: [s0_acEg[fuv:0], s0_acEm[fuv:0]]
  [WD]
  s0_acEq[fuv:0]
flatten/flat-cache miss
  /: [s0_acEg[fuv:0], s0_acEm[fuv:0]]
  s_acEq[fuv:0]
  [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEq[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acEe[fuv:0]
Unfilled tyvar s_acEe[fuv:0]
matchFamTcM
  Matching: s0_acEq[fuv:0] *: s1_acEe[fuv:0]
  Match failed
New coercion hole: acEt
Emitting new coercion hole
  {acEt} :: ((s0_acEq[fuv:0] *: s1_acEe[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acEs[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acEq[fuv:0], s0_acEe[fuv:0]]
  [WD]
  s0_acEs[fuv:0]
flatten/flat-cache miss
  *: [s0_acEq[fuv:0], s0_acEe[fuv:0]]
  s_acEs[fuv:0]
  [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0] *: s1_acEe[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEs[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acEo[fuv:0]
            Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]
  Match failed
New coercion hole: acEv
Emitting new coercion hole
  {acEv} :: ((s0_acEo[fuv:0]
              Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
            GHC.Prim.~#
            (s2_acEu[fuv:0] :: Constraint)
extendFlatCache
  Data.UnitsOfMeasure.Syntax.~~ [s0_acEo[fuv:0], s0_acEs[fuv:0]]
  [WD]
  s0_acEu[fuv:0]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Syntax.~~ [s0_acEo[fuv:0], s0_acEs[fuv:0]]
  s_acEu[fuv:0]
  [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                          Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                        GHC.Prim.~#
                        (s2_acEu[fuv:0] :: Constraint)
flatten } s0_acEu[fuv:0]
Emitting new wanted
  irred_acEw :: s0_acEu[fuv:0]
  arising from a use of ‘*:’ at test-suite-force/Tests.hs:49:17-40
addTcEvBind
  acC4
  [W] irred_acDJ
    = irred_acEw `cast` (Sub
                           (Sym
                              U(hole:{acEv}, s0_acEo[fuv:0]
                                             Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0], s0_acEu[fuv:0])_N
                            ; (Trans
                                   (Sym {acEp})
                                   (Trans (Sym {acEj}) (Sym {acEf} *: Sym {acEh})_N
                                    /: Trans (Sym {acEn}) (Sym {acEl} *: Sym {acEl})_N)_N
                               Data.UnitsOfMeasure.Syntax.~~ Trans
                                                                 (Sym {acEt})
                                                                 (Trans
                                                                      (Sym {acEr})
                                                                      (Sym {acEh}
                                                                       /: Trans
                                                                              (Sym {acEn})
                                                                              (Sym {acEl}
                                                                               *: Sym {acEl})_N)_N
                                                                  *: Sym {acEf})_N)_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
doTopReact [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
addInertCan }
Step 96[l:1,d:0] Kept as inert:
    [WD] irred_acEw {0}:: s0_acEu[fuv:0]
End solver pipeline (kept as inert) }
  final_item = [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEf} {0}:: (Base "kg" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Irreds = [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEh} {0}:: (Base
                                                           "m" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0] *: s1_acEg[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0] *: s0_acEk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0] *: s1_acEe[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEf} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "kg"
flatten } "kg"
extendFlatCache
  Base ["kg"]
  [WD]
  s0_acEe[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEf} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEf} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEf} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "kg"
  Match failed
improveTopFunEqs
  Base ["kg"] s_acEe[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEf} {0}:: (Base
                                                                   "kg" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 97[l:1,d:0] Kept as inert:
    [WD] hole{acEf} {0}:: (Base "kg" :: Unit)
                          GHC.Prim.~#
                          (s0_acEe[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEf} {0}:: (Base "kg" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEf} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                                          *: s1_acEg[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0] *: s0_acEk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0] *: s1_acEe[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "m"
flatten } "m"
extendFlatCache
  Base ["m"]
  [WD]
  s0_acEg[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                        GHC.Prim.~#
                        (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "m"
  Match failed
improveTopFunEqs
  Base ["m"] s_acEg[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEh} {0}:: (Base
                                                                   "m" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 98[l:1,d:0] Kept as inert:
    [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                          GHC.Prim.~#
                          (s0_acEg[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                      *: s1_acEg[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEf} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEl} {0}:: (Base
                                                           "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0] *: s0_acEk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0] *: s1_acEe[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                        *: s1_acEg[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEe[fuv:0]
  s0_acEg[fuv:0]
Unfilled tyvar s_acEe[fuv:0]
Unfilled tyvar s_acEg[fuv:0]
flatten }
  s0_acEe[fuv:0]
  s0_acEg[fuv:0]
extendFlatCache
  *: [s0_acEe[fuv:0], s0_acEg[fuv:0]]
  [WD]
  s0_acEi[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                        *: s1_acEg[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                        *: s1_acEg[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0] *: s1_acEg[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEe[fuv:0] *: s1_acEg[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acEe[fuv:0], s0_acEg[fuv:0]] s_acEi[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                                                  *: s1_acEg[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 99[l:1,d:0] Kept as inert:
    [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0] *: s1_acEg[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acEi[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                       *: s1_acEg[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEf} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                                               *: s1_acEg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                                          *: s0_acEk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0] *: s1_acEe[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "s"
flatten } "s"
extendFlatCache
  Base ["s"]
  [WD]
  s0_acEk[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                        GHC.Prim.~#
                        (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "s"
  Match failed
improveTopFunEqs
  Base ["s"] s_acEk[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEl} {0}:: (Base
                                                                   "s" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 100[l:1,d:0] Kept as inert:
    [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                          GHC.Prim.~#
                          (s0_acEk[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                      *: s0_acEk[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                                               *: s1_acEg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEf} {0}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0]
                                                          /: s1_acEm[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0] *: s1_acEe[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                        *: s0_acEk[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEk[fuv:0]
  s0_acEk[fuv:0]
Unfilled tyvar s_acEk[fuv:0]
Unfilled tyvar s_acEk[fuv:0]
flatten }
  s0_acEk[fuv:0]
  s0_acEk[fuv:0]
extendFlatCache
  *: [s0_acEk[fuv:0], s0_acEk[fuv:0]]
  [WD]
  s0_acEm[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                        *: s0_acEk[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                        *: s0_acEk[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0] *: s0_acEk[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEk[fuv:0] *: s0_acEk[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acEk[fuv:0], s0_acEk[fuv:0]] s_acEm[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                                                  *: s0_acEk[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 101[l:1,d:0] Kept as inert:
    [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0] *: s0_acEk[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s1_acEm[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                       *: s0_acEk[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0]
                                      /: s1_acEm[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEf} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                                               *: s1_acEg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                                               *: s0_acEk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0]
                                                          /: s1_acEm[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0] *: s1_acEe[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0]
                                        /: s1_acEm[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEi[fuv:0]
  s0_acEm[fuv:0]
Unfilled tyvar s_acEi[fuv:0]
Unfilled tyvar s_acEm[fuv:0]
flatten }
  s0_acEi[fuv:0]
  s0_acEm[fuv:0]
extendFlatCache
  /: [s0_acEi[fuv:0], s0_acEm[fuv:0]]
  [WD]
  s0_acEo[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0]
                                        /: s1_acEm[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0]
                                        /: s1_acEm[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEi[fuv:0] /: s1_acEm[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acEi[fuv:0], s0_acEm[fuv:0]] s_acEo[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0]
                                                                  /: s1_acEm[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 102[l:1,d:0] Kept as inert:
    [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acEo[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0]
                                       /: s1_acEm[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0]
                                      /: s1_acEm[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEf} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                                               *: s1_acEg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                                               *: s0_acEk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0]
                                                               /: s1_acEm[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0]
                                                          *: s1_acEe[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0]
                                        /: s1_acEm[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEg[fuv:0]
  s0_acEm[fuv:0]
Unfilled tyvar s_acEg[fuv:0]
Unfilled tyvar s_acEm[fuv:0]
flatten }
  s0_acEg[fuv:0]
  s0_acEm[fuv:0]
extendFlatCache
  /: [s0_acEg[fuv:0], s0_acEm[fuv:0]]
  [WD]
  s0_acEq[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0]
                                        /: s1_acEm[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0]
                                        /: s1_acEm[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEg[fuv:0] /: s1_acEm[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acEg[fuv:0], s0_acEm[fuv:0]] s_acEq[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0]
                                                                  /: s1_acEm[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 103[l:1,d:0] Kept as inert:
    [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acEq[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0]
                                       /: s1_acEm[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0]
                                      *: s1_acEe[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEf} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                                               *: s1_acEg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                                               *: s0_acEk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0]
                                                               /: s1_acEm[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0]
                                                               /: s1_acEm[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0]
                                        *: s1_acEe[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEq[fuv:0]
  s0_acEe[fuv:0]
Unfilled tyvar s_acEq[fuv:0]
Unfilled tyvar s_acEe[fuv:0]
flatten }
  s0_acEq[fuv:0]
  s0_acEe[fuv:0]
extendFlatCache
  *: [s0_acEq[fuv:0], s0_acEe[fuv:0]]
  [WD]
  s0_acEs[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0]
                                        *: s1_acEe[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0]
                                        *: s1_acEe[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0] *: s1_acEe[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEq[fuv:0] *: s1_acEe[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acEq[fuv:0], s0_acEe[fuv:0]] s_acEs[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0]
                                                                  *: s1_acEe[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 104[l:1,d:0] Kept as inert:
    [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0] *: s1_acEe[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acEs[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0]
                                       *: s1_acEe[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                      Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                    GHC.Prim.~#
                                    (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEf} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0]
                                                               /: s1_acEm[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0]
                                                               /: s1_acEm[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                                               *: s1_acEg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                                               *: s0_acEk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0]
                                                               *: s1_acEe[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] irred_acDJ {0}:: ((Base "kg"
                                                           *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                        Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
flatten_many {
  s0_acEo[fuv:0]
  s0_acEs[fuv:0]
Unfilled tyvar s_acEo[fuv:0]
Unfilled tyvar s_acEs[fuv:0]
flatten }
  s0_acEo[fuv:0]
  s0_acEs[fuv:0]
extendFlatCache
  Data.UnitsOfMeasure.Syntax.~~ [s0_acEo[fuv:0], s0_acEs[fuv:0]]
  [WD]
  s0_acEu[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                        Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                        Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
doTopReact
  [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                          Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                        GHC.Prim.~#
                        (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
matchFamTcM
  Matching: s0_acEo[fuv:0]
            Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]
  Match failed
improveTopFunEqs
  Data.UnitsOfMeasure.Syntax.~~ [s0_acEo[fuv:0],
                                 s0_acEs[fuv:0]] s_acEu[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                                                  Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                                                GHC.Prim.~#
                                                                (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
addInertCan }
Step 105[l:1,d:0] Kept as inert:
    [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                            Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                          GHC.Prim.~#
                          (s2_acEu[fuv:0] :: Constraint)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                       Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                     GHC.Prim.~#
                                     (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                     /: (Base "s" *: Base "s"))
                                    Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                    /: (Base "s" *: Base "s"))
                                                                   *: Base "kg") (CNonCanonical)
  inerts = {Type-function equalities = [WD] hole{acEf} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0]
                                                               /: s1_acEm[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0]
                                                               /: s1_acEm[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                                               *: s1_acEg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                                               *: s0_acEk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0]
                                                               *: s1_acEe[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                                               Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                                       /: (Base "s" *: Base "s"))
                                      Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                      /: (Base "s" *: Base "s"))
                                                                     *: Base "kg") (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_acDJ {0}:: ((Base "kg" *: Base "m")
                         /: (Base "s" *: Base "s"))
                        Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                       *: Base "kg") (CNonCanonical)
canEvNC:irred
  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                 *: Base "kg")
can_pred
  IrredPred =  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
               Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                              *: Base "kg")
flatten {
  FM_FlattenAll ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                               *: Base "kg")
matchFamTcM
  Matching: ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
            Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                           *: Base "kg")
  Match failed
matchFamTcM
  Matching: (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "kg" *: Base "m"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acEe[fuv:0]
Unfilled tyvar s_acEe[fuv:0]
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acEg[fuv:0]
Unfilled tyvar s_acEg[fuv:0]
flatten/flat-cache hit
  *: [s0_acEe[fuv:0], s0_acEg[fuv:0]]
  s0_acEi[fuv:0]
Unfilled tyvar s_acEi[fuv:0]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEk[fuv:0]
Unfilled tyvar s_acEk[fuv:0]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEk[fuv:0]
Unfilled tyvar s_acEk[fuv:0]
flatten/flat-cache hit
  *: [s0_acEk[fuv:0], s0_acEk[fuv:0]]
  s0_acEm[fuv:0]
Unfilled tyvar s_acEm[fuv:0]
flatten/flat-cache hit
  /: [s0_acEi[fuv:0], s0_acEm[fuv:0]]
  s0_acEo[fuv:0]
Unfilled tyvar s_acEo[fuv:0]
matchFamTcM
  Matching: (Base "m" /: (Base "s" *: Base "s")) *: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "m" /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acEg[fuv:0]
Unfilled tyvar s_acEg[fuv:0]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEk[fuv:0]
Unfilled tyvar s_acEk[fuv:0]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEk[fuv:0]
Unfilled tyvar s_acEk[fuv:0]
flatten/flat-cache hit
  *: [s0_acEk[fuv:0], s0_acEk[fuv:0]]
  s0_acEm[fuv:0]
Unfilled tyvar s_acEm[fuv:0]
flatten/flat-cache hit
  /: [s0_acEg[fuv:0], s0_acEm[fuv:0]]
  s0_acEq[fuv:0]
Unfilled tyvar s_acEq[fuv:0]
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acEe[fuv:0]
Unfilled tyvar s_acEe[fuv:0]
flatten/flat-cache hit
  *: [s0_acEq[fuv:0], s0_acEe[fuv:0]]
  s0_acEs[fuv:0]
Unfilled tyvar s_acEs[fuv:0]
flatten/flat-cache hit
  Data.UnitsOfMeasure.Syntax.~~ [s0_acEo[fuv:0], s0_acEs[fuv:0]]
  s0_acEu[fuv:0]
Unfilled tyvar s_acEu[fuv:0]
flatten } s0_acEu[fuv:0]
Emitting new wanted
  irred_acEx :: s0_acEu[fuv:0]
  arising from a use of ‘*:’ at test-suite-force/Tests.hs:49:17-40
addTcEvBind
  acC4
  [W] irred_acDJ
    = irred_acEx `cast` (Sub
                           (Sym
                              U(hole:{acEv}, s0_acEo[fuv:0]
                                             Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0], s0_acEu[fuv:0])_N
                            ; (Trans
                                   (Sym {acEp})
                                   (Trans (Sym {acEj}) (Sym {acEf} *: Sym {acEh})_N
                                    /: Trans (Sym {acEn}) (Sym {acEl} *: Sym {acEl})_N)_N
                               Data.UnitsOfMeasure.Syntax.~~ Trans
                                                                 (Sym {acEt})
                                                                 (Trans
                                                                      (Sym {acEr})
                                                                      (Sym {acEh}
                                                                       /: Trans
                                                                              (Sym {acEn})
                                                                              (Sym {acEl}
                                                                               *: Sym {acEl})_N)_N
                                                                  *: Sym {acEf})_N)_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_acEx {0}:: s0_acEu[fuv:0] (CIrredEvCan)
addTcEvBind
  acC4
  [W] irred_acEx = irred_acEw
end stage interact with inerts }
Step 106[l:1,d:0] Irred equal (keep):
    [WD] irred_acEx {0}:: s0_acEu[fuv:0]
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
  inerts = {Type-function equalities = [WD] hole{acEf} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0]
                                                               /: s1_acEm[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0]
                                                               /: s1_acEm[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0]
                                                               *: s1_acEg[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0]
                                                               *: s0_acEk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0]
                                                               *: s1_acEe[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                                               Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
flatten_many {
  "callStack"
  GHC.Stack.Types.CallStack
flatten }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
doTopReact
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
matchClassInst pred = ?callStack::GHC.Stack.Types.CallStack {
matchClass not matching dict ?callStack::GHC.Stack.Types.CallStack
} matchClassInst result NoInstance
try_fundeps
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
addInertCan }
Step 107[l:1,d:0] Kept as inert:
    [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (kept as inert) }
  final_item = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {[WD] hole{acEf} {0}:: (Base "kg" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acEe[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acEg[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acEk[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acEo[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acEq[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0] *: s1_acEg[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acEi[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0] *: s0_acEk[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s1_acEm[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0] *: s1_acEe[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acEs[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                     Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                   GHC.Prim.~#
                                   (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)}
  insols = {}
  others = {[WD] irred_acEw {0}:: s0_acEu[fuv:0] (CIrredEvCan),
            [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{acEf} {0}:: (Base "kg" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acEe[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEh} {0}:: (Base "m" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acEg[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEl} {0}:: (Base "s" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acEk[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEp} {0}:: ((s0_acEi[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acEo[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEr} {0}:: ((s0_acEg[fuv:0] /: s1_acEm[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acEq[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEj} {0}:: ((s0_acEe[fuv:0] *: s1_acEg[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acEi[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEn} {0}:: ((s0_acEk[fuv:0] *: s0_acEk[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s1_acEm[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEt} {0}:: ((s0_acEq[fuv:0] *: s1_acEe[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acEs[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEv} {0}:: ((s0_acEo[fuv:0]
                                    Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]) :: Constraint)
                                  GHC.Prim.~#
                                  (s2_acEu[fuv:0] :: Constraint) (CFunEqCan)
   Tv eqs =}
Filling coercion hole
  acEv := <s0_acEo[fuv:0]
           Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]>_N
unflattenFmv
  s_acEu[fuv:0] := s0_acEo[fuv:0]
                   Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]
writeMetaTyVar
  s_acEu[fuv:0] :: Constraint := s0_acEo[fuv:0]
                                 Data.UnitsOfMeasure.Syntax.~~ s1_acEs[fuv:0]
Filling coercion hole acEt := <s0_acEq[fuv:0] *: s1_acEe[fuv:0]>_N
unflattenFmv s_acEs[fuv:0] := s0_acEq[fuv:0] *: s1_acEe[fuv:0]
writeMetaTyVar
  s_acEs[fuv:0] :: Unit := s0_acEq[fuv:0] *: s1_acEe[fuv:0]
Filling coercion hole acEn := <s0_acEk[fuv:0] *: s0_acEk[fuv:0]>_N
unflattenFmv s_acEm[fuv:0] := s0_acEk[fuv:0] *: s0_acEk[fuv:0]
writeMetaTyVar
  s_acEm[fuv:0] :: Unit := s0_acEk[fuv:0] *: s0_acEk[fuv:0]
Filling coercion hole acEj := <s0_acEe[fuv:0] *: s1_acEg[fuv:0]>_N
unflattenFmv s_acEi[fuv:0] := s0_acEe[fuv:0] *: s1_acEg[fuv:0]
writeMetaTyVar
  s_acEi[fuv:0] :: Unit := s0_acEe[fuv:0] *: s1_acEg[fuv:0]
Filling coercion hole
  acEr := <s0_acEg[fuv:0] /: (s1_acEk[fuv:0] *: s1_acEk[fuv:0])>_N
unflattenFmv
  s_acEq[fuv:0] := s0_acEg[fuv:0]
                   /: (s1_acEk[fuv:0] *: s1_acEk[fuv:0])
writeMetaTyVar
  s_acEq[fuv:0] :: Unit := s0_acEg[fuv:0]
                           /: (s1_acEk[fuv:0] *: s1_acEk[fuv:0])
Filling coercion hole
  acEp := <(s0_acEe[fuv:0] *: s1_acEg[fuv:0])
           /: (s2_acEk[fuv:0] *: s2_acEk[fuv:0])>_N
unflattenFmv
  s_acEo[fuv:0] := (s0_acEe[fuv:0] *: s1_acEg[fuv:0])
                   /: (s2_acEk[fuv:0] *: s2_acEk[fuv:0])
writeMetaTyVar
  s_acEo[fuv:0] :: Unit := (s0_acEe[fuv:0] *: s1_acEg[fuv:0])
                           /: (s2_acEk[fuv:0] *: s2_acEk[fuv:0])
Filling coercion hole acEl := <Base "s">_N
unflattenFmv s_acEk[fuv:0] := Base "s"
writeMetaTyVar s_acEk[fuv:0] :: Unit := Base "s"
Filling coercion hole acEh := <Base "m">_N
unflattenFmv s_acEg[fuv:0] := Base "m"
writeMetaTyVar s_acEg[fuv:0] :: Unit := Base "m"
Filling coercion hole acEf := <Base "kg">_N
unflattenFmv s_acEe[fuv:0] := Base "kg"
writeMetaTyVar s_acEe[fuv:0] :: Unit := Base "kg"
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
zonkSimples done: {}
zonkSimples done:
  {[WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
tcPluginSolve start thoralf-uom-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve gsConvCts Just [ ] [] []
thoralf-solve wsConvCts
  Just [ (= ((_ map (- (Int Int) Int)) ((_ map (+ (Int Int) Int)) (store base "kg" n1) (store base "m" n1)) ((_ map (+ (Int Int) Int)) (store base "s" n1) (store base "s" n1))) ((_ map (+ (Int Int) Int)) ((_ map (- (Int Int) Int)) (store base "m" n1) ((_ map (+ (Int Int) Int)) (store base "s" n1) (store base "s" n1))) (store base "kg" n1))) ] [[WD] irred_acEw {0}:: ((Base
                                                                                                                                                                                                                                                                                                                                                                                    "kg"
                                                                                                                                                                                                                                                                                                                                                                                  *: Base
                                                                                                                                                                                                                                                                                                                                                                                       "m")
                                                                                                                                                                                                                                                                                                                                                                                 /: (Base
                                                                                                                                                                                                                                                                                                                                                                                       "s"
                                                                                                                                                                                                                                                                                                                                                                                     *: Base
                                                                                                                                                                                                                                                                                                                                                                                          "s"))
                                                                                                                                                                                                                                                                                                                                                                                Data.UnitsOfMeasure.Syntax.~~ ((Base
                                                                                                                                                                                                                                                                                                                                                                                                                  "m"
                                                                                                                                                                                                                                                                                                                                                                                                                /: (Base
                                                                                                                                                                                                                                                                                                                                                                                                                      "s"
                                                                                                                                                                                                                                                                                                                                                                                                                    *: Base
                                                                                                                                                                                                                                                                                                                                                                                                                         "s"))
                                                                                                                                                                                                                                                                                                                                                                                                               *: Base
                                                                                                                                                                                                                                                                                                                                                                                                                    "kg") (CNonCanonical)] []
thoralf-solve decls []
thoralf-solve decls filtered []
thoralf-solve givens []
thoralf-solve givens filtered []
thoralf-solve wanteds
  [[WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve wanteds filtered
  [[WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve simplified given sexprs []
thoralf-solve simplified wanteds []
tcPluginSolve ok thoralf-uom-plugin
  solved = []
  new    = []
tcPluginSolve start uom-eq-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok uom-eq-plugin
  solved = []
  new    = [[WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                   /: (Base "s" *: Base "s"))
                                  Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                  /: (Base "s" *: Base "s"))
                                                                 *: Base "kg") (CNonCanonical)]
tcPluginSolve start uom-unpack-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok uom-unpack-plugin
  solved = []
  new    = []
solveSimple going round again:
  0
  True
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                     /: (Base "s" *: Base "s"))
                                    Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                    /: (Base "s" *: Base "s"))
                                                                   *: Base "kg") (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] irred_acEw {0}:: ((Base "kg"
                                                           *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                       /: (Base "s" *: Base "s"))
                                      Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                      /: (Base "s" *: Base "s"))
                                                                     *: Base "kg") (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                         /: (Base "s" *: Base "s"))
                        Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                       *: Base "kg") (CNonCanonical)
canEvNC:irred
  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                 *: Base "kg")
can_pred
  IrredPred =  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
               Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                              *: Base "kg")
flatten {
  FM_FlattenAll ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                               *: Base "kg")
matchFamTcM
  Matching: ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
            Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                           *: Base "kg")
  Match failed
matchFamTcM
  Matching: (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "kg" *: Base "m"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
New coercion hole: acEz
Emitting new coercion hole
  {acEz} :: (Base "kg" :: Unit) GHC.Prim.~# (s0_acEy[fuv:0] :: Unit)
extendFlatCache
  Base ["kg"]
  [WD]
  s0_acEy[fuv:0]
flatten/flat-cache miss
  Base ["kg"]
  s_acEy[fuv:0]
  [WD] hole{acEz} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (s0_acEy[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "m"
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
New coercion hole: acEB
Emitting new coercion hole
  {acEB} :: (Base "m" :: Unit) GHC.Prim.~# (s0_acEA[fuv:0] :: Unit)
extendFlatCache
  Base ["m"]
  [WD]
  s0_acEA[fuv:0]
flatten/flat-cache miss
  Base ["m"]
  s_acEA[fuv:0]
  [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                        GHC.Prim.~#
                        (s0_acEA[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acEy[fuv:0] *: s1_acEA[fuv:0]
  Match failed
New coercion hole: acED
Emitting new coercion hole
  {acED} :: ((s0_acEy[fuv:0] *: s1_acEA[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acEC[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acEy[fuv:0], s0_acEA[fuv:0]]
  [WD]
  s0_acEC[fuv:0]
flatten/flat-cache miss
  *: [s0_acEy[fuv:0], s0_acEA[fuv:0]]
  s_acEC[fuv:0]
  [WD] hole{acED} {0}:: ((s0_acEy[fuv:0] *: s1_acEA[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEC[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
New coercion hole: acEF
Emitting new coercion hole
  {acEF} :: (Base "s" :: Unit) GHC.Prim.~# (s0_acEE[fuv:0] :: Unit)
extendFlatCache
  Base ["s"]
  [WD]
  s0_acEE[fuv:0]
flatten/flat-cache miss
  Base ["s"]
  s_acEE[fuv:0]
  [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                        GHC.Prim.~#
                        (s0_acEE[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEE[fuv:0]
Unfilled tyvar s_acEE[fuv:0]
matchFamTcM
  Matching: s0_acEE[fuv:0] *: s0_acEE[fuv:0]
  Match failed
New coercion hole: acEH
Emitting new coercion hole
  {acEH} :: ((s0_acEE[fuv:0] *: s0_acEE[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s1_acEG[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acEE[fuv:0], s0_acEE[fuv:0]]
  [WD]
  s0_acEG[fuv:0]
flatten/flat-cache miss
  *: [s0_acEE[fuv:0], s0_acEE[fuv:0]]
  s_acEG[fuv:0]
  [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0] *: s0_acEE[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s1_acEG[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acEC[fuv:0] /: s1_acEG[fuv:0]
  Match failed
New coercion hole: acEJ
Emitting new coercion hole
  {acEJ} :: ((s0_acEC[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acEI[fuv:0] :: Unit)
extendFlatCache
  /: [s0_acEC[fuv:0], s0_acEG[fuv:0]]
  [WD]
  s0_acEI[fuv:0]
flatten/flat-cache miss
  /: [s0_acEC[fuv:0], s0_acEG[fuv:0]]
  s_acEI[fuv:0]
  [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEI[fuv:0] :: Unit)
matchFamTcM
  Matching: (Base "m" /: (Base "s" *: Base "s")) *: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "m" /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acEA[fuv:0]
Unfilled tyvar s_acEA[fuv:0]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEE[fuv:0]
Unfilled tyvar s_acEE[fuv:0]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEE[fuv:0]
Unfilled tyvar s_acEE[fuv:0]
flatten/flat-cache hit
  *: [s0_acEE[fuv:0], s0_acEE[fuv:0]]
  s0_acEG[fuv:0]
Unfilled tyvar s_acEG[fuv:0]
matchFamTcM
  Matching: s0_acEA[fuv:0] /: s1_acEG[fuv:0]
  Match failed
New coercion hole: acEL
Emitting new coercion hole
  {acEL} :: ((s0_acEA[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acEK[fuv:0] :: Unit)
extendFlatCache
  /: [s0_acEA[fuv:0], s0_acEG[fuv:0]]
  [WD]
  s0_acEK[fuv:0]
flatten/flat-cache miss
  /: [s0_acEA[fuv:0], s0_acEG[fuv:0]]
  s_acEK[fuv:0]
  [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEK[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acEy[fuv:0]
Unfilled tyvar s_acEy[fuv:0]
matchFamTcM
  Matching: s0_acEK[fuv:0] *: s1_acEy[fuv:0]
  Match failed
New coercion hole: acEN
Emitting new coercion hole
  {acEN} :: ((s0_acEK[fuv:0] *: s1_acEy[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acEM[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acEK[fuv:0], s0_acEy[fuv:0]]
  [WD]
  s0_acEM[fuv:0]
flatten/flat-cache miss
  *: [s0_acEK[fuv:0], s0_acEy[fuv:0]]
  s_acEM[fuv:0]
  [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0] *: s1_acEy[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEM[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acEI[fuv:0]
            Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]
  Match failed
New coercion hole: acEP
Emitting new coercion hole
  {acEP} :: ((s0_acEI[fuv:0]
              Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
            GHC.Prim.~#
            (s2_acEO[fuv:0] :: Constraint)
extendFlatCache
  Data.UnitsOfMeasure.Syntax.~~ [s0_acEI[fuv:0], s0_acEM[fuv:0]]
  [WD]
  s0_acEO[fuv:0]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Syntax.~~ [s0_acEI[fuv:0], s0_acEM[fuv:0]]
  s_acEO[fuv:0]
  [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                          Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                        GHC.Prim.~#
                        (s2_acEO[fuv:0] :: Constraint)
flatten } s0_acEO[fuv:0]
Emitting new wanted
  irred_acEQ :: s0_acEO[fuv:0]
  arising from a use of ‘*:’ at test-suite-force/Tests.hs:49:17-40
addTcEvBind
  acC4
  [W] irred_acEw
    = irred_acEQ `cast` (Sub
                           (Sym
                              U(hole:{acEP}, s0_acEI[fuv:0]
                                             Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0], s0_acEO[fuv:0])_N
                            ; (Trans
                                   (Sym {acEJ})
                                   (Trans (Sym {acED}) (Sym {acEz} *: Sym {acEB})_N
                                    /: Trans (Sym {acEH}) (Sym {acEF} *: Sym {acEF})_N)_N
                               Data.UnitsOfMeasure.Syntax.~~ Trans
                                                                 (Sym {acEN})
                                                                 (Trans
                                                                      (Sym {acEL})
                                                                      (Sym {acEB}
                                                                       /: Trans
                                                                              (Sym {acEH})
                                                                              (Sym {acEF}
                                                                               *: Sym {acEF})_N)_N
                                                                  *: Sym {acEz})_N)_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
doTopReact [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
addInertCan }
Step 108[l:1,d:0] Kept as inert:
    [WD] irred_acEQ {0}:: s0_acEO[fuv:0]
End solver pipeline (kept as inert) }
  final_item = [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEz} {0}:: (Base "kg" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Irreds = [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEB} {0}:: (Base
                                                           "m" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acED} {0}:: ((s0_acEy[fuv:0] *: s1_acEA[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0] *: s0_acEE[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0] *: s1_acEy[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEz} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "kg"
flatten } "kg"
extendFlatCache
  Base ["kg"]
  [WD]
  s0_acEy[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEz} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEz} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEz} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "kg"
  Match failed
improveTopFunEqs
  Base ["kg"] s_acEy[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEz} {0}:: (Base
                                                                   "kg" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 109[l:1,d:0] Kept as inert:
    [WD] hole{acEz} {0}:: (Base "kg" :: Unit)
                          GHC.Prim.~#
                          (s0_acEy[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEz} {0}:: (Base "kg" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEz} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                                          *: s1_acEA[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0] *: s0_acEE[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0] *: s1_acEy[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "m"
flatten } "m"
extendFlatCache
  Base ["m"]
  [WD]
  s0_acEA[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                        GHC.Prim.~#
                        (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "m"
  Match failed
improveTopFunEqs
  Base ["m"] s_acEA[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEB} {0}:: (Base
                                                                   "m" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 110[l:1,d:0] Kept as inert:
    [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                          GHC.Prim.~#
                          (s0_acEA[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                      *: s1_acEA[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEz} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEF} {0}:: (Base
                                                           "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0] *: s0_acEE[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0] *: s1_acEy[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                        *: s1_acEA[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEy[fuv:0]
  s0_acEA[fuv:0]
Unfilled tyvar s_acEy[fuv:0]
Unfilled tyvar s_acEA[fuv:0]
flatten }
  s0_acEy[fuv:0]
  s0_acEA[fuv:0]
extendFlatCache
  *: [s0_acEy[fuv:0], s0_acEA[fuv:0]]
  [WD]
  s0_acEC[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                        *: s1_acEA[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                        *: s1_acEA[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acED} {0}:: ((s0_acEy[fuv:0] *: s1_acEA[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEy[fuv:0] *: s1_acEA[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acEy[fuv:0], s0_acEA[fuv:0]] s_acEC[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                                                  *: s1_acEA[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 111[l:1,d:0] Kept as inert:
    [WD] hole{acED} {0}:: ((s0_acEy[fuv:0] *: s1_acEA[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acEC[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                       *: s1_acEA[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEz} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                                               *: s1_acEA[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                                          *: s0_acEE[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0] *: s1_acEy[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "s"
flatten } "s"
extendFlatCache
  Base ["s"]
  [WD]
  s0_acEE[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                        GHC.Prim.~#
                        (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "s"
  Match failed
improveTopFunEqs
  Base ["s"] s_acEE[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEF} {0}:: (Base
                                                                   "s" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 112[l:1,d:0] Kept as inert:
    [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                          GHC.Prim.~#
                          (s0_acEE[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                      *: s0_acEE[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                                               *: s1_acEA[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEz} {0}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0]
                                                          /: s1_acEG[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0] *: s1_acEy[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                        *: s0_acEE[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEE[fuv:0]
  s0_acEE[fuv:0]
Unfilled tyvar s_acEE[fuv:0]
Unfilled tyvar s_acEE[fuv:0]
flatten }
  s0_acEE[fuv:0]
  s0_acEE[fuv:0]
extendFlatCache
  *: [s0_acEE[fuv:0], s0_acEE[fuv:0]]
  [WD]
  s0_acEG[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                        *: s0_acEE[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                        *: s0_acEE[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0] *: s0_acEE[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEE[fuv:0] *: s0_acEE[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acEE[fuv:0], s0_acEE[fuv:0]] s_acEG[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                                                  *: s0_acEE[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 113[l:1,d:0] Kept as inert:
    [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0] *: s0_acEE[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s1_acEG[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                       *: s0_acEE[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0]
                                      /: s1_acEG[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEz} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                                               *: s1_acEA[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                                               *: s0_acEE[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0]
                                                          /: s1_acEG[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0] *: s1_acEy[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0]
                                        /: s1_acEG[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEC[fuv:0]
  s0_acEG[fuv:0]
Unfilled tyvar s_acEC[fuv:0]
Unfilled tyvar s_acEG[fuv:0]
flatten }
  s0_acEC[fuv:0]
  s0_acEG[fuv:0]
extendFlatCache
  /: [s0_acEC[fuv:0], s0_acEG[fuv:0]]
  [WD]
  s0_acEI[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0]
                                        /: s1_acEG[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0]
                                        /: s1_acEG[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEC[fuv:0] /: s1_acEG[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acEC[fuv:0], s0_acEG[fuv:0]] s_acEI[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0]
                                                                  /: s1_acEG[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 114[l:1,d:0] Kept as inert:
    [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acEI[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0]
                                       /: s1_acEG[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0]
                                      /: s1_acEG[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEz} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                                               *: s1_acEA[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                                               *: s0_acEE[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0]
                                                               /: s1_acEG[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0]
                                                          *: s1_acEy[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0]
                                        /: s1_acEG[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEA[fuv:0]
  s0_acEG[fuv:0]
Unfilled tyvar s_acEA[fuv:0]
Unfilled tyvar s_acEG[fuv:0]
flatten }
  s0_acEA[fuv:0]
  s0_acEG[fuv:0]
extendFlatCache
  /: [s0_acEA[fuv:0], s0_acEG[fuv:0]]
  [WD]
  s0_acEK[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0]
                                        /: s1_acEG[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0]
                                        /: s1_acEG[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEA[fuv:0] /: s1_acEG[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acEA[fuv:0], s0_acEG[fuv:0]] s_acEK[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0]
                                                                  /: s1_acEG[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 115[l:1,d:0] Kept as inert:
    [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acEK[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0]
                                       /: s1_acEG[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0]
                                      *: s1_acEy[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEz} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                                               *: s1_acEA[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                                               *: s0_acEE[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0]
                                                               /: s1_acEG[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0]
                                                               /: s1_acEG[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0]
                                        *: s1_acEy[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEK[fuv:0]
  s0_acEy[fuv:0]
Unfilled tyvar s_acEK[fuv:0]
Unfilled tyvar s_acEy[fuv:0]
flatten }
  s0_acEK[fuv:0]
  s0_acEy[fuv:0]
extendFlatCache
  *: [s0_acEK[fuv:0], s0_acEy[fuv:0]]
  [WD]
  s0_acEM[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0]
                                        *: s1_acEy[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0]
                                        *: s1_acEy[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0] *: s1_acEy[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEK[fuv:0] *: s1_acEy[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acEK[fuv:0], s0_acEy[fuv:0]] s_acEM[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0]
                                                                  *: s1_acEy[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 116[l:1,d:0] Kept as inert:
    [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0] *: s1_acEy[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acEM[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0]
                                       *: s1_acEy[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                      Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                    GHC.Prim.~#
                                    (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEz} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0]
                                                               /: s1_acEG[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0]
                                                               /: s1_acEG[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                                               *: s1_acEA[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                                               *: s0_acEE[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0]
                                                               *: s1_acEy[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] irred_acEw {0}:: ((Base "kg"
                                                           *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                        Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
flatten_many {
  s0_acEI[fuv:0]
  s0_acEM[fuv:0]
Unfilled tyvar s_acEI[fuv:0]
Unfilled tyvar s_acEM[fuv:0]
flatten }
  s0_acEI[fuv:0]
  s0_acEM[fuv:0]
extendFlatCache
  Data.UnitsOfMeasure.Syntax.~~ [s0_acEI[fuv:0], s0_acEM[fuv:0]]
  [WD]
  s0_acEO[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                        Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                        Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
doTopReact
  [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                          Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                        GHC.Prim.~#
                        (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
matchFamTcM
  Matching: s0_acEI[fuv:0]
            Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]
  Match failed
improveTopFunEqs
  Data.UnitsOfMeasure.Syntax.~~ [s0_acEI[fuv:0],
                                 s0_acEM[fuv:0]] s_acEO[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                                                  Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                                                GHC.Prim.~#
                                                                (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
addInertCan }
Step 117[l:1,d:0] Kept as inert:
    [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                            Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                          GHC.Prim.~#
                          (s2_acEO[fuv:0] :: Constraint)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                       Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                     GHC.Prim.~#
                                     (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                     /: (Base "s" *: Base "s"))
                                    Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                    /: (Base "s" *: Base "s"))
                                                                   *: Base "kg") (CNonCanonical)
  inerts = {Type-function equalities = [WD] hole{acEz} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0]
                                                               /: s1_acEG[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0]
                                                               /: s1_acEG[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                                               *: s1_acEA[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                                               *: s0_acEE[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0]
                                                               *: s1_acEy[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                                               Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                                       /: (Base "s" *: Base "s"))
                                      Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                      /: (Base "s" *: Base "s"))
                                                                     *: Base "kg") (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_acEw {0}:: ((Base "kg" *: Base "m")
                         /: (Base "s" *: Base "s"))
                        Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                       *: Base "kg") (CNonCanonical)
canEvNC:irred
  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                 *: Base "kg")
can_pred
  IrredPred =  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
               Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                              *: Base "kg")
flatten {
  FM_FlattenAll ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                               *: Base "kg")
matchFamTcM
  Matching: ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
            Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                           *: Base "kg")
  Match failed
matchFamTcM
  Matching: (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "kg" *: Base "m"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acEy[fuv:0]
Unfilled tyvar s_acEy[fuv:0]
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acEA[fuv:0]
Unfilled tyvar s_acEA[fuv:0]
flatten/flat-cache hit
  *: [s0_acEy[fuv:0], s0_acEA[fuv:0]]
  s0_acEC[fuv:0]
Unfilled tyvar s_acEC[fuv:0]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEE[fuv:0]
Unfilled tyvar s_acEE[fuv:0]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEE[fuv:0]
Unfilled tyvar s_acEE[fuv:0]
flatten/flat-cache hit
  *: [s0_acEE[fuv:0], s0_acEE[fuv:0]]
  s0_acEG[fuv:0]
Unfilled tyvar s_acEG[fuv:0]
flatten/flat-cache hit
  /: [s0_acEC[fuv:0], s0_acEG[fuv:0]]
  s0_acEI[fuv:0]
Unfilled tyvar s_acEI[fuv:0]
matchFamTcM
  Matching: (Base "m" /: (Base "s" *: Base "s")) *: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "m" /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acEA[fuv:0]
Unfilled tyvar s_acEA[fuv:0]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEE[fuv:0]
Unfilled tyvar s_acEE[fuv:0]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEE[fuv:0]
Unfilled tyvar s_acEE[fuv:0]
flatten/flat-cache hit
  *: [s0_acEE[fuv:0], s0_acEE[fuv:0]]
  s0_acEG[fuv:0]
Unfilled tyvar s_acEG[fuv:0]
flatten/flat-cache hit
  /: [s0_acEA[fuv:0], s0_acEG[fuv:0]]
  s0_acEK[fuv:0]
Unfilled tyvar s_acEK[fuv:0]
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acEy[fuv:0]
Unfilled tyvar s_acEy[fuv:0]
flatten/flat-cache hit
  *: [s0_acEK[fuv:0], s0_acEy[fuv:0]]
  s0_acEM[fuv:0]
Unfilled tyvar s_acEM[fuv:0]
flatten/flat-cache hit
  Data.UnitsOfMeasure.Syntax.~~ [s0_acEI[fuv:0], s0_acEM[fuv:0]]
  s0_acEO[fuv:0]
Unfilled tyvar s_acEO[fuv:0]
flatten } s0_acEO[fuv:0]
Emitting new wanted
  irred_acER :: s0_acEO[fuv:0]
  arising from a use of ‘*:’ at test-suite-force/Tests.hs:49:17-40
addTcEvBind
  acC4
  [W] irred_acEw
    = irred_acER `cast` (Sub
                           (Sym
                              U(hole:{acEP}, s0_acEI[fuv:0]
                                             Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0], s0_acEO[fuv:0])_N
                            ; (Trans
                                   (Sym {acEJ})
                                   (Trans (Sym {acED}) (Sym {acEz} *: Sym {acEB})_N
                                    /: Trans (Sym {acEH}) (Sym {acEF} *: Sym {acEF})_N)_N
                               Data.UnitsOfMeasure.Syntax.~~ Trans
                                                                 (Sym {acEN})
                                                                 (Trans
                                                                      (Sym {acEL})
                                                                      (Sym {acEB}
                                                                       /: Trans
                                                                              (Sym {acEH})
                                                                              (Sym {acEF}
                                                                               *: Sym {acEF})_N)_N
                                                                  *: Sym {acEz})_N)_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_acER {0}:: s0_acEO[fuv:0] (CIrredEvCan)
addTcEvBind
  acC4
  [W] irred_acER = irred_acEQ
end stage interact with inerts }
Step 118[l:1,d:0] Irred equal (keep):
    [WD] irred_acER {0}:: s0_acEO[fuv:0]
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
  inerts = {Type-function equalities = [WD] hole{acEz} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0]
                                                               /: s1_acEG[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0]
                                                               /: s1_acEG[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acED} {0}:: ((s0_acEy[fuv:0]
                                                               *: s1_acEA[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0]
                                                               *: s0_acEE[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0]
                                                               *: s1_acEy[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                                               Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
flatten_many {
  "callStack"
  GHC.Stack.Types.CallStack
flatten }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
doTopReact
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
matchClassInst pred = ?callStack::GHC.Stack.Types.CallStack {
matchClass not matching dict ?callStack::GHC.Stack.Types.CallStack
} matchClassInst result NoInstance
try_fundeps
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
addInertCan }
Step 119[l:1,d:0] Kept as inert:
    [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (kept as inert) }
  final_item = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {[WD] hole{acEz} {0}:: (Base "kg" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acEy[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acEA[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acEE[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acEI[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acEK[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acED} {0}:: ((s0_acEy[fuv:0] *: s1_acEA[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acEC[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0] *: s0_acEE[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s1_acEG[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0] *: s1_acEy[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acEM[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                     Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                   GHC.Prim.~#
                                   (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)}
  insols = {}
  others = {[WD] irred_acEQ {0}:: s0_acEO[fuv:0] (CIrredEvCan),
            [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{acEz} {0}:: (Base "kg" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acEy[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEB} {0}:: (Base "m" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acEA[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEF} {0}:: (Base "s" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acEE[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEJ} {0}:: ((s0_acEC[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acEI[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEL} {0}:: ((s0_acEA[fuv:0] /: s1_acEG[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acEK[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acED} {0}:: ((s0_acEy[fuv:0] *: s1_acEA[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acEC[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEH} {0}:: ((s0_acEE[fuv:0] *: s0_acEE[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s1_acEG[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEN} {0}:: ((s0_acEK[fuv:0] *: s1_acEy[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acEM[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEP} {0}:: ((s0_acEI[fuv:0]
                                    Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]) :: Constraint)
                                  GHC.Prim.~#
                                  (s2_acEO[fuv:0] :: Constraint) (CFunEqCan)
   Tv eqs =}
Filling coercion hole
  acEP := <s0_acEI[fuv:0]
           Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]>_N
unflattenFmv
  s_acEO[fuv:0] := s0_acEI[fuv:0]
                   Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]
writeMetaTyVar
  s_acEO[fuv:0] :: Constraint := s0_acEI[fuv:0]
                                 Data.UnitsOfMeasure.Syntax.~~ s1_acEM[fuv:0]
Filling coercion hole acEN := <s0_acEK[fuv:0] *: s1_acEy[fuv:0]>_N
unflattenFmv s_acEM[fuv:0] := s0_acEK[fuv:0] *: s1_acEy[fuv:0]
writeMetaTyVar
  s_acEM[fuv:0] :: Unit := s0_acEK[fuv:0] *: s1_acEy[fuv:0]
Filling coercion hole acEH := <s0_acEE[fuv:0] *: s0_acEE[fuv:0]>_N
unflattenFmv s_acEG[fuv:0] := s0_acEE[fuv:0] *: s0_acEE[fuv:0]
writeMetaTyVar
  s_acEG[fuv:0] :: Unit := s0_acEE[fuv:0] *: s0_acEE[fuv:0]
Filling coercion hole acED := <s0_acEy[fuv:0] *: s1_acEA[fuv:0]>_N
unflattenFmv s_acEC[fuv:0] := s0_acEy[fuv:0] *: s1_acEA[fuv:0]
writeMetaTyVar
  s_acEC[fuv:0] :: Unit := s0_acEy[fuv:0] *: s1_acEA[fuv:0]
Filling coercion hole
  acEL := <s0_acEA[fuv:0] /: (s1_acEE[fuv:0] *: s1_acEE[fuv:0])>_N
unflattenFmv
  s_acEK[fuv:0] := s0_acEA[fuv:0]
                   /: (s1_acEE[fuv:0] *: s1_acEE[fuv:0])
writeMetaTyVar
  s_acEK[fuv:0] :: Unit := s0_acEA[fuv:0]
                           /: (s1_acEE[fuv:0] *: s1_acEE[fuv:0])
Filling coercion hole
  acEJ := <(s0_acEy[fuv:0] *: s1_acEA[fuv:0])
           /: (s2_acEE[fuv:0] *: s2_acEE[fuv:0])>_N
unflattenFmv
  s_acEI[fuv:0] := (s0_acEy[fuv:0] *: s1_acEA[fuv:0])
                   /: (s2_acEE[fuv:0] *: s2_acEE[fuv:0])
writeMetaTyVar
  s_acEI[fuv:0] :: Unit := (s0_acEy[fuv:0] *: s1_acEA[fuv:0])
                           /: (s2_acEE[fuv:0] *: s2_acEE[fuv:0])
Filling coercion hole acEF := <Base "s">_N
unflattenFmv s_acEE[fuv:0] := Base "s"
writeMetaTyVar s_acEE[fuv:0] :: Unit := Base "s"
Filling coercion hole acEB := <Base "m">_N
unflattenFmv s_acEA[fuv:0] := Base "m"
writeMetaTyVar s_acEA[fuv:0] :: Unit := Base "m"
Filling coercion hole acEz := <Base "kg">_N
unflattenFmv s_acEy[fuv:0] := Base "kg"
writeMetaTyVar s_acEy[fuv:0] :: Unit := Base "kg"
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
zonkSimples done: {}
zonkSimples done:
  {[WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
tcPluginSolve start thoralf-uom-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve gsConvCts Just [ ] [] []
thoralf-solve wsConvCts
  Just [ (= ((_ map (- (Int Int) Int)) ((_ map (+ (Int Int) Int)) (store base "kg" n1) (store base "m" n1)) ((_ map (+ (Int Int) Int)) (store base "s" n1) (store base "s" n1))) ((_ map (+ (Int Int) Int)) ((_ map (- (Int Int) Int)) (store base "m" n1) ((_ map (+ (Int Int) Int)) (store base "s" n1) (store base "s" n1))) (store base "kg" n1))) ] [[WD] irred_acEQ {0}:: ((Base
                                                                                                                                                                                                                                                                                                                                                                                    "kg"
                                                                                                                                                                                                                                                                                                                                                                                  *: Base
                                                                                                                                                                                                                                                                                                                                                                                       "m")
                                                                                                                                                                                                                                                                                                                                                                                 /: (Base
                                                                                                                                                                                                                                                                                                                                                                                       "s"
                                                                                                                                                                                                                                                                                                                                                                                     *: Base
                                                                                                                                                                                                                                                                                                                                                                                          "s"))
                                                                                                                                                                                                                                                                                                                                                                                Data.UnitsOfMeasure.Syntax.~~ ((Base
                                                                                                                                                                                                                                                                                                                                                                                                                  "m"
                                                                                                                                                                                                                                                                                                                                                                                                                /: (Base
                                                                                                                                                                                                                                                                                                                                                                                                                      "s"
                                                                                                                                                                                                                                                                                                                                                                                                                    *: Base
                                                                                                                                                                                                                                                                                                                                                                                                                         "s"))
                                                                                                                                                                                                                                                                                                                                                                                                               *: Base
                                                                                                                                                                                                                                                                                                                                                                                                                    "kg") (CNonCanonical)] []
thoralf-solve decls []
thoralf-solve decls filtered []
thoralf-solve givens []
thoralf-solve givens filtered []
thoralf-solve wanteds
  [[WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve wanteds filtered
  [[WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve simplified given sexprs []
thoralf-solve simplified wanteds []
tcPluginSolve ok thoralf-uom-plugin
  solved = []
  new    = []
tcPluginSolve start uom-eq-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok uom-eq-plugin
  solved = []
  new    = [[WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                   /: (Base "s" *: Base "s"))
                                  Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                  /: (Base "s" *: Base "s"))
                                                                 *: Base "kg") (CNonCanonical)]
tcPluginSolve start uom-unpack-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok uom-unpack-plugin
  solved = []
  new    = []
solveSimple going round again:
  0
  True
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                     /: (Base "s" *: Base "s"))
                                    Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                    /: (Base "s" *: Base "s"))
                                                                   *: Base "kg") (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] irred_acEQ {0}:: ((Base "kg"
                                                           *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                       /: (Base "s" *: Base "s"))
                                      Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                      /: (Base "s" *: Base "s"))
                                                                     *: Base "kg") (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                         /: (Base "s" *: Base "s"))
                        Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                       *: Base "kg") (CNonCanonical)
canEvNC:irred
  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                 *: Base "kg")
can_pred
  IrredPred =  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
               Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                              *: Base "kg")
flatten {
  FM_FlattenAll ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                               *: Base "kg")
matchFamTcM
  Matching: ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
            Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                           *: Base "kg")
  Match failed
matchFamTcM
  Matching: (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "kg" *: Base "m"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
New coercion hole: acET
Emitting new coercion hole
  {acET} :: (Base "kg" :: Unit) GHC.Prim.~# (s0_acES[fuv:0] :: Unit)
extendFlatCache
  Base ["kg"]
  [WD]
  s0_acES[fuv:0]
flatten/flat-cache miss
  Base ["kg"]
  s_acES[fuv:0]
  [WD] hole{acET} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (s0_acES[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "m"
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
New coercion hole: acEV
Emitting new coercion hole
  {acEV} :: (Base "m" :: Unit) GHC.Prim.~# (s0_acEU[fuv:0] :: Unit)
extendFlatCache
  Base ["m"]
  [WD]
  s0_acEU[fuv:0]
flatten/flat-cache miss
  Base ["m"]
  s_acEU[fuv:0]
  [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                        GHC.Prim.~#
                        (s0_acEU[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acES[fuv:0] *: s1_acEU[fuv:0]
  Match failed
New coercion hole: acEX
Emitting new coercion hole
  {acEX} :: ((s0_acES[fuv:0] *: s1_acEU[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acEW[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acES[fuv:0], s0_acEU[fuv:0]]
  [WD]
  s0_acEW[fuv:0]
flatten/flat-cache miss
  *: [s0_acES[fuv:0], s0_acEU[fuv:0]]
  s_acEW[fuv:0]
  [WD] hole{acEX} {0}:: ((s0_acES[fuv:0] *: s1_acEU[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEW[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
New coercion hole: acEZ
Emitting new coercion hole
  {acEZ} :: (Base "s" :: Unit) GHC.Prim.~# (s0_acEY[fuv:0] :: Unit)
extendFlatCache
  Base ["s"]
  [WD]
  s0_acEY[fuv:0]
flatten/flat-cache miss
  Base ["s"]
  s_acEY[fuv:0]
  [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                        GHC.Prim.~#
                        (s0_acEY[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEY[fuv:0]
Unfilled tyvar s_acEY[fuv:0]
matchFamTcM
  Matching: s0_acEY[fuv:0] *: s0_acEY[fuv:0]
  Match failed
New coercion hole: acF1
Emitting new coercion hole
  {acF1} :: ((s0_acEY[fuv:0] *: s0_acEY[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s1_acF0[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acEY[fuv:0], s0_acEY[fuv:0]]
  [WD]
  s0_acF0[fuv:0]
flatten/flat-cache miss
  *: [s0_acEY[fuv:0], s0_acEY[fuv:0]]
  s_acF0[fuv:0]
  [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0] *: s0_acEY[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s1_acF0[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acEW[fuv:0] /: s1_acF0[fuv:0]
  Match failed
New coercion hole: acF3
Emitting new coercion hole
  {acF3} :: ((s0_acEW[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acF2[fuv:0] :: Unit)
extendFlatCache
  /: [s0_acEW[fuv:0], s0_acF0[fuv:0]]
  [WD]
  s0_acF2[fuv:0]
flatten/flat-cache miss
  /: [s0_acEW[fuv:0], s0_acF0[fuv:0]]
  s_acF2[fuv:0]
  [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acF2[fuv:0] :: Unit)
matchFamTcM
  Matching: (Base "m" /: (Base "s" *: Base "s")) *: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "m" /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acEU[fuv:0]
Unfilled tyvar s_acEU[fuv:0]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEY[fuv:0]
Unfilled tyvar s_acEY[fuv:0]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEY[fuv:0]
Unfilled tyvar s_acEY[fuv:0]
flatten/flat-cache hit
  *: [s0_acEY[fuv:0], s0_acEY[fuv:0]]
  s0_acF0[fuv:0]
Unfilled tyvar s_acF0[fuv:0]
matchFamTcM
  Matching: s0_acEU[fuv:0] /: s1_acF0[fuv:0]
  Match failed
New coercion hole: acF5
Emitting new coercion hole
  {acF5} :: ((s0_acEU[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acF4[fuv:0] :: Unit)
extendFlatCache
  /: [s0_acEU[fuv:0], s0_acF0[fuv:0]]
  [WD]
  s0_acF4[fuv:0]
flatten/flat-cache miss
  /: [s0_acEU[fuv:0], s0_acF0[fuv:0]]
  s_acF4[fuv:0]
  [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acF4[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acES[fuv:0]
Unfilled tyvar s_acES[fuv:0]
matchFamTcM
  Matching: s0_acF4[fuv:0] *: s1_acES[fuv:0]
  Match failed
New coercion hole: acF7
Emitting new coercion hole
  {acF7} :: ((s0_acF4[fuv:0] *: s1_acES[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acF6[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acF4[fuv:0], s0_acES[fuv:0]]
  [WD]
  s0_acF6[fuv:0]
flatten/flat-cache miss
  *: [s0_acF4[fuv:0], s0_acES[fuv:0]]
  s_acF6[fuv:0]
  [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0] *: s1_acES[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acF6[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acF2[fuv:0]
            Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]
  Match failed
New coercion hole: acF9
Emitting new coercion hole
  {acF9} :: ((s0_acF2[fuv:0]
              Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
            GHC.Prim.~#
            (s2_acF8[fuv:0] :: Constraint)
extendFlatCache
  Data.UnitsOfMeasure.Syntax.~~ [s0_acF2[fuv:0], s0_acF6[fuv:0]]
  [WD]
  s0_acF8[fuv:0]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Syntax.~~ [s0_acF2[fuv:0], s0_acF6[fuv:0]]
  s_acF8[fuv:0]
  [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                          Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                        GHC.Prim.~#
                        (s2_acF8[fuv:0] :: Constraint)
flatten } s0_acF8[fuv:0]
Emitting new wanted
  irred_acFa :: s0_acF8[fuv:0]
  arising from a use of ‘*:’ at test-suite-force/Tests.hs:49:17-40
addTcEvBind
  acC4
  [W] irred_acEQ
    = irred_acFa `cast` (Sub
                           (Sym
                              U(hole:{acF9}, s0_acF2[fuv:0]
                                             Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0], s0_acF8[fuv:0])_N
                            ; (Trans
                                   (Sym {acF3})
                                   (Trans (Sym {acEX}) (Sym {acET} *: Sym {acEV})_N
                                    /: Trans (Sym {acF1}) (Sym {acEZ} *: Sym {acEZ})_N)_N
                               Data.UnitsOfMeasure.Syntax.~~ Trans
                                                                 (Sym {acF7})
                                                                 (Trans
                                                                      (Sym {acF5})
                                                                      (Sym {acEV}
                                                                       /: Trans
                                                                              (Sym {acF1})
                                                                              (Sym {acEZ}
                                                                               *: Sym {acEZ})_N)_N
                                                                  *: Sym {acET})_N)_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
doTopReact [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
addInertCan }
Step 120[l:1,d:0] Kept as inert:
    [WD] irred_acFa {0}:: s0_acF8[fuv:0]
End solver pipeline (kept as inert) }
  final_item = [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acET} {0}:: (Base "kg" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acES[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Irreds = [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEV} {0}:: (Base
                                                           "m" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEX} {0}:: ((s0_acES[fuv:0] *: s1_acEU[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0] *: s0_acEY[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0] *: s1_acES[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acET} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acES[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "kg"
flatten } "kg"
extendFlatCache
  Base ["kg"]
  [WD]
  s0_acES[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acET} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acES[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acET} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acES[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acET} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (s0_acES[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "kg"
  Match failed
improveTopFunEqs
  Base ["kg"] s_acES[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acET} {0}:: (Base
                                                                   "kg" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acES[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 121[l:1,d:0] Kept as inert:
    [WD] hole{acET} {0}:: (Base "kg" :: Unit)
                          GHC.Prim.~#
                          (s0_acES[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acET} {0}:: (Base "kg" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acES[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acET} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acES[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                                          *: s1_acEU[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0] *: s0_acEY[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0] *: s1_acES[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "m"
flatten } "m"
extendFlatCache
  Base ["m"]
  [WD]
  s0_acEU[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                        GHC.Prim.~#
                        (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "m"
  Match failed
improveTopFunEqs
  Base ["m"] s_acEU[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEV} {0}:: (Base
                                                                   "m" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 122[l:1,d:0] Kept as inert:
    [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                          GHC.Prim.~#
                          (s0_acEU[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                      *: s1_acEU[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acET} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acES[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acEZ} {0}:: (Base
                                                           "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0] *: s0_acEY[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0] *: s1_acES[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                        *: s1_acEU[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acES[fuv:0]
  s0_acEU[fuv:0]
Unfilled tyvar s_acES[fuv:0]
Unfilled tyvar s_acEU[fuv:0]
flatten }
  s0_acES[fuv:0]
  s0_acEU[fuv:0]
extendFlatCache
  *: [s0_acES[fuv:0], s0_acEU[fuv:0]]
  [WD]
  s0_acEW[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                        *: s1_acEU[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                        *: s1_acEU[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEX} {0}:: ((s0_acES[fuv:0] *: s1_acEU[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acES[fuv:0] *: s1_acEU[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acES[fuv:0], s0_acEU[fuv:0]] s_acEW[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                                                  *: s1_acEU[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 123[l:1,d:0] Kept as inert:
    [WD] hole{acEX} {0}:: ((s0_acES[fuv:0] *: s1_acEU[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acEW[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                       *: s1_acEU[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acET} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acES[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                                               *: s1_acEU[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                                          *: s0_acEY[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0] *: s1_acES[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "s"
flatten } "s"
extendFlatCache
  Base ["s"]
  [WD]
  s0_acEY[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                        GHC.Prim.~#
                        (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "s"
  Match failed
improveTopFunEqs
  Base ["s"] s_acEY[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acEZ} {0}:: (Base
                                                                   "s" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 124[l:1,d:0] Kept as inert:
    [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                          GHC.Prim.~#
                          (s0_acEY[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                      *: s0_acEY[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                                               *: s1_acEU[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acET} {0}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acES[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0]
                                                          /: s1_acF0[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0] *: s1_acES[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                        *: s0_acEY[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEY[fuv:0]
  s0_acEY[fuv:0]
Unfilled tyvar s_acEY[fuv:0]
Unfilled tyvar s_acEY[fuv:0]
flatten }
  s0_acEY[fuv:0]
  s0_acEY[fuv:0]
extendFlatCache
  *: [s0_acEY[fuv:0], s0_acEY[fuv:0]]
  [WD]
  s0_acF0[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                        *: s0_acEY[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                        *: s0_acEY[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0] *: s0_acEY[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEY[fuv:0] *: s0_acEY[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acEY[fuv:0], s0_acEY[fuv:0]] s_acF0[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                                                  *: s0_acEY[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 125[l:1,d:0] Kept as inert:
    [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0] *: s0_acEY[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s1_acF0[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                       *: s0_acEY[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0]
                                      /: s1_acF0[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acET} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acES[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                                               *: s1_acEU[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                                               *: s0_acEY[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0]
                                                          /: s1_acF0[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0] *: s1_acES[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0]
                                        /: s1_acF0[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEW[fuv:0]
  s0_acF0[fuv:0]
Unfilled tyvar s_acEW[fuv:0]
Unfilled tyvar s_acF0[fuv:0]
flatten }
  s0_acEW[fuv:0]
  s0_acF0[fuv:0]
extendFlatCache
  /: [s0_acEW[fuv:0], s0_acF0[fuv:0]]
  [WD]
  s0_acF2[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0]
                                        /: s1_acF0[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0]
                                        /: s1_acF0[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEW[fuv:0] /: s1_acF0[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acEW[fuv:0], s0_acF0[fuv:0]] s_acF2[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0]
                                                                  /: s1_acF0[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 126[l:1,d:0] Kept as inert:
    [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acF2[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0]
                                       /: s1_acF0[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0]
                                      /: s1_acF0[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acET} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acES[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                                               *: s1_acEU[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                                               *: s0_acEY[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0]
                                                               /: s1_acF0[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0]
                                                          *: s1_acES[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0]
                                        /: s1_acF0[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acEU[fuv:0]
  s0_acF0[fuv:0]
Unfilled tyvar s_acEU[fuv:0]
Unfilled tyvar s_acF0[fuv:0]
flatten }
  s0_acEU[fuv:0]
  s0_acF0[fuv:0]
extendFlatCache
  /: [s0_acEU[fuv:0], s0_acF0[fuv:0]]
  [WD]
  s0_acF4[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0]
                                        /: s1_acF0[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0]
                                        /: s1_acF0[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acEU[fuv:0] /: s1_acF0[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acEU[fuv:0], s0_acF0[fuv:0]] s_acF4[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0]
                                                                  /: s1_acF0[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 127[l:1,d:0] Kept as inert:
    [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acF4[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0]
                                       /: s1_acF0[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0]
                                      *: s1_acES[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acET} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acES[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                                               *: s1_acEU[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                                               *: s0_acEY[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0]
                                                               /: s1_acF0[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0]
                                                               /: s1_acF0[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0]
                                        *: s1_acES[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acF4[fuv:0]
  s0_acES[fuv:0]
Unfilled tyvar s_acF4[fuv:0]
Unfilled tyvar s_acES[fuv:0]
flatten }
  s0_acF4[fuv:0]
  s0_acES[fuv:0]
extendFlatCache
  *: [s0_acF4[fuv:0], s0_acES[fuv:0]]
  [WD]
  s0_acF6[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0]
                                        *: s1_acES[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0]
                                        *: s1_acES[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0] *: s1_acES[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acF4[fuv:0] *: s1_acES[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acF4[fuv:0], s0_acES[fuv:0]] s_acF6[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0]
                                                                  *: s1_acES[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 128[l:1,d:0] Kept as inert:
    [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0] *: s1_acES[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acF6[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0]
                                       *: s1_acES[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                      Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                    GHC.Prim.~#
                                    (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acET} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acES[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0]
                                                               /: s1_acF0[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0]
                                                               /: s1_acF0[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                                               *: s1_acEU[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                                               *: s0_acEY[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0]
                                                               *: s1_acES[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] irred_acEQ {0}:: ((Base "kg"
                                                           *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                        Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
flatten_many {
  s0_acF2[fuv:0]
  s0_acF6[fuv:0]
Unfilled tyvar s_acF2[fuv:0]
Unfilled tyvar s_acF6[fuv:0]
flatten }
  s0_acF2[fuv:0]
  s0_acF6[fuv:0]
extendFlatCache
  Data.UnitsOfMeasure.Syntax.~~ [s0_acF2[fuv:0], s0_acF6[fuv:0]]
  [WD]
  s0_acF8[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                        Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                        Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
doTopReact
  [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                          Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                        GHC.Prim.~#
                        (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
matchFamTcM
  Matching: s0_acF2[fuv:0]
            Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]
  Match failed
improveTopFunEqs
  Data.UnitsOfMeasure.Syntax.~~ [s0_acF2[fuv:0],
                                 s0_acF6[fuv:0]] s_acF8[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                                                  Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                                                GHC.Prim.~#
                                                                (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
addInertCan }
Step 129[l:1,d:0] Kept as inert:
    [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                            Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                          GHC.Prim.~#
                          (s2_acF8[fuv:0] :: Constraint)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                       Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                     GHC.Prim.~#
                                     (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                     /: (Base "s" *: Base "s"))
                                    Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                    /: (Base "s" *: Base "s"))
                                                                   *: Base "kg") (CNonCanonical)
  inerts = {Type-function equalities = [WD] hole{acET} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acES[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0]
                                                               /: s1_acF0[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0]
                                                               /: s1_acF0[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                                               *: s1_acEU[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                                               *: s0_acEY[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0]
                                                               *: s1_acES[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                                               Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                                       /: (Base "s" *: Base "s"))
                                      Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                      /: (Base "s" *: Base "s"))
                                                                     *: Base "kg") (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_acEQ {0}:: ((Base "kg" *: Base "m")
                         /: (Base "s" *: Base "s"))
                        Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                       *: Base "kg") (CNonCanonical)
canEvNC:irred
  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                 *: Base "kg")
can_pred
  IrredPred =  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
               Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                              *: Base "kg")
flatten {
  FM_FlattenAll ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                               *: Base "kg")
matchFamTcM
  Matching: ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
            Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                           *: Base "kg")
  Match failed
matchFamTcM
  Matching: (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "kg" *: Base "m"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acES[fuv:0]
Unfilled tyvar s_acES[fuv:0]
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acEU[fuv:0]
Unfilled tyvar s_acEU[fuv:0]
flatten/flat-cache hit
  *: [s0_acES[fuv:0], s0_acEU[fuv:0]]
  s0_acEW[fuv:0]
Unfilled tyvar s_acEW[fuv:0]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEY[fuv:0]
Unfilled tyvar s_acEY[fuv:0]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEY[fuv:0]
Unfilled tyvar s_acEY[fuv:0]
flatten/flat-cache hit
  *: [s0_acEY[fuv:0], s0_acEY[fuv:0]]
  s0_acF0[fuv:0]
Unfilled tyvar s_acF0[fuv:0]
flatten/flat-cache hit
  /: [s0_acEW[fuv:0], s0_acF0[fuv:0]]
  s0_acF2[fuv:0]
Unfilled tyvar s_acF2[fuv:0]
matchFamTcM
  Matching: (Base "m" /: (Base "s" *: Base "s")) *: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "m" /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acEU[fuv:0]
Unfilled tyvar s_acEU[fuv:0]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEY[fuv:0]
Unfilled tyvar s_acEY[fuv:0]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acEY[fuv:0]
Unfilled tyvar s_acEY[fuv:0]
flatten/flat-cache hit
  *: [s0_acEY[fuv:0], s0_acEY[fuv:0]]
  s0_acF0[fuv:0]
Unfilled tyvar s_acF0[fuv:0]
flatten/flat-cache hit
  /: [s0_acEU[fuv:0], s0_acF0[fuv:0]]
  s0_acF4[fuv:0]
Unfilled tyvar s_acF4[fuv:0]
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acES[fuv:0]
Unfilled tyvar s_acES[fuv:0]
flatten/flat-cache hit
  *: [s0_acF4[fuv:0], s0_acES[fuv:0]]
  s0_acF6[fuv:0]
Unfilled tyvar s_acF6[fuv:0]
flatten/flat-cache hit
  Data.UnitsOfMeasure.Syntax.~~ [s0_acF2[fuv:0], s0_acF6[fuv:0]]
  s0_acF8[fuv:0]
Unfilled tyvar s_acF8[fuv:0]
flatten } s0_acF8[fuv:0]
Emitting new wanted
  irred_acFb :: s0_acF8[fuv:0]
  arising from a use of ‘*:’ at test-suite-force/Tests.hs:49:17-40
addTcEvBind
  acC4
  [W] irred_acEQ
    = irred_acFb `cast` (Sub
                           (Sym
                              U(hole:{acF9}, s0_acF2[fuv:0]
                                             Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0], s0_acF8[fuv:0])_N
                            ; (Trans
                                   (Sym {acF3})
                                   (Trans (Sym {acEX}) (Sym {acET} *: Sym {acEV})_N
                                    /: Trans (Sym {acF1}) (Sym {acEZ} *: Sym {acEZ})_N)_N
                               Data.UnitsOfMeasure.Syntax.~~ Trans
                                                                 (Sym {acF7})
                                                                 (Trans
                                                                      (Sym {acF5})
                                                                      (Sym {acEV}
                                                                       /: Trans
                                                                              (Sym {acF1})
                                                                              (Sym {acEZ}
                                                                               *: Sym {acEZ})_N)_N
                                                                  *: Sym {acET})_N)_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_acFb {0}:: s0_acF8[fuv:0] (CIrredEvCan)
addTcEvBind
  acC4
  [W] irred_acFb = irred_acFa
end stage interact with inerts }
Step 130[l:1,d:0] Irred equal (keep):
    [WD] irred_acFb {0}:: s0_acF8[fuv:0]
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
  inerts = {Type-function equalities = [WD] hole{acET} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acES[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0]
                                                               /: s1_acF0[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0]
                                                               /: s1_acF0[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acEX} {0}:: ((s0_acES[fuv:0]
                                                               *: s1_acEU[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0]
                                                               *: s0_acEY[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0]
                                                               *: s1_acES[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                                               Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
flatten_many {
  "callStack"
  GHC.Stack.Types.CallStack
flatten }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
doTopReact
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
matchClassInst pred = ?callStack::GHC.Stack.Types.CallStack {
matchClass not matching dict ?callStack::GHC.Stack.Types.CallStack
} matchClassInst result NoInstance
try_fundeps
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
addInertCan }
Step 131[l:1,d:0] Kept as inert:
    [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (kept as inert) }
  final_item = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {[WD] hole{acET} {0}:: (Base "kg" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acES[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acEU[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acEY[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acF2[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acF4[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acEX} {0}:: ((s0_acES[fuv:0] *: s1_acEU[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acEW[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0] *: s0_acEY[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s1_acF0[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0] *: s1_acES[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acF6[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                     Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                   GHC.Prim.~#
                                   (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)}
  insols = {}
  others = {[WD] irred_acFa {0}:: s0_acF8[fuv:0] (CIrredEvCan),
            [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{acET} {0}:: (Base "kg" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acES[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEV} {0}:: (Base "m" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acEU[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEZ} {0}:: (Base "s" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acEY[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acF3} {0}:: ((s0_acEW[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acF2[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acF5} {0}:: ((s0_acEU[fuv:0] /: s1_acF0[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acF4[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acEX} {0}:: ((s0_acES[fuv:0] *: s1_acEU[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acEW[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acF1} {0}:: ((s0_acEY[fuv:0] *: s0_acEY[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s1_acF0[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acF7} {0}:: ((s0_acF4[fuv:0] *: s1_acES[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acF6[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acF9} {0}:: ((s0_acF2[fuv:0]
                                    Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]) :: Constraint)
                                  GHC.Prim.~#
                                  (s2_acF8[fuv:0] :: Constraint) (CFunEqCan)
   Tv eqs =}
Filling coercion hole
  acF9 := <s0_acF2[fuv:0]
           Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]>_N
unflattenFmv
  s_acF8[fuv:0] := s0_acF2[fuv:0]
                   Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]
writeMetaTyVar
  s_acF8[fuv:0] :: Constraint := s0_acF2[fuv:0]
                                 Data.UnitsOfMeasure.Syntax.~~ s1_acF6[fuv:0]
Filling coercion hole acF7 := <s0_acF4[fuv:0] *: s1_acES[fuv:0]>_N
unflattenFmv s_acF6[fuv:0] := s0_acF4[fuv:0] *: s1_acES[fuv:0]
writeMetaTyVar
  s_acF6[fuv:0] :: Unit := s0_acF4[fuv:0] *: s1_acES[fuv:0]
Filling coercion hole acF1 := <s0_acEY[fuv:0] *: s0_acEY[fuv:0]>_N
unflattenFmv s_acF0[fuv:0] := s0_acEY[fuv:0] *: s0_acEY[fuv:0]
writeMetaTyVar
  s_acF0[fuv:0] :: Unit := s0_acEY[fuv:0] *: s0_acEY[fuv:0]
Filling coercion hole acEX := <s0_acES[fuv:0] *: s1_acEU[fuv:0]>_N
unflattenFmv s_acEW[fuv:0] := s0_acES[fuv:0] *: s1_acEU[fuv:0]
writeMetaTyVar
  s_acEW[fuv:0] :: Unit := s0_acES[fuv:0] *: s1_acEU[fuv:0]
Filling coercion hole
  acF5 := <s0_acEU[fuv:0] /: (s1_acEY[fuv:0] *: s1_acEY[fuv:0])>_N
unflattenFmv
  s_acF4[fuv:0] := s0_acEU[fuv:0]
                   /: (s1_acEY[fuv:0] *: s1_acEY[fuv:0])
writeMetaTyVar
  s_acF4[fuv:0] :: Unit := s0_acEU[fuv:0]
                           /: (s1_acEY[fuv:0] *: s1_acEY[fuv:0])
Filling coercion hole
  acF3 := <(s0_acES[fuv:0] *: s1_acEU[fuv:0])
           /: (s2_acEY[fuv:0] *: s2_acEY[fuv:0])>_N
unflattenFmv
  s_acF2[fuv:0] := (s0_acES[fuv:0] *: s1_acEU[fuv:0])
                   /: (s2_acEY[fuv:0] *: s2_acEY[fuv:0])
writeMetaTyVar
  s_acF2[fuv:0] :: Unit := (s0_acES[fuv:0] *: s1_acEU[fuv:0])
                           /: (s2_acEY[fuv:0] *: s2_acEY[fuv:0])
Filling coercion hole acEZ := <Base "s">_N
unflattenFmv s_acEY[fuv:0] := Base "s"
writeMetaTyVar s_acEY[fuv:0] :: Unit := Base "s"
Filling coercion hole acEV := <Base "m">_N
unflattenFmv s_acEU[fuv:0] := Base "m"
writeMetaTyVar s_acEU[fuv:0] :: Unit := Base "m"
Filling coercion hole acET := <Base "kg">_N
unflattenFmv s_acES[fuv:0] := Base "kg"
writeMetaTyVar s_acES[fuv:0] :: Unit := Base "kg"
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
zonkSimples done: {}
zonkSimples done:
  {[WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
tcPluginSolve start thoralf-uom-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve gsConvCts Just [ ] [] []
thoralf-solve wsConvCts
  Just [ (= ((_ map (- (Int Int) Int)) ((_ map (+ (Int Int) Int)) (store base "kg" n1) (store base "m" n1)) ((_ map (+ (Int Int) Int)) (store base "s" n1) (store base "s" n1))) ((_ map (+ (Int Int) Int)) ((_ map (- (Int Int) Int)) (store base "m" n1) ((_ map (+ (Int Int) Int)) (store base "s" n1) (store base "s" n1))) (store base "kg" n1))) ] [[WD] irred_acFa {0}:: ((Base
                                                                                                                                                                                                                                                                                                                                                                                    "kg"
                                                                                                                                                                                                                                                                                                                                                                                  *: Base
                                                                                                                                                                                                                                                                                                                                                                                       "m")
                                                                                                                                                                                                                                                                                                                                                                                 /: (Base
                                                                                                                                                                                                                                                                                                                                                                                       "s"
                                                                                                                                                                                                                                                                                                                                                                                     *: Base
                                                                                                                                                                                                                                                                                                                                                                                          "s"))
                                                                                                                                                                                                                                                                                                                                                                                Data.UnitsOfMeasure.Syntax.~~ ((Base
                                                                                                                                                                                                                                                                                                                                                                                                                  "m"
                                                                                                                                                                                                                                                                                                                                                                                                                /: (Base
                                                                                                                                                                                                                                                                                                                                                                                                                      "s"
                                                                                                                                                                                                                                                                                                                                                                                                                    *: Base
                                                                                                                                                                                                                                                                                                                                                                                                                         "s"))
                                                                                                                                                                                                                                                                                                                                                                                                               *: Base
                                                                                                                                                                                                                                                                                                                                                                                                                    "kg") (CNonCanonical)] []
thoralf-solve decls []
thoralf-solve decls filtered []
thoralf-solve givens []
thoralf-solve givens filtered []
thoralf-solve wanteds
  [[WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve wanteds filtered
  [[WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve simplified given sexprs []
thoralf-solve simplified wanteds []
tcPluginSolve ok thoralf-uom-plugin
  solved = []
  new    = []
tcPluginSolve start uom-eq-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok uom-eq-plugin
  solved = []
  new    = [[WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                   /: (Base "s" *: Base "s"))
                                  Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                  /: (Base "s" *: Base "s"))
                                                                 *: Base "kg") (CNonCanonical)]
tcPluginSolve start uom-unpack-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok uom-unpack-plugin
  solved = []
  new    = []
solveSimple going round again:
  0
  True
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                     /: (Base "s" *: Base "s"))
                                    Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                    /: (Base "s" *: Base "s"))
                                                                   *: Base "kg") (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] irred_acFa {0}:: ((Base "kg"
                                                           *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                       /: (Base "s" *: Base "s"))
                                      Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                      /: (Base "s" *: Base "s"))
                                                                     *: Base "kg") (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                         /: (Base "s" *: Base "s"))
                        Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                       *: Base "kg") (CNonCanonical)
canEvNC:irred
  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                 *: Base "kg")
can_pred
  IrredPred =  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
               Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                              *: Base "kg")
flatten {
  FM_FlattenAll ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                               *: Base "kg")
matchFamTcM
  Matching: ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
            Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                           *: Base "kg")
  Match failed
matchFamTcM
  Matching: (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "kg" *: Base "m"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
New coercion hole: acFd
Emitting new coercion hole
  {acFd} :: (Base "kg" :: Unit) GHC.Prim.~# (s0_acFc[fuv:0] :: Unit)
extendFlatCache
  Base ["kg"]
  [WD]
  s0_acFc[fuv:0]
flatten/flat-cache miss
  Base ["kg"]
  s_acFc[fuv:0]
  [WD] hole{acFd} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (s0_acFc[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "m"
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
New coercion hole: acFf
Emitting new coercion hole
  {acFf} :: (Base "m" :: Unit) GHC.Prim.~# (s0_acFe[fuv:0] :: Unit)
extendFlatCache
  Base ["m"]
  [WD]
  s0_acFe[fuv:0]
flatten/flat-cache miss
  Base ["m"]
  s_acFe[fuv:0]
  [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                        GHC.Prim.~#
                        (s0_acFe[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acFc[fuv:0] *: s1_acFe[fuv:0]
  Match failed
New coercion hole: acFh
Emitting new coercion hole
  {acFh} :: ((s0_acFc[fuv:0] *: s1_acFe[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acFg[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acFc[fuv:0], s0_acFe[fuv:0]]
  [WD]
  s0_acFg[fuv:0]
flatten/flat-cache miss
  *: [s0_acFc[fuv:0], s0_acFe[fuv:0]]
  s_acFg[fuv:0]
  [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0] *: s1_acFe[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acFg[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
New coercion hole: acFj
Emitting new coercion hole
  {acFj} :: (Base "s" :: Unit) GHC.Prim.~# (s0_acFi[fuv:0] :: Unit)
extendFlatCache
  Base ["s"]
  [WD]
  s0_acFi[fuv:0]
flatten/flat-cache miss
  Base ["s"]
  s_acFi[fuv:0]
  [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                        GHC.Prim.~#
                        (s0_acFi[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acFi[fuv:0]
Unfilled tyvar s_acFi[fuv:0]
matchFamTcM
  Matching: s0_acFi[fuv:0] *: s0_acFi[fuv:0]
  Match failed
New coercion hole: acFl
Emitting new coercion hole
  {acFl} :: ((s0_acFi[fuv:0] *: s0_acFi[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s1_acFk[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acFi[fuv:0], s0_acFi[fuv:0]]
  [WD]
  s0_acFk[fuv:0]
flatten/flat-cache miss
  *: [s0_acFi[fuv:0], s0_acFi[fuv:0]]
  s_acFk[fuv:0]
  [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0] *: s0_acFi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s1_acFk[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acFg[fuv:0] /: s1_acFk[fuv:0]
  Match failed
New coercion hole: acFn
Emitting new coercion hole
  {acFn} :: ((s0_acFg[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acFm[fuv:0] :: Unit)
extendFlatCache
  /: [s0_acFg[fuv:0], s0_acFk[fuv:0]]
  [WD]
  s0_acFm[fuv:0]
flatten/flat-cache miss
  /: [s0_acFg[fuv:0], s0_acFk[fuv:0]]
  s_acFm[fuv:0]
  [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acFm[fuv:0] :: Unit)
matchFamTcM
  Matching: (Base "m" /: (Base "s" *: Base "s")) *: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "m" /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acFe[fuv:0]
Unfilled tyvar s_acFe[fuv:0]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acFi[fuv:0]
Unfilled tyvar s_acFi[fuv:0]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acFi[fuv:0]
Unfilled tyvar s_acFi[fuv:0]
flatten/flat-cache hit
  *: [s0_acFi[fuv:0], s0_acFi[fuv:0]]
  s0_acFk[fuv:0]
Unfilled tyvar s_acFk[fuv:0]
matchFamTcM
  Matching: s0_acFe[fuv:0] /: s1_acFk[fuv:0]
  Match failed
New coercion hole: acFp
Emitting new coercion hole
  {acFp} :: ((s0_acFe[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acFo[fuv:0] :: Unit)
extendFlatCache
  /: [s0_acFe[fuv:0], s0_acFk[fuv:0]]
  [WD]
  s0_acFo[fuv:0]
flatten/flat-cache miss
  /: [s0_acFe[fuv:0], s0_acFk[fuv:0]]
  s_acFo[fuv:0]
  [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acFo[fuv:0] :: Unit)
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acFc[fuv:0]
Unfilled tyvar s_acFc[fuv:0]
matchFamTcM
  Matching: s0_acFo[fuv:0] *: s1_acFc[fuv:0]
  Match failed
New coercion hole: acFr
Emitting new coercion hole
  {acFr} :: ((s0_acFo[fuv:0] *: s1_acFc[fuv:0]) :: Unit)
            GHC.Prim.~#
            (s2_acFq[fuv:0] :: Unit)
extendFlatCache
  *: [s0_acFo[fuv:0], s0_acFc[fuv:0]]
  [WD]
  s0_acFq[fuv:0]
flatten/flat-cache miss
  *: [s0_acFo[fuv:0], s0_acFc[fuv:0]]
  s_acFq[fuv:0]
  [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0] *: s1_acFc[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acFq[fuv:0] :: Unit)
matchFamTcM
  Matching: s0_acFm[fuv:0]
            Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]
  Match failed
New coercion hole: acFt
Emitting new coercion hole
  {acFt} :: ((s0_acFm[fuv:0]
              Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
            GHC.Prim.~#
            (s2_acFs[fuv:0] :: Constraint)
extendFlatCache
  Data.UnitsOfMeasure.Syntax.~~ [s0_acFm[fuv:0], s0_acFq[fuv:0]]
  [WD]
  s0_acFs[fuv:0]
flatten/flat-cache miss
  Data.UnitsOfMeasure.Syntax.~~ [s0_acFm[fuv:0], s0_acFq[fuv:0]]
  s_acFs[fuv:0]
  [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                          Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                        GHC.Prim.~#
                        (s2_acFs[fuv:0] :: Constraint)
flatten } s0_acFs[fuv:0]
Emitting new wanted
  irred_acFu :: s0_acFs[fuv:0]
  arising from a use of ‘*:’ at test-suite-force/Tests.hs:49:17-40
addTcEvBind
  acC4
  [W] irred_acFa
    = irred_acFu `cast` (Sub
                           (Sym
                              U(hole:{acFt}, s0_acFm[fuv:0]
                                             Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0], s0_acFs[fuv:0])_N
                            ; (Trans
                                   (Sym {acFn})
                                   (Trans (Sym {acFh}) (Sym {acFd} *: Sym {acFf})_N
                                    /: Trans (Sym {acFl}) (Sym {acFj} *: Sym {acFj})_N)_N
                               Data.UnitsOfMeasure.Syntax.~~ Trans
                                                                 (Sym {acFr})
                                                                 (Trans
                                                                      (Sym {acFp})
                                                                      (Sym {acFf}
                                                                       /: Trans
                                                                              (Sym {acFl})
                                                                              (Sym {acFj}
                                                                               *: Sym {acFj})_N)_N
                                                                  *: Sym {acFd})_N)_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
doTopReact [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
addInertCan }
Step 132[l:1,d:0] Kept as inert:
    [WD] irred_acFu {0}:: s0_acFs[fuv:0]
End solver pipeline (kept as inert) }
  final_item = [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acFd} {0}:: (Base "kg" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Irreds = [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acFf} {0}:: (Base
                                                           "m" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0] *: s1_acFe[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0] *: s0_acFi[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0] *: s1_acFc[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acFd} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "kg"
flatten } "kg"
extendFlatCache
  Base ["kg"]
  [WD]
  s0_acFc[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acFd} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acFd} {0}:: (Base "kg" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acFd} {0}:: (Base "kg" :: Unit)
                        GHC.Prim.~#
                        (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "kg"
  Match failed
improveTopFunEqs
  Base ["kg"] s_acFc[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acFd} {0}:: (Base
                                                                   "kg" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 133[l:1,d:0] Kept as inert:
    [WD] hole{acFd} {0}:: (Base "kg" :: Unit)
                          GHC.Prim.~#
                          (s0_acFc[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acFd} {0}:: (Base "kg" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acFd} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                                          *: s1_acFe[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0] *: s0_acFi[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0] *: s1_acFc[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "m"
flatten } "m"
extendFlatCache
  Base ["m"]
  [WD]
  s0_acFe[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                        GHC.Prim.~#
                        (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "m"
  Match failed
improveTopFunEqs
  Base ["m"] s_acFe[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acFf} {0}:: (Base
                                                                   "m" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 134[l:1,d:0] Kept as inert:
    [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                          GHC.Prim.~#
                          (s0_acFe[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                      *: s1_acFe[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acFd} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acFj} {0}:: (Base
                                                           "s" :: Unit)
                                                        GHC.Prim.~#
                                                        (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0] *: s0_acFi[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0] *: s1_acFc[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                        *: s1_acFe[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acFc[fuv:0]
  s0_acFe[fuv:0]
Unfilled tyvar s_acFc[fuv:0]
Unfilled tyvar s_acFe[fuv:0]
flatten }
  s0_acFc[fuv:0]
  s0_acFe[fuv:0]
extendFlatCache
  *: [s0_acFc[fuv:0], s0_acFe[fuv:0]]
  [WD]
  s0_acFg[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                        *: s1_acFe[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                        *: s1_acFe[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0] *: s1_acFe[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acFc[fuv:0] *: s1_acFe[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acFc[fuv:0], s0_acFe[fuv:0]] s_acFg[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                                                  *: s1_acFe[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 135[l:1,d:0] Kept as inert:
    [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0] *: s1_acFe[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acFg[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                       *: s1_acFe[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                    GHC.Prim.~#
                                    (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acFd} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                                               *: s1_acFe[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                                          *: s0_acFi[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0] *: s1_acFc[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
flatten_many { "s"
flatten } "s"
extendFlatCache
  Base ["s"]
  [WD]
  s0_acFi[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                      GHC.Prim.~#
                                      (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                        GHC.Prim.~#
                        (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: Base "s"
  Match failed
improveTopFunEqs
  Base ["s"] s_acFi[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acFj} {0}:: (Base
                                                                   "s" :: Unit)
                                                                GHC.Prim.~#
                                                                (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 136[l:1,d:0] Kept as inert:
    [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                          GHC.Prim.~#
                          (s0_acFi[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                     GHC.Prim.~#
                                     (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                      *: s0_acFi[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                                               *: s1_acFe[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFd} {0}:: (Base "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0]
                                                          /: s1_acFk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0] *: s1_acFc[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                        *: s0_acFi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acFi[fuv:0]
  s0_acFi[fuv:0]
Unfilled tyvar s_acFi[fuv:0]
Unfilled tyvar s_acFi[fuv:0]
flatten }
  s0_acFi[fuv:0]
  s0_acFi[fuv:0]
extendFlatCache
  *: [s0_acFi[fuv:0], s0_acFi[fuv:0]]
  [WD]
  s0_acFk[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                        *: s0_acFi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                        *: s0_acFi[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0] *: s0_acFi[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acFi[fuv:0] *: s0_acFi[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acFi[fuv:0], s0_acFi[fuv:0]] s_acFk[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                                                  *: s0_acFi[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 137[l:1,d:0] Kept as inert:
    [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0] *: s0_acFi[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s1_acFk[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                       *: s0_acFi[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0]
                                      /: s1_acFk[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acFd} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                                               *: s1_acFe[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                                               *: s0_acFi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0]
                                                          /: s1_acFk[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0] *: s1_acFc[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0]
                                        /: s1_acFk[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acFg[fuv:0]
  s0_acFk[fuv:0]
Unfilled tyvar s_acFg[fuv:0]
Unfilled tyvar s_acFk[fuv:0]
flatten }
  s0_acFg[fuv:0]
  s0_acFk[fuv:0]
extendFlatCache
  /: [s0_acFg[fuv:0], s0_acFk[fuv:0]]
  [WD]
  s0_acFm[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0]
                                        /: s1_acFk[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0]
                                        /: s1_acFk[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acFg[fuv:0] /: s1_acFk[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acFg[fuv:0], s0_acFk[fuv:0]] s_acFm[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0]
                                                                  /: s1_acFk[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 138[l:1,d:0] Kept as inert:
    [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acFm[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0]
                                       /: s1_acFk[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0]
                                      /: s1_acFk[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acFd} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                                               *: s1_acFe[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                                               *: s0_acFi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0]
                                                               /: s1_acFk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0]
                                                          *: s1_acFc[fuv:0]) :: Unit)
                                                        GHC.Prim.~#
                                                        (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
                                  [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0]
                                        /: s1_acFk[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acFe[fuv:0]
  s0_acFk[fuv:0]
Unfilled tyvar s_acFe[fuv:0]
Unfilled tyvar s_acFk[fuv:0]
flatten }
  s0_acFe[fuv:0]
  s0_acFk[fuv:0]
extendFlatCache
  /: [s0_acFe[fuv:0], s0_acFk[fuv:0]]
  [WD]
  s0_acFo[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0]
                                        /: s1_acFk[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0]
                                        /: s1_acFk[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acFe[fuv:0] /: s1_acFk[fuv:0]
  Match failed
improveTopFunEqs
  /: [s0_acFe[fuv:0], s0_acFk[fuv:0]] s_acFo[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0]
                                                                  /: s1_acFk[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 139[l:1,d:0] Kept as inert:
    [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acFo[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0]
                                       /: s1_acFk[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0]
                                      *: s1_acFc[fuv:0]) :: Unit)
                                    GHC.Prim.~#
                                    (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acFd} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                                               *: s1_acFe[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                                               *: s0_acFi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0]
                                                               /: s1_acFk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0]
                                                               /: s1_acFk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Funeqs = [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                                          Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                                        GHC.Prim.~#
                                                        (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
                         Non-eqs = [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0]
                                        *: s1_acFc[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
flatten_many {
  s0_acFo[fuv:0]
  s0_acFc[fuv:0]
Unfilled tyvar s_acFo[fuv:0]
Unfilled tyvar s_acFc[fuv:0]
flatten }
  s0_acFo[fuv:0]
  s0_acFc[fuv:0]
extendFlatCache
  *: [s0_acFo[fuv:0], s0_acFc[fuv:0]]
  [WD]
  s0_acFq[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0]
                                        *: s1_acFc[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0]
                                        *: s1_acFc[fuv:0]) :: Unit)
                                      GHC.Prim.~#
                                      (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
doTopReact
  [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0] *: s1_acFc[fuv:0]) :: Unit)
                        GHC.Prim.~#
                        (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
matchFamTcM
  Matching: s0_acFo[fuv:0] *: s1_acFc[fuv:0]
  Match failed
improveTopFunEqs
  *: [s0_acFo[fuv:0], s0_acFc[fuv:0]] s_acFq[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0]
                                                                  *: s1_acFc[fuv:0]) :: Unit)
                                                                GHC.Prim.~#
                                                                (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
addInertCan }
Step 140[l:1,d:0] Kept as inert:
    [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0] *: s1_acFc[fuv:0]) :: Unit)
                          GHC.Prim.~#
                          (s2_acFq[fuv:0] :: Unit)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0]
                                       *: s1_acFc[fuv:0]) :: Unit)
                                     GHC.Prim.~#
                                     (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                      Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                    GHC.Prim.~#
                                    (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
  inerts = {Type-function equalities = [WD] hole{acFd} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0]
                                                               /: s1_acFk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0]
                                                               /: s1_acFk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                                               *: s1_acFe[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                                               *: s0_acFi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0]
                                                               *: s1_acFc[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
            Irreds = [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] irred_acFa {0}:: ((Base "kg"
                                                           *: Base "m")
                                                          /: (Base "s" *: Base "s"))
                                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                                         /: (Base
                                                                                               "s"
                                                                                             *: Base
                                                                                                  "s"))
                                                                                        *: Base
                                                                                             "kg") (CNonCanonical)
                                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                        Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
flatten_many {
  s0_acFm[fuv:0]
  s0_acFq[fuv:0]
Unfilled tyvar s_acFm[fuv:0]
Unfilled tyvar s_acFq[fuv:0]
flatten }
  s0_acFm[fuv:0]
  s0_acFq[fuv:0]
extendFlatCache
  Data.UnitsOfMeasure.Syntax.~~ [s0_acFm[fuv:0], s0_acFq[fuv:0]]
  [WD]
  s0_acFs[fuv:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                        Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                        Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                      GHC.Prim.~#
                                      (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
doTopReact
  [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                          Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                        GHC.Prim.~#
                        (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
matchFamTcM
  Matching: s0_acFm[fuv:0]
            Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]
  Match failed
improveTopFunEqs
  Data.UnitsOfMeasure.Syntax.~~ [s0_acFm[fuv:0],
                                 s0_acFq[fuv:0]] s_acFs[fuv:0]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                                                  Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                                                GHC.Prim.~#
                                                                (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
addInertCan }
Step 141[l:1,d:0] Kept as inert:
    [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                            Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                          GHC.Prim.~#
                          (s2_acFs[fuv:0] :: Constraint)
End solver pipeline (kept as inert) }
  final_item = [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                       Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                     GHC.Prim.~#
                                     (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
----------------------------- 
Start solver pipeline {
  work item = [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                     /: (Base "s" *: Base "s"))
                                    Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                    /: (Base "s" *: Base "s"))
                                                                   *: Base "kg") (CNonCanonical)
  inerts = {Type-function equalities = [WD] hole{acFd} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0]
                                                               /: s1_acFk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0]
                                                               /: s1_acFk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                                               *: s1_acFe[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                                               *: s0_acFi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0]
                                                               *: s1_acFc[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                                               Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {Non-eqs = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
runStage canonicalization {
  workitem   =  [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                                       /: (Base "s" *: Base "s"))
                                      Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                      /: (Base "s" *: Base "s"))
                                                                     *: Base "kg") (CNonCanonical)
canonicalize (non-canonical)
  [WD] irred_acFa {0}:: ((Base "kg" *: Base "m")
                         /: (Base "s" *: Base "s"))
                        Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                       *: Base "kg") (CNonCanonical)
canEvNC:irred
  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
  Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                 *: Base "kg")
can_pred
  IrredPred =  ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
               Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                              *: Base "kg")
flatten {
  FM_FlattenAll ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
                Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                               *: Base "kg")
matchFamTcM
  Matching: ((Base "kg" *: Base "m") /: (Base "s" *: Base "s"))
            Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                           *: Base "kg")
  Match failed
matchFamTcM
  Matching: (Base "kg" *: Base "m") /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "kg" *: Base "m"
  Match failed
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acFc[fuv:0]
Unfilled tyvar s_acFc[fuv:0]
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acFe[fuv:0]
Unfilled tyvar s_acFe[fuv:0]
flatten/flat-cache hit
  *: [s0_acFc[fuv:0], s0_acFe[fuv:0]]
  s0_acFg[fuv:0]
Unfilled tyvar s_acFg[fuv:0]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acFi[fuv:0]
Unfilled tyvar s_acFi[fuv:0]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acFi[fuv:0]
Unfilled tyvar s_acFi[fuv:0]
flatten/flat-cache hit
  *: [s0_acFi[fuv:0], s0_acFi[fuv:0]]
  s0_acFk[fuv:0]
Unfilled tyvar s_acFk[fuv:0]
flatten/flat-cache hit
  /: [s0_acFg[fuv:0], s0_acFk[fuv:0]]
  s0_acFm[fuv:0]
Unfilled tyvar s_acFm[fuv:0]
matchFamTcM
  Matching: (Base "m" /: (Base "s" *: Base "s")) *: Base "kg"
  Match failed
matchFamTcM
  Matching: Base "m" /: (Base "s" *: Base "s")
  Match failed
matchFamTcM
  Matching: Base "m"
  Match failed
flatten/flat-cache hit
  Base ["m"]
  s0_acFe[fuv:0]
Unfilled tyvar s_acFe[fuv:0]
matchFamTcM
  Matching: Base "s" *: Base "s"
  Match failed
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acFi[fuv:0]
Unfilled tyvar s_acFi[fuv:0]
matchFamTcM
  Matching: Base "s"
  Match failed
flatten/flat-cache hit
  Base ["s"]
  s0_acFi[fuv:0]
Unfilled tyvar s_acFi[fuv:0]
flatten/flat-cache hit
  *: [s0_acFi[fuv:0], s0_acFi[fuv:0]]
  s0_acFk[fuv:0]
Unfilled tyvar s_acFk[fuv:0]
flatten/flat-cache hit
  /: [s0_acFe[fuv:0], s0_acFk[fuv:0]]
  s0_acFo[fuv:0]
Unfilled tyvar s_acFo[fuv:0]
matchFamTcM
  Matching: Base "kg"
  Match failed
flatten/flat-cache hit
  Base ["kg"]
  s0_acFc[fuv:0]
Unfilled tyvar s_acFc[fuv:0]
flatten/flat-cache hit
  *: [s0_acFo[fuv:0], s0_acFc[fuv:0]]
  s0_acFq[fuv:0]
Unfilled tyvar s_acFq[fuv:0]
flatten/flat-cache hit
  Data.UnitsOfMeasure.Syntax.~~ [s0_acFm[fuv:0], s0_acFq[fuv:0]]
  s0_acFs[fuv:0]
Unfilled tyvar s_acFs[fuv:0]
flatten } s0_acFs[fuv:0]
Emitting new wanted
  irred_acFv :: s0_acFs[fuv:0]
  arising from a use of ‘*:’ at test-suite-force/Tests.hs:49:17-40
addTcEvBind
  acC4
  [W] irred_acFa
    = irred_acFv `cast` (Sub
                           (Sym
                              U(hole:{acFt}, s0_acFm[fuv:0]
                                             Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0], s0_acFs[fuv:0])_N
                            ; (Trans
                                   (Sym {acFn})
                                   (Trans (Sym {acFh}) (Sym {acFd} *: Sym {acFf})_N
                                    /: Trans (Sym {acFl}) (Sym {acFj} *: Sym {acFj})_N)_N
                               Data.UnitsOfMeasure.Syntax.~~ Trans
                                                                 (Sym {acFr})
                                                                 (Trans
                                                                      (Sym {acFp})
                                                                      (Sym {acFf}
                                                                       /: Trans
                                                                              (Sym {acFl})
                                                                              (Sym {acFj}
                                                                               *: Sym {acFj})_N)_N
                                                                  *: Sym {acFd})_N)_N))
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] irred_acFv {0}:: s0_acFs[fuv:0] (CIrredEvCan)
addTcEvBind
  acC4
  [W] irred_acFv = irred_acFu
end stage interact with inerts }
Step 142[l:1,d:0] Irred equal (keep):
    [WD] irred_acFv {0}:: s0_acFs[fuv:0]
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  work item = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
  inerts = {Type-function equalities = [WD] hole{acFd} {0}:: (Base
                                                                "kg" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                                             GHC.Prim.~#
                                                             (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0]
                                                               /: s1_acFk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0]
                                                               /: s1_acFk[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0]
                                                               *: s1_acFe[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0]
                                                               *: s0_acFi[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0]
                                                               *: s1_acFc[fuv:0]) :: Unit)
                                                             GHC.Prim.~#
                                                             (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
                                       [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                                               Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                                             GHC.Prim.~#
                                                             (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
            Irreds = [WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan)
            Unsolved goals = 1}
           Solved dicts [WD] $dFractional_aciw {0}:: Fractional Double
                        [WD] $dNum_ackl {0}:: Num Double
                        [WD] $dEq_acxx {0}:: Eq String
                        [WD] $dEq_acCM {1}:: Eq Char
                        [WD] $dShow_acxy {0}:: Show String
                        [WD] $dShow_acCS {1}:: Show Char
                        [WD] $dShow_acA6 {0}:: Show Double
                        [WD] $dKnownSymbol_acDZ {2}:: GHC.TypeLits.KnownSymbol "kg"
                        [WD] $dKnownSymbol_acE9 {2}:: GHC.TypeLits.KnownSymbol "m"
                        [WD] $dKnownSymbol_acEa {2}:: GHC.TypeLits.KnownSymbol "s"
                        [WD] $dKnownUnit_acEc {0}:: KnownUnit
                                                      ('["kg", "m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownUnit_acDL {0}:: KnownUnit
                                                      ('["kg"] 'Data.UnitsOfMeasure.Syntax.:/ '[])
                        [WD] $dKnownUnit_acE6 {0}:: KnownUnit
                                                      ('["m"]
                                                       'Data.UnitsOfMeasure.Syntax.:/ '["s", "s"])
                        [WD] $dKnownList_acEd {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg", "m"]
                        [WD] $dKnownList_acDQ {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["kg"]
                        [WD] $dKnownList_acE7 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["m"]
                        [WD] $dKnownList_acE8 {1}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s", "s"]
                        [WD] $dKnownList_acEb {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '["s"]
                        [WD] $dKnownList_acE0 {2}:: Data.UnitsOfMeasure.Singleton.KnownList
                                                      '[]
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
flatten_many {
  "callStack"
  GHC.Stack.Types.CallStack
flatten }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
doTopReact
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
matchClassInst pred = ?callStack::GHC.Stack.Types.CallStack {
matchClass not matching dict ?callStack::GHC.Stack.Types.CallStack
} matchClassInst result NoInstance
try_fundeps
  [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new non-eq inert item: [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
addInertCan }
Step 143[l:1,d:0] Kept as inert:
    [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (kept as inert) }
  final_item = [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {[WD] hole{acFd} {0}:: (Base "kg" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acFc[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acFe[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                   GHC.Prim.~#
                                   (s0_acFi[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acFm[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acFo[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0] *: s1_acFe[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acFg[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0] *: s0_acFi[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s1_acFk[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0] *: s1_acFc[fuv:0]) :: Unit)
                                   GHC.Prim.~#
                                   (s2_acFq[fuv:0] :: Unit) (CFunEqCan),
             [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                     Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                   GHC.Prim.~#
                                   (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)}
  insols = {}
  others = {[WD] irred_acFu {0}:: s0_acFs[fuv:0] (CIrredEvCan),
            [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{acFd} {0}:: (Base "kg" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acFc[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acFf} {0}:: (Base "m" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acFe[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acFj} {0}:: (Base "s" :: Unit)
                                  GHC.Prim.~#
                                  (s0_acFi[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acFn} {0}:: ((s0_acFg[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acFm[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acFp} {0}:: ((s0_acFe[fuv:0] /: s1_acFk[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acFo[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acFh} {0}:: ((s0_acFc[fuv:0] *: s1_acFe[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acFg[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acFl} {0}:: ((s0_acFi[fuv:0] *: s0_acFi[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s1_acFk[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acFr} {0}:: ((s0_acFo[fuv:0] *: s1_acFc[fuv:0]) :: Unit)
                                  GHC.Prim.~#
                                  (s2_acFq[fuv:0] :: Unit) (CFunEqCan)
            [WD] hole{acFt} {0}:: ((s0_acFm[fuv:0]
                                    Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]) :: Constraint)
                                  GHC.Prim.~#
                                  (s2_acFs[fuv:0] :: Constraint) (CFunEqCan)
   Tv eqs =}
Filling coercion hole
  acFt := <s0_acFm[fuv:0]
           Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]>_N
unflattenFmv
  s_acFs[fuv:0] := s0_acFm[fuv:0]
                   Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]
writeMetaTyVar
  s_acFs[fuv:0] :: Constraint := s0_acFm[fuv:0]
                                 Data.UnitsOfMeasure.Syntax.~~ s1_acFq[fuv:0]
Filling coercion hole acFr := <s0_acFo[fuv:0] *: s1_acFc[fuv:0]>_N
unflattenFmv s_acFq[fuv:0] := s0_acFo[fuv:0] *: s1_acFc[fuv:0]
writeMetaTyVar
  s_acFq[fuv:0] :: Unit := s0_acFo[fuv:0] *: s1_acFc[fuv:0]
Filling coercion hole acFl := <s0_acFi[fuv:0] *: s0_acFi[fuv:0]>_N
unflattenFmv s_acFk[fuv:0] := s0_acFi[fuv:0] *: s0_acFi[fuv:0]
writeMetaTyVar
  s_acFk[fuv:0] :: Unit := s0_acFi[fuv:0] *: s0_acFi[fuv:0]
Filling coercion hole acFh := <s0_acFc[fuv:0] *: s1_acFe[fuv:0]>_N
unflattenFmv s_acFg[fuv:0] := s0_acFc[fuv:0] *: s1_acFe[fuv:0]
writeMetaTyVar
  s_acFg[fuv:0] :: Unit := s0_acFc[fuv:0] *: s1_acFe[fuv:0]
Filling coercion hole
  acFp := <s0_acFe[fuv:0] /: (s1_acFi[fuv:0] *: s1_acFi[fuv:0])>_N
unflattenFmv
  s_acFo[fuv:0] := s0_acFe[fuv:0]
                   /: (s1_acFi[fuv:0] *: s1_acFi[fuv:0])
writeMetaTyVar
  s_acFo[fuv:0] :: Unit := s0_acFe[fuv:0]
                           /: (s1_acFi[fuv:0] *: s1_acFi[fuv:0])
Filling coercion hole
  acFn := <(s0_acFc[fuv:0] *: s1_acFe[fuv:0])
           /: (s2_acFi[fuv:0] *: s2_acFi[fuv:0])>_N
unflattenFmv
  s_acFm[fuv:0] := (s0_acFc[fuv:0] *: s1_acFe[fuv:0])
                   /: (s2_acFi[fuv:0] *: s2_acFi[fuv:0])
writeMetaTyVar
  s_acFm[fuv:0] :: Unit := (s0_acFc[fuv:0] *: s1_acFe[fuv:0])
                           /: (s2_acFi[fuv:0] *: s2_acFi[fuv:0])
Filling coercion hole acFj := <Base "s">_N
unflattenFmv s_acFi[fuv:0] := Base "s"
writeMetaTyVar s_acFi[fuv:0] :: Unit := Base "s"
Filling coercion hole acFf := <Base "m">_N
unflattenFmv s_acFe[fuv:0] := Base "m"
writeMetaTyVar s_acFe[fuv:0] :: Unit := Base "m"
Filling coercion hole acFd := <Base "kg">_N
unflattenFmv s_acFc[fuv:0] := Base "kg"
writeMetaTyVar s_acFc[fuv:0] :: Unit := Base "kg"
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
zonkSimples done: {}
zonkSimples done:
  {[WD] irred_acFu {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
tcPluginSolve start thoralf-uom-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acFu {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve gsConvCts Just [ ] [] []
thoralf-solve wsConvCts
  Just [ (= ((_ map (- (Int Int) Int)) ((_ map (+ (Int Int) Int)) (store base "kg" n1) (store base "m" n1)) ((_ map (+ (Int Int) Int)) (store base "s" n1) (store base "s" n1))) ((_ map (+ (Int Int) Int)) ((_ map (- (Int Int) Int)) (store base "m" n1) ((_ map (+ (Int Int) Int)) (store base "s" n1) (store base "s" n1))) (store base "kg" n1))) ] [[WD] irred_acFu {0}:: ((Base
                                                                                                                                                                                                                                                                                                                                                                                    "kg"
                                                                                                                                                                                                                                                                                                                                                                                  *: Base
                                                                                                                                                                                                                                                                                                                                                                                       "m")
                                                                                                                                                                                                                                                                                                                                                                                 /: (Base
                                                                                                                                                                                                                                                                                                                                                                                       "s"
                                                                                                                                                                                                                                                                                                                                                                                     *: Base
                                                                                                                                                                                                                                                                                                                                                                                          "s"))
                                                                                                                                                                                                                                                                                                                                                                                Data.UnitsOfMeasure.Syntax.~~ ((Base
                                                                                                                                                                                                                                                                                                                                                                                                                  "m"
                                                                                                                                                                                                                                                                                                                                                                                                                /: (Base
                                                                                                                                                                                                                                                                                                                                                                                                                      "s"
                                                                                                                                                                                                                                                                                                                                                                                                                    *: Base
                                                                                                                                                                                                                                                                                                                                                                                                                         "s"))
                                                                                                                                                                                                                                                                                                                                                                                                               *: Base
                                                                                                                                                                                                                                                                                                                                                                                                                    "kg") (CNonCanonical)] []
thoralf-solve decls []
thoralf-solve decls filtered []
thoralf-solve givens []
thoralf-solve givens filtered []
thoralf-solve wanteds
  [[WD] irred_acFu {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve wanteds filtered
  [[WD] irred_acFu {0}:: ((Base "kg" *: Base "m")
                          /: (Base "s" *: Base "s"))
                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m" /: (Base "s" *: Base "s"))
                                                        *: Base "kg") (CNonCanonical),
   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
thoralf-solve simplified given sexprs []
thoralf-solve simplified wanteds []
tcPluginSolve ok thoralf-uom-plugin
  solved = []
  new    = []
tcPluginSolve start uom-eq-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acFu {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok uom-eq-plugin
  solved = []
  new    = [[WD] irred_acFu {0}:: ((Base "kg" *: Base "m")
                                   /: (Base "s" *: Base "s"))
                                  Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                  /: (Base "s" *: Base "s"))
                                                                 *: Base "kg") (CNonCanonical)]
tcPluginSolve start uom-unpack-plugin
  given   = []
  derived = []
  wanted  = [[WD] irred_acFu {0}:: ((Base "kg" *: Base "m")
                                    /: (Base "s" *: Base "s"))
                                   Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                   /: (Base "s" *: Base "s"))
                                                                  *: Base "kg") (CNonCanonical),
             [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)]
tcPluginSolve ok uom-unpack-plugin
  solved = []
  new    = []
solveSimple going round again:
  0
  True
Adding error:
  test-suite-force/Tests.hs:1:1: error:
      solveSimpleWanteds: too many iterations (limit = 6)
        Set limit with -fconstraint-solver-iterations=n; n=0 for no limit
        Simples = {[WD] $dFractional_aciw {0}:: Fractional
                                                  a0 (CNonCanonical),
                   [WD] hole{acix} {0}:: (MkUnit "m" /: (MkUnit "s" *: MkUnit "s"))
                                         ~
                                         (MkUnit "m" /: (MkUnit "s" ^: 2)) (CNonCanonical),
                   [WD] $dNum_ackl {0}:: Num a0 (CNonCanonical),
                   [WD] hole{ackm} {0}:: MkUnit "kg" ~ Base "kg" (CNonCanonical),
                   [WD] $dNum_ackx {0}:: Num a0 (CNonCanonical),
                   [WD] irred_acky {0}:: w0
                                         Data.UnitsOfMeasure.Syntax.~~ (u0 *: v0) (CNonCanonical),
                   [WD] hole{ackz} {0}:: (MkUnit "m" /: (MkUnit "s" ^: 2))
                                         ~
                                         u0 (CNonCanonical),
                   [WD] hole{ackA} {0}:: Base "kg" ~ v0 (CNonCanonical),
                   [WD] hole{ackB} {0}:: w0 ~ MkUnit "N" (CNonCanonical),
                   [WD] $dEq_acxx {0}:: Eq a0 (CNonCanonical),
                   [WD] $dShow_acxy {0}:: Show a0 (CNonCanonical),
                   [WD] $dIP_acxE {0}:: HasCallStack (CNonCanonical),
                   [WD] $dShow_acA6 {0}:: Show a0 (CNonCanonical),
                   [WD] $dKnownUnit_acA7 {0}:: KnownUnit (Unpack u0) (CNonCanonical),
                   [WD] hole{acA8} {0}:: Base "kg" ~ u0 (CNonCanonical),
                   [WD] $dEq_acAc {0}:: Eq a0 (CNonCanonical),
                   [WD] $dShow_acAd {0}:: Show a0 (CNonCanonical),
                   [WD] $dIP_acAe {0}:: HasCallStack (CNonCanonical),
                   [WD] $dShow_acAh {0}:: Show a0 (CNonCanonical),
                   [WD] $dKnownUnit_acAi {0}:: KnownUnit (Unpack u0) (CNonCanonical),
                   [WD] hole{acAj} {0}:: (MkUnit "m" /: (MkUnit "s" ^: 2))
                                         ~
                                         u0 (CNonCanonical),
                   [WD] $dEq_acAn {0}:: Eq a0 (CNonCanonical),
                   [WD] $dShow_acAo {0}:: Show a0 (CNonCanonical),
                   [WD] $dIP_acAp {0}:: HasCallStack (CNonCanonical),
                   [WD] $dShow_acAs {0}:: Show a0 (CNonCanonical),
                   [WD] $dKnownUnit_acAt {0}:: KnownUnit (Unpack u0) (CNonCanonical),
                   [WD] hole{acAu} {0}:: MkUnit "N" ~ u0 (CNonCanonical)}
        WC = WC {wc_simple =
                   [WD] irred_acFu {0}:: ((Base "kg" *: Base "m")
                                          /: (Base "s" *: Base "s"))
                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                         /: (Base "s" *: Base "s"))
                                                                        *: Base
                                                                             "kg") (CNonCanonical)
                   [WD] irred_acFu {0}:: ((Base "kg" *: Base "m")
                                          /: (Base "s" *: Base "s"))
                                         Data.UnitsOfMeasure.Syntax.~~ ((Base "m"
                                                                         /: (Base "s" *: Base "s"))
                                                                        *: Base
                                                                             "kg") (CNonCanonical)
                   [WD] $dIP_acD3 {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
tcPluginStop thoralf-uom-plugin
tcPluginStop uom-eq-plugin
tcPluginStop uom-unpack-plugin
